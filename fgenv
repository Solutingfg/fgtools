#!/bin/bash

# History control
#HISTFILE
#HISTSIZE=10000
#HISTFILESIZE=20000

## GENERAL
# Functions

function pathmunge {
## Add to PATH if not exists (default before or specify after)
    if ! echo $PATH | /bin/egrep -q "(^|:)$1($|:)" ; then
        if [ "$2" = "after" ] ; then
            PATH=$PATH:$1
        else
            PATH=$1:$PATH
        fi
    fi
}

function pathremove {
    PATH=:$PATH:
    PATH=${PATH//:$1:/:}
    PATH=${PATH#:}
    PATH=${PATH%:}
}


[ "${1}" == "-s" ] && SILENT=TRUE || unset SILENT
#TIMEFORMAT="Time Elapsed : %3Rs"

# WORKAROUND DEFAULT ENV
# Default Shell Deconnection Timeout
[ -n "${TMOUT}" ] && echo -e TMOUT=${TMOUT} unsetting TMOUT; unset TMOUT

#WORKDIR="${0%/*}" # Not working when script is not executed but sourced
#if [ -z "${WORKDIR}" ]
#then
#    [ -x "${BI_PATH}" ] && WORKDIR=${BI_PATH}
#else
    [ -h "${BASH_SOURCE}" ] && echo ${BASH_SOURCE} is a link && SOURCED_FILE_PATH=$(readlink ${BASH_SOURCE}) || SOURCED_FILE_PATH=${BASH_SOURCE}
    WORKDIR=$(dirname ${SOURCED_FILE_PATH})
    [ -d "${WORKDIR}/../bin" ] && WORKDIR=$(dirname ${WORKDIR})
    [ -z "${BI_PATH}" ] && BI_PATH=${WORKDIR}
#fi

BINDIR=${WORKDIR}/bin
EXADIR=${WORKDIR}/exadata
ZRADIR=${WORKDIR}/zdlra
APPLIANCEDIR=${WORKDIR}/appliance
LIBDIR=${WORKDIR}/lib
[ $(grep -c "${BINDIR}" <<< ${PATH}) -eq 0 ] && export PATH=$PATH:${BINDIR}:.
[ $(grep -c "${EXADIR}" <<< ${PATH}) -eq 0 ] && export PATH=$PATH:${EXADIR}:.
[ $(grep -c "${ZRADIR}" <<< ${PATH}) -eq 0 ] && export PATH=$PATH:${ZRADIR}:.
[ $(grep -c "${APPLIANCEDIR}" <<< ${PATH}) -eq 0 ] && export PATH=$PATH:${APPLIANCEDIR}:.
[ $(grep -c "${LIBDIR}" <<< ${LD_LIBRARY_PATH}) -eq 0 ] && export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:${LIBDIR}
[ $(grep -c "${WORKDIR}" <<< ${MANPATH}) -eq 0 ] && export MANPATH="$(manpath -g):${WORKDIR}/usr/share/man"


## FGR : SCRIPT_DIR is from /etc/profile.d/prsyslib.sh (previously from bienv.sh)
#SCRIPT_DIR=${TOOLKIT_BIN:-/oracle/exploit}
#[ -x /prsyslib/toolunix/bin ] && SCRIPT_DIR=/prsyslib/toolunix/bin
#[ -x /oracle/exploit ] && SCRIPT_DIR=/oracle/exploit
[ -z "${SCRIPT_DIR}" ] && SCRIPT_DIR=${TOOLKIT_BIN:-$(dirname $(which --skip-alias ora_functions.sh &>/dev/null) &>/dev/null)}


## IF EXADATA
if [ $(hostname | grep -E "dbadm|biexa|bizra") ]; then
  PLATFORM=ORACLE_APPLIANCE
  [ $(hostname | grep "mez") ] && WELCOME_MSG="Plateform : ZDLRA" 
  [ $(hostname | grep -E "mex|bfx") ] && WELCOME_MSG="Plateform : EXADATA"
  [ $(hostname | grep "dbadm") ] && WELCOME_MSG+=" BI Legacy (VIOLET)"
  [ $(hostname | grep "biexa") ] && WELCOME_MSG="Plateform : EXADATA Converged (CNVG)"
  [ $(hostname | grep "bizra") ] && WELCOME_MSG="Plateform : ZDLRA Converged (CNVG)"
  alias fgenv &>/dev/null || alias fgenv=". ${LIBDIR}/fgenv"
  HN=$(hostname -s)
  #echo ${HN#${HN%?}}
  HN_BASE=${HN%?}
  HN_NUM=${HN#${HN%?}}
  HN_INT_APPL=$(hostname -A | awk -F. '{print $1}')
  #HOSTNAME_NUM=$(v=$(hostname -s);echo ${v: -1})
  #INSTANCE_NUM=$(v=$(hostname -s); [ $((${v: -1} % 2)) = 1 ] && echo 1 || echo 2)
## FGR : Managed by prsyslib.sh #[ ! -d "/prsyslib" ] && [ $(grep -c "/oracle/scripts" <<< ${PATH}) -eq 0 ] && export PATH=$PATH:/oracle/scripts:/oracle/exploit
else
  PLATFORM=LINUX
  WELCOME_MSG="Plateform : VIOLET (Hors Exadata)"
  #export PATH=$PATH:${WORKDIR}/bin:.
  alias fgenv=". ${LIBDIR}/fgenv"
  [ ! -f /etc/profile.d/zz-fgenv.sh ] && [ $(id -u) -eq 0 ] && echo ln -s ${LIBDIR}/fgenv /etc/profile.d/zz-fgenv.sh
  export LANG=C
fi


## DEBUG
if [ -n "${DBG}" ]
then
echo "0=$0 1=$1 2=$2"
env | grep FGR
echo "which fgenv"
which fgenv
echo "locate fgenv"
locate fgenv
echo WORKDIR=${WORKDIR}
echo BINDIR=${BINDIR}
echo LIBDIR=${LIBDIR}
sysctl net.ipv4.tcp_keepalive_time net.ipv4.tcp_keepalive_intvl net.ipv4.tcp_keepalive_probes
fi


## PROMPT
# Noir        0;30  # Blanc 1;37
# Gris foncé  1;30  # Gris clair 0;37
# Rouge       0;31  # Rouge clair  1;31
# Vert        0;32  # Vert clair   1;32
# Jaune       0;33  # Jaune clair  1;33
# Bleu        0;34  # Bleu clair   1;34
# Violet      0;35  # Violet clair 1;35
# Cyan        0;36  # Cyan clair   1;36
# Blanc       0;37  # Blanc clair  1;37


case ${USER} in
    root)
        USR_COLOR='31'
        SRV_COLOR='31'
        SRV_NUM_COLOR='36'
        PATH_COLOR='37'
        OSID_COLOR='31'
        OVER_COLOR='33'
        SH_MARK_COLOR='31'
        ;;
    oracle)
        USR_COLOR='32'
        SRV_COLOR='34'
        SRV_NUM_COLOR='36'
        PATH_COLOR='37'
        OSID_COLOR='31'
        OVER_COLOR='33'
        SH_MARK_COLOR='32'
        ;;
    *)
        USR_COLOR='35'
        SRV_COLOR='34'
        SRV_NUM_COLOR='36'
        PATH_COLOR='37'
        OSID_COLOR='31'
        OVER_COLOR='33'
        SH_MARK_COLOR='32'
        ;;
esac

#export PS1='\[\e[1;31m\]\u\[\e[0;0m\]@\[\e[1;34m\]\h\[\e[0;0m\]:\w\$ '
## FGR 2023-09 : To test# export PS1="\[\e[32m\]\$(printf %s%s\ %-\$((\$(tput cols)-12))s '## ' \$(date '+%d/%m/%y %H:%M:%S'))\[\e[0m\]\n\[\e[0;96m\]\u\[\e[0m\]@\[\e[0;93m\]\h:\[\e[0m\]\[\e[0;92m\]\W\[\e[0m\]# "

#[ -z "$ORACLE_HOME" ] && unset ORAVER || ORAVER=${ORACLE_HOME##*/product/}; ORAVER=${ORAVER%/*}
#ORAVER=$(ORAVER=${ORACLE_HOME##*/product/}; ORAVER=${ORAVER%/*}; echo $ORAVER)

## HighLight Color
case $(hostname --fqdn | cut -d'.' -f2- | tr '[:upper:]' '[:lower:]') in
    *prdres)  WELCOME_MSG+="\nEnvironnement : PRD"
        HL_COLOR=';41'
        HL_COLOR2=';47'
        ENV=PRD
    ;;
    *intres)  WELCOME_MSG+="\nEnvironnement : HPR (INT)"
        HL_COLOR=
        HL_COLOR2=
        ENV=HPR
    ;;
    *mapres)  WELCOME_MSG+="\nEnvironnement : HPR (MAP)"
        HL_COLOR=
        HL_COLOR2=
        ENV=HPR
    ;;
esac


## BI Specific


## Screen flag
#[ "${TERM}" = "screen" ] && SCREEN_FLAG=" screen:${STY#*.}" || unset SCREEN_FLAG
[ "${TERM}" = "screen" ] && [ -z "${TMUX}" ] && SCREEN_FLAG=$(echo -e " \e[1;36mscreen:${STY#*.}\e[0m") || unset SCREEN_FLAG
## Tmux flag
[[ "${TERM}" =~ "screen" ]] && [ -n "${TMUX}" ] && TMUX_FLAG=$(echo -e " \e[1;32mtmux:${TMUX/*tmux/tmux}\e[0m") || unset TMUX_FLAG
## Software Collection flag
[ -n "${X_SCLS}" ] && SCL_FLAG=$(echo -e " \e[1;35mscl:${X_SCLS}\e[0m") || unset SCL_FLAG
## Oracle Version
#[ "${PLATFORM}" == "ORACLE_APPLIANCE" ] && ORA_VERSION='$(ORAVER=${ORACLE_HOME##*/product/};ORAVER=${ORAVER%/*};echo "$ORAVER")' && GRID_VERSION='$(ORAVER=${ORACLE_HOME##*/u01/app/};ORAVER=${ORAVER%/*};echo "$ORAVER")'
[ "${PLATFORM}" == "ORACLE_APPLIANCE" ] && ORA_VERSION='$(ORAVER=${ORACLE_HOME##*/product/};ORAVER=${ORAVER%/*};echo "$ORAVER")' && GRID_VERSION='$(ORAVER=${ORACLE_HOME##*/u01/app/};echo "$ORAVER")'
[ "${PLATFORM}" != "ORACLE_APPLIANCE" ] && ORA_VERSION='$(ORAVER=${ORACLE_HOME##*/tech/oracle/dbhome/};echo "$ORAVER")' && GRID_VERSION='$(ORAVER=${ORACLE_HOME##*/tech/oracle/grid/};echo "$ORAVER")'
## FG : Decommenter pour avoir la date dans le prompt #DATE_PS1='[$(date "+%a %m/%d %H:%M:%S")]'

case ${USER} in
    root)
        #export PS1='\[\033[01;31m\]\u\[\033[00m\]@\[\033[01;34m\]\h\[\033[00m\]:\[\033[01;37m\]\w\[\033[00m\] \n\[\033[1;31m\]$ORACLE_SID\[\033[00m\][$(date "+%a %m/%d %H:%M:%S")]\# '
        #export PS1='\e[1;31m\u\e[0m@\e[1;31m\h\e[0m:\e[1;37m\w\e[0m \e[1;31m$ORACLE_SID $SCREEN_FLAG\e[0m\n[$(date "+%a %m/%d %H:%M:%S")]\e[1;31m\$\e[0m\[ '
        #export PS1='\[\e[1;31${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;31${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${ORACLE_SID} \[\e[1;33m\]$(eval echo ${ORA_VERSION})\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;31m\]\$\[\e[0m\] '
        export PS1='\[\e[1;${USR_COLOR}${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;${SRV_COLOR}${HL_COLOR2}m\]${HN_BASE}\[\e[0m\]\[\e[1;${SRV_NUM_COLOR}${HL_COLOR2}m\]${HN_NUM}\[\e[0m\]:\[\e[1;${PATH_COLOR}m\]\w\[\e[0m\] \[\e[1;${OSID_COLOR}m\]${ORACLE_SID} \[\e[1;${OVER_COLOR}m\]$(eval echo ${ORA_VERSION})\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;${SH_MARK_COLOR}m\]\$\[\e[0m\] '
        ;;
    oracle)
        #export PS1='\[\033[01;32m\]\u\[\033[00m\]@\[\033[01;34m\]\h\[\033[00m\]:\[\033[01;37m\]\w\[\033[00m\] \n\[\033[1;31m\]$ORACLE_SID\[\033[00m\][$(date "+%a %m/%d %H:%M:%S")]\$ '
        #export PS1='\[\e[1;32${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${ORACLE_SID} \[\e[1;33m\]$(eval echo ${ORA_VERSION})\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;32m\]\$\[\e[0m\] '
        #export PS1='\[\e[1;32${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]${HN_BASE}\[\e[0m\]\[\e[1;36${HL_COLOR2}m\]${HN_NUM}\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${ORACLE_SID} \[\e[1;33m\]$(eval echo ${ORA_VERSION})\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;32m\]\$\[\e[0m\] '
        export PS1='\[\e[1;${USR_COLOR}${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;${SRV_COLOR}${HL_COLOR2}m\]${HN_BASE}\[\e[0m\]\[\e[1;${SRV_NUM_COLOR}${HL_COLOR2}m\]${HN_NUM}\[\e[0m\]:\[\e[1;${PATH_COLOR}m\]\w\[\e[0m\] \[\e[1;${OSID_COLOR}m\]${ORACLE_SID} \[\e[1;${OVER_COLOR}m\]$(eval echo ${ORA_VERSION})\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;${SH_MARK_COLOR}m\]\$\[\e[0m\] '
        ;;
    grid)
        export PS1='\[\e[1;33${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${ORACLE_SID} \[\e[1;33m\]$(eval echo ${GRID_VERSION})\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;32m\]\$\[\e[0m\] '
        ;;
    postgres)
        export PS1='\[\e[1;33${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${PGS_INSTANCE} \[\e[1;33m\]${PGS_VERSION}\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;32m\]\$\[\e[0m\] '
        ;;
    admb*)
        export PS1='\[\e[1;36${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${ORACLE_SID} \[\e[1;33m\]$(eval echo ${ORA_VERSION})\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;32m\]\$\[\e[0m\] '
        ;;
    *)
        export PS1='\[\e[1;35${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] ${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;32m\]\$\[\e[0m\] '
        ;;
esac

## https://www.thegeekstuff.com/2008/09/bash-shell-take-control-of-ps1-ps2-ps3-ps4-and-prompt_command/
# PS1 – Default interaction prompt : Default "\s-\v\$"
# PS2 – Continuation interactive prompt : Default '>'
#PS2="continue->"
# PS3 – Prompt used by “select” inside shell script
#PS3="Select a day (1-4): "
# PS4 – Used by “set -x” to prefix tracing output : Default '+'
export PS4='$0.$LINENO+ '

## COLOR
function display_all_colors_16
{
for clbg in {40..47} {100..107} 49 ; do
    #Foreground
    for clfg in {30..37} {90..97} 39 ; do
        #Formatting
        for attr in 0 1 2 4 5 7 ; do
            #Print the result
            echo -en "\e[${attr};${clbg};${clfg}m ^[${attr};${clbg};${clfg}m \e[0m"
        done
        echo #Newline
    done
done
}


## ORACLE
if [ "${LOGNAME}" == "oracle" -o "${LOGNAME}" == "grid" ]
then
    ## FGR : To speedup GI_HOME lookup : use of oratab first then search the path from the process ocssd.bin
    GI_HOME=$(awk -F: '/+ASM/ {print $2}' /etc/oratab)
    [ -d "${GI_HOME}/bin" ] || GI_HOME=$(dirname $(ps -eo args | grep [o]cssd.bin) | awk '{print substr( $1, 1, length($1)-4)}')
    #GI_HOME=$(dirname $(ps -eo args | grep [o]cssd.bin) | awk '{print substr( $1, 1, length($1)-4)}')
    #GI_BIN=$(dirname $(ps -eo args | grep [o]cssd.bin | awk '{print $1}' ))
    GI_BIN=${GI_HOME}/bin
    #export PATH=${PATH}:${GI_BIN}
    pathmunge ${GI_BIN} after
    #.oracle_profile
    #export PS1='\[\033[01;32m\]\u\[\033[00m\]@\[\033[01;34m\]\h\[\033[00m\]:\[\033[01;37m\]\w\[\033[00m\] \n\[\033[1;31m\]$ORACLE_SID\[\033[00m\][$(date "+%a %m/%d %H:%M:%S")]\$ '
    #export NLS_LANG=AMERICAN_AMERICA.WE8MSWIN1252
    export NLS_LANG=AMERICAN_AMERICA.US7ASCII
    export NLS_DATE_FORMAT='DD-MON-YY HH24:MI:SS';
    ## FG : Windows=SQLPATH + @ login OR Unix=ORACLE_PATH (Doc ID 2241021.1)
    #export SQLPATH=/oracle/exploit/sql
    #export ORACLE_PATH=/oracle/exploit/sql
    export ORACLE_PATH=${WORKDIR}/sql
    # FG : alias cdoh='cd \${ORACLE_HOME}' # -bash: cd: ${ORACLE_HOME}: No such file or directory
    alias cdoh='cd ${ORACLE_HOME}'
    alias lslsn='ps -ef | grep l[s]n'
    [ -f "${ORACLE_HOME}/suptools/oratop/oratop" ] && ORATOP_PATH=${ORACLE_HOME}/suptools/oratop || ORATOP_PATH=${BI_PATH}/bin
    alias oratop="${ORATOP_PATH}/oratop -f -r / as sysdba"
    alias alrt="echo /u01/app/oracle/diag/rdbms/$(echo ${ORACLE_SID:0:8}D* | tr '[:upper:]' '[:lower:]')/${ORACLE_SID}/trace/alert_${ORACLE_SID}.log"
    alias alrttail="tail -100f /u01/app/oracle/diag/rdbms/$(echo ${ORACLE_SID:0:8}D* | tr '[:upper:]' '[:lower:]')/${ORACLE_SID}/trace/alert_${ORACLE_SID}.log"
    alias alrtvi="view /u01/app/oracle/diag/rdbms/$(echo ${ORACLE_SID:0:8}D* | tr '[:upper:]' '[:lower:]')/${ORACLE_SID}/trace/alert_${ORACLE_SID}.log"
    IS_RLWRAP_IN_PATH=$(which --skip-alias rlwrap >/dev/null 2>&1; echo $?)
    IS_RLWRAP_IN_WORKDIR=$(test -x ${BINDIR}/rlwrap; echo $?)
    [ ${IS_RLWRAP_IN_PATH} == 0 ] && RLWRAP_BIN=rlwrap || echo "rlwrap binary not present or not executable : ${BINDIR}/rlwrap"
    [ ${IS_RLWRAP_IN_WORKDIR} == 0 ] && RLWRAP_BIN=${BINDIR}/rlwrap && [ -d ${LIBDIR}/.rlwrap ] && RLWRAP_DIR=${LIBDIR}/.rlwrap
    #[ -z "${RLWRAP_BIN}" ] && RLWRAP_BIN=$(locate -be '\rlwrap')
    #[ -z "${RLWRAP_DIR}" ] && RLWRAP_DIR=$(locate -be '\.rlwrap')
    IS_RLWRAP_PREREQ_OK=$(${RLWRAP_BIN} -v >/dev/null 2>&1; echo $?)
    if [ -n "${RLWRAP_BIN}" -a -n "${RLWRAP_DIR}" -a ${IS_RLWRAP_PREREQ_OK} -eq 0 ]
    then
      alias rlwrap="${RLWRAP_BIN} --histsize 5000"
      alias rlsqlplus='rlwrap -f ${RLWRAP_DIR}/sqlplus_completions sqlplus'
      alias rlsqlcl='SQLPATH=${ORACLE_PATH} rlwrap -f ${RLWRAP_DIR}/sqlplus_completions \sql'
      alias rlrman='rlwrap -f ${RLWRAP_DIR}/rman_completions rman'
      alias rldgmgrl='rlwrap -f ${RLWRAP_DIR}/dgmgrl_completions dgmgrl'
      alias rlasmcmd='rlwrap -f ${RLWRAP_DIR}/asmcmd_completions asmcmd -p'
      alias rlasmcmdora='ORACLE_HOME=${GI_HOME} rlwrap -f ${RLWRAP_DIR}/asmcmd_completions asmcmd -p --privilege sysdba'
      alias rladrci='rlwrap -f ${RLWRAP_DIR}/adrci_completions adrci'
      alias rllsn='rlwrap -f ${RLWRAP_DIR}/lsnrctl_completions lsnrctl'
      alias rlsql='rlwrap -f ${RLWRAP_DIR}/sqlplus_completions sqlplus / as sysdba @ login_noauto ${COLUMNS}'
      alias rlsqlc='SQLPATH=${ORACLE_PATH} rlwrap -f ${RLWRAP_DIR}/sqlplus_completions \sql / as sysdba @ login_noauto_sqlcl ${COLUMNS}'
      alias rlsqlasm='rlwrap -f ${RLWRAP_DIR}/sqlplus_completions sqlplus / as sysasm @ login_noauto ${COLUMNS}'
      alias sql='rlsql'
      #[ "${LOGNAME}" == "grid" ] && [[ "${ORACLE_SID^^}" ~= "ASM" ]] && alias sql='rlsqlasm'
      [ "${LOGNAME}" == "grid" ] && alias sql='rlsqlasm'
      alias sqlc='rlsqlc'
      alias sqlasm='rlsqlasm'
      alias rmn='rlrman target /'
      alias dgb='rldgmgrl /'
      alias asm='rlasmcmd'
      alias asmora='rlasmcmdora'
      [ "${LOGNAME}" == "oracle" ] && alias asm='rlasmcmdora'
      alias adr='rladrci'
      alias lsn='rllsn'
    else
      alias sql='sqlplus / as sysdba @ login_noauto ${COLUMNS}'
    fi
fi

alias setoh='. ${LIBDIR}/setoh.sh'
alias env11='. ${LIBDIR}/env11.sh'
alias env12='. ${LIBDIR}/env12.sh'
[ -n "${ORACLE_HOME}" ] && alias opatch='${ORACLE_HOME}/OPatch/opatch'


function loopdb {
#  set +x
  local DB_FILTER ORAVERFILTER VERBOSE=0 DEBUG SQL_COLLECTION HEADER DEFINED_HEADER OPEN_ONLY TIMING
  SQL_COLLECTION=${1} ; shift 1

  function Usage {
  echo "Usage : ${FUNCTNAME} [query template] [options]
  Query template :
  IS_DTG, SGA_DBF_USAGE, DBPSU
  
  Options: 
  -d    <INSTANCE_NAME>  : Filter INSTANCE_NAME or pattern (eg -d ALF)
  --ver <ORACLE_VERSION> : 11.2|12|19.4
  --open                 : Display OPEN database only
  --timing               : Execution timing
  -v                     : Verbose enable
  -vv                    : More verbosity
  -dbg                   : Debug enable 
  "
  }

  #echo args=$*
  [ -z "${SQL_COLLECTION}" ] && Usage && return 1

#  for argv in $@ ; do  ## FGR : Avec FOR le shift n'est pas pris en compte
  while [ "$#" -gt 0 ]; do
    #echo argv=$1
    case "$1" in
      -h*)  Usage ; return 1 ;;
      -d)  DB_FILTER=".*$2.*" ; if [ "$2" = "" ]; then Usage ; return 1 ; else shift 2 ; fi ;;
      --ver|-o)  ORAVERFILTER=$2 ; if [ "$2" = "" ]; then Usage ; return 1 ; else shift 2 ; fi ;;
      --open)  OPEN_ONLY=1 ; shift 1 ;;
      --timing) TIMING=1 ; shift 1 ;;
      -v)  VERBOSE=1 ; shift 1 ;;
      -vv)  VERBOSE=2 ; shift 1 ;;
      -dbg|--debug) DEBUG=YES ;  shift 1 ;;
      -*)  echo "!!! Argument $1 invalide !!!"; Usage ; return 1 ;;
      *)  echo "!!! Argument $1 invalide !!!"; Usage ; return 1 ;;
      #-exemple_1)   export EX=YES ; shift 1 ;;
      #-exemple_2*)  export EX=$2 ;  if [ "$2" = "" ]; then Usage ; else shift 2 ; fi ;;
      #-exemple_3)   EX=$2 ; [ -z "$2" ] && Usage || shift 2 ;;
      #--name=*) name="${1#*=}"; shift 1;;
    esac
  done

## Replace occurrences of $ with \$ to prevent variable substitution:
# filename="${filename//$/\\$}"
## Print dollar : HEXA or OCTAL
# echo -e '\x24' or # echo -e '\044'

  COLOR_OK='\033[30;42m'; COLOR_KO="\033[1;37;41m"; COLOR_WARN="\033[30;43m"; COLOR_CMD="\033[1;37;44m"; COLOR_STD="\033[0;0m"; COLOR_TITLE="\033[30;47m"; COLOR_RESULT="\033[30;46m"
  #alias echo='echo -e'

  SQL_PARAM="WHENEVER SQLERROR EXIT SQL.SQLCODE\nset head off feed off verify off echo off pages 0 trimout on trimspool on termout off wrap off set feed only\n"
  SQL_PARAM="WHENEVER SQLERROR EXIT SQL.SQLCODE\nset head off lines $[${COLUMNS}-${COLUMNS}/3] pages 0 trimout on\n"
  [ -n "${TIMING}" ] && SQL_PARAM+="set timing on\n"

  #column value new_val blksize
  #select value from v$parameter where name = 'db_block_size'
  #ENVSQL="${ENVSQL}"
    #ENVSQL_HEADER="CPU_COUNT"
  DB_VERSION="SELECT VERSION FROM PRODUCT_COMPONENT_VERSION WHERE PRODUCT LIKE '%Oracle Database%';"
  DBID='select dbid from v$database;'
  DBPSU11="SELECT TO_CHAR(action_time, 'YYYY-MM-DD HH24:MI:SS') AS action_time,action,version,id,comments FROM sys.dba_registry_history where comments like 'BP%' ORDER by action_time asc;"
  DBPSU12="SELECT TO_CHAR(action_time, 'YYYY-MM-DD HH24:MI:SS') AS action_time,action,status,description,version FROM sys.dba_registry_sqlpatch where description like '%PSU%' ORDER by action_time;"
  DIRECTORIES="col OWNER for a10\ncol DIRECTORY_NAME for a25\ncol DIRECTORY_PATH for a70\nselect OWNER,DIRECTORY_NAME,DIRECTORY_PATH from dba_directories where DIRECTORY_NAME like '%PUMP%';"
  HEATMAP="col owner for a10\ncol SEGMENT_NAME for a20\nSELECT owner, segment_name, segment_type, SUM(bytes/1048576) seg_size FROM dba_extents WHERE tablespace_name='SYSAUX' AND SEGMENT_NAME = 'HEATMAP' GROUP BY owner,segment_name , segment_type;"
  STARTUP_TIME="select STARTUP_TIME from v\$instance;"
  DB_ROLE="select DATABASE_ROLE from v\$database;"
  DB_OPEN_MODE="select OPEN_MODE from v\$database;"
  INSTANCE_STATUS="select STATUS from v\$instance;"
  IS_DTG="show parameter dg_broker_start"
  IS_RAC="select VALUE from v\$parameter where upper(NAME) = 'CLUSTER_DATABASE_INSTANCES';"
  IS_RAC="select count(*) NBR_INSTANCES from gv\$instance;"
  IS_RAC="select count(*) FROM v\$active_instances;"
  RAC_TYPE="select DECODE(INSTR(instance_name,'_'),0,'RAC','RACONE') RAC_TYPE from v\$instance;"
    RAC_TYPE_HEADER="RAC_TYPE CLUSTER_DATABASE_INSTANCES COUNT_GV\$INSTANCE"
  NB_INST="select count(*) from gv\$instance;"
  NB_THREAD="select count(distinct(THREAD#)) NB_THREAD from v\$log;"
  DIFF_INST_THREAD="select (select DECODE(count(*),1,2,count(*)) FROM v\$active_instances) - (select nvl(count(distinct(THREAD#)),0) from v\$standby_log) DIFF_INST_THREAD from dual;"
  CDI="select VALUE from v\$parameter where upper(NAME) = 'CLUSTER_DATABASE_INSTANCES';"
  FORCE_LOGGING="select FORCE_LOGGING from v\$database;"
  FIX_CONTROL_CHECK="show parameter _fix_control"
  LAST_LOGIN="select to_char(max(LAST_LOGIN),'dd/mm/yyyy') from dba_users where username not in ('ANONYMOUS','APEX_030200','APEX_PUBLIC_USER','APPQOSSYS','BI','CTXSYS','DBSNMP','DIP','EXFSYS','FLOWS_FILES','HR','IX','MDDATA','DMSYS','MDSYS','MGMT_VIEW','OE','OLAPSYS','ORACLE_OCM','ORDDATA','ORDPLUGINS','ORDSYS','OUTLN','OWBSYS','OWBSYS_AUDIT','PM','TSMSYS','SCOTT','SH','SI_INFORMTN_SCHEMA','SPATIAL_CSW_ADMIN_USR','SPATIAL_WFS_ADMIN_USR','SYS','SYSMAN','SYSTEM','WMSYS','XDB','XS$NULL','SYSBACKUP','SYSKM','SYSDG','AUDSYS','GSMCATUSER','GSMUSER','GSMADMIN_INTERNAL','PERFSTAT','OJVMSYS');"
  DB_SIZE="select sum(bytes)/1048576 as MB, round(sum(bytes)/1048576/1024,1) as GB from dba_data_files;"
    DB_SIZE_HEADER="MB   GB"
  DBF_SIZE="select round(sum(df.bytes/1073741824),0) as DBF_GB from v\$datafile df, v\$tablespace ts where df.ts#=ts.ts# and ts.NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS');"
  SGA_DBF_USAGE="COLUMN SGA_USAGE FORMAT A40
  SELECT
  'SGA_TARGET         GB : '||SGA_TARGET_GB
  ||chr(10)||'All Pool Used      GB : '||POOL_USED_GB
  ||chr(10)||'Shared Pool Alloc  GB : '||SHARED_POOL_GB
  ||chr(10)||'Shared Pool Used   GB : '||SHARED_POOL_USED_GB
  ||chr(10)||'Shared Pool Free   GB : '||SHARED_POOL_FREE_GB
  ||chr(10)||'Buffer Cache Alloc GB : '||BUFFER_CACHE_GB
  ||chr(10)||'Buffer Cache Used  GB : '||BUFFER_CACHE_USED_GB
  ||chr(10)||'Other Pool Alloc   GB : '||OTHER_POOL_GB
  ||chr(10)||'Other Pool Used    GB : '||OTHER_POOL_USED_GB
  ||chr(10)||'Other Pool Free    GB : '||OTHER_POOL_FREE_GB
  ||chr(10)||'SGA_USED           GB : '||round((SHARED_POOL_USED_GB+BUFFER_CACHE_USED_GB+OTHER_POOL_USED_GB),1)
  ||chr(10)||'SGA_FREE           GB : '||round((SGA_TARGET_GB-BUFFER_CACHE_USED_GB-SHARED_POOL_USED_GB-OTHER_POOL_USED_GB),1)
  ||chr(10)||'SGA_FREE_PERCENT    % : '||round(((SGA_TARGET_GB-BUFFER_CACHE_USED_GB-SHARED_POOL_USED_GB-OTHER_POOL_USED_GB)*100/SGA_TARGET_GB),1)
  ||chr(10)||'DBF_SIZE           GB : '||DBF_SIZE_GB
  ||chr(10)||'DBF_SIZE_FREE      GB : '||DBF_SIZE_FREE_GB
  ||chr(10)||'DBF_SIZE_USED      GB : '||(DBF_SIZE_GB - DBF_SIZE_FREE_GB)
    FROM
    (SELECT round(sum(number_of_blocks*db_block_size/1073741824),1) BUFFER_CACHE_USED_GB
    ,(select round(bytes/1073741824,1) from v\$sgastat where name = 'buffer_cache') BUFFER_CACHE_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%') POOL_USED_GB
    ,(select round(bytes/1073741824,1) GB from v\$sgainfo where name = 'Shared Pool Size') SHARED_POOL_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool = 'shared pool' and name != 'free memory') SHARED_POOL_USED_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool = 'shared pool' and name = 'free memory') SHARED_POOL_FREE_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgainfo where lower(name) like '%pool%' and name != 'Shared Pool Size') OTHER_POOL_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%' and pool != 'shared pool' and name != 'free memory') OTHER_POOL_USED_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%' and pool != 'shared pool' and name = 'free memory') OTHER_POOL_FREE_GB
--#    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%' and pool in ('large pool','streams pool','numa pool') and name != 'free memory') OTHER_POOL_USED_GB
--#    ,(select round(sum(df.bytes/1073741824),0) from v\$datafile df, v\$tablespace ts where df.ts#=ts.ts# and ts.NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_GB
    ,(select round(sum(bytes/1073741824),0) from dba_data_files where TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_GB
--#    ,(select round(sum(user_bytes/1073741824),0) from dba_data_files where TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_GB
    ,(select round(sum(bytes/1073741824),0) from dba_free_space where TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_FREE_GB
    ,SGA_TARGET_GB
      FROM
      (
      SELECT o.object_name, COUNT(*) number_of_blocks
      ,(SELECT value FROM V\$PARAMETER WHERE name = 'db_block_size') db_block_size
      ,(select round(value/1073741824,1) GB from v\$parameter where name='sga_target') SGA_TARGET_GB
       FROM DBA_OBJECTS o, V\$BH bh
       WHERE o.data_object_id = bh.OBJD
       AND o.owner != 'SYS'
       GROUP BY o.object_Name
       --ORDER BY COUNT(*)
      )
    GROUP BY SGA_TARGET_GB
    )
;"


  [ ! -z "${DEBUG}" ] && (PROMPT_COMMAND_PREV=$PROMPT_COMMAND; unset PROMPT_COMMAND) && set -x

  pad_space="                    "
  pad_size=10

  HEADER=${SQL_COLLECTION}
  DEFINED_HEADER=$(echo ${SQL_COLLECTION}_HEADER)
  [ ! -z "${!DEFINED_HEADER}" ] && HEADER+=" : ${!DEFINED_HEADER}"
  (( ${VERBOSE} >= 2 )) && HEADER+=" : ${!SQL_COLLECTION}"
#echo ${!SQL_COLLECTION}
#echo ${!SQL_COLLECTION//$/\\$}
#echo ${!SQL_COLLECTION//\"/}
  #QUERYRAW=$(set -f; echo "${!SQL_COLLECTION//\"/}" | sed 's:\\$:\\\$:g'; set +f)    QUERY2EXEC="${SQL_PARAM}${QUERYRAW}"
  #QUERYRAW=${!SQL_COLLECTION//$/\\$}
  #QUERYRAW=${!SQL_COLLECTION//\"/}    QUERY2EXEC="${SQL_PARAM}${QUERYRAW}"
  QUERYRAW="${!SQL_COLLECTION}"    QUERY2EXEC="${SQL_PARAM}${QUERYRAW}"

  for SID in $(ps -eo args | grep pm[o]n_"${DB_FILTER}" | cut -d'_' -f3- | grep -v "^+\|^-\|^$\|^DBA" | sort); do . oraenv <<<${SID}>/dev/null
    ORA_VERSION=$(ORAVER=${ORACLE_HOME##*/product/};ORAVER=${ORAVER%/*};echo "$ORAVER")
    [ ! -z "${ORAVERFILTER}" ] && [[ ! ${ORA_VERSION} =~ ${ORAVERFILTER} ]] && continue
    [ "${OPEN_ONLY}" = 1 ] && [ $(echo -e "${INSTANCE_STATUS}" | sqlplus -S / as sysdba | grep -c 'OPEN') -eq 0 ] && continue 
    (( ${VERBOSE} >= 1 )) && echo -e "\n${COLOR_TITLE}${ORACLE_SID} : ${ORA_VERSION}${COLOR_STD}" # : ${COLOR_CMD}${QUERYRAW//\\n/ & }${COLOR_STD}"
    QUERY_OUTPUT=$(echo -e "${QUERY2EXEC}" | sqlplus -S / as sysdba)
    [[ "${QUERY_OUTPUT}" =~ ORA-|TNS-|RMAN-|-bash|KO ]] && OUTCOLOR=${COLOR_KO} || OUTCOLOR=${COLOR_STD}
    [[ "${QUERY_OUTPUT}" =~ "OK" ]] && OUTCOLOR=${COLOR_OK}
    #(( ${VERBOSE} == 0 )) && echo "${ORACLE_SID}${pad_space:0:$((${pad_size}-${#ORACLE_SID}))} (${ORA_VERSION}) : ${HEADER} : ${QUERY_OUTPUT}"
    (( ${VERBOSE} == 0 )) && (set -f; echo "${ORACLE_SID}${pad_space:0:$((${pad_size}-${#ORACLE_SID}))} (${ORA_VERSION}) : ${HEADER} : $(echo ${QUERY_OUTPUT})"; set +f);
    (( ${VERBOSE} >= 1 )) && echo -e "${COLOR_RESULT}${HEADER}${COLOR_STD}"
    (( ${VERBOSE} == 1 )) && (set -f; echo -e "${OUTCOLOR:-${COLOR_RESULT}}$(echo ${QUERY_OUTPUT})${COLOR_STD}"; set +f);
    (( ${VERBOSE} >= 2 )) && echo -e "${OUTCOLOR}${QUERY_OUTPUT}${COLOR_STD}"

  done

  [ ! -z "${DEBUG}" ] && PROMPT_COMMAND=$PROMPT_COMMAND_PREV && set +x
}




function loopdb_tmp {
  unset DB_FILTER VERBOSE DEBUG LOOP_TIMER
  SQL_COLLECTION=${1} ; shift 1

  while [ "$#" -gt 0 ]; do
    case "$1" in
      -h*)  Usage ; return 1 ;;
      -d)  DB_FILTER=".*$2.*" ; if [ "$2" = "" ]; then Usage ; return 1 ; else shift 2 ; fi ;;
      -t)  LOOP_TIMER="$2" ; if [ "$2" = "" ]; then Usage ; return 1 ; else shift 2 ; fi ;;
      -v*)  VERBOSE=YES ; shift 1 ;;
      --debug|-dbg) DEBUG=YES ;  shift 1 ;;
       -*)  echo "!!! Argument $1 invalide !!!"; Usage ; return 1 ;;
        *)  echo "!!! Argument $1 invalide !!!"; Usage ; return 1 ;;
    esac
  done

  COLOR_OK='\033[30;42m'; COLOR_KO="\033[1;37;41m"; COLOR_WARN="\033[30;43m"; COLOR_CMD="\033[1;37;44m"; COLOR_STD="\033[0;0m"; COLOR_TITLE="\033[30;47m"; COLOR_RESULT="\033[30;46m"
  unset COLOR_OK COLOR_KO COLOR_WARN COLOR_CMD COLOR_STD COLOR_TITLE COLOR_RESULT
  DATE=$(date "+%Y-%m-%d_%H:%M:%S")
  SQL_PARAM="WHENEVER SQLERROR EXIT SQL.SQLCODE\nset head off lines $[${COLUMNS}-${COLUMNS}/3] pages 0 trimout on\n"

  export NLS_DATE_FORMAT='YYYY-MM-DD_HH24:MI:SS'
  export NLS_NUMERIC_CHARACTERS=', '
  SGA_DBF_USAGE_HEADER='DATE;HOUR;INSTANCE_NAME;SGA_TARGET_GB;POOL_USED_GB;SHARED_POOL_GB;SHARED_POOL_USED_GB;SHARED_POOL_FREE_GB;BUFFER_CACHE_GB;BUFFER_CACHE_USED_GB;OTHER_POOL_GB;OTHER_POOL_USED_GB;OTHER_POOL_FREE_GB;SGA_FREE;SGA_FREE_PERCENT;SGA_USED'
  SGA_DBF_USAGE="COLUMN SGA_USAGE FORMAT A40
SELECT TO_CHAR(SYSDATE,'YYYY-MM-DD')||';'||TO_CHAR(SYSDATE,'HH24:MI')||';'||(select sys_context('userenv','instance_name') from dual)
||';'||SGA_TARGET_GB
||';'||POOL_USED_GB
||';'||SHARED_POOL_GB
||';'||SHARED_POOL_USED_GB
||';'||SHARED_POOL_FREE_GB
||';'||BUFFER_CACHE_GB
||';'||BUFFER_CACHE_USED_GB
||';'||OTHER_POOL_GB
||';'||OTHER_POOL_USED_GB
||';'||OTHER_POOL_FREE_GB
||';'||(SGA_TARGET_GB-BUFFER_CACHE_USED_GB-SHARED_POOL_USED_GB-OTHER_POOL_USED_GB)
||';'||round(((SGA_TARGET_GB-BUFFER_CACHE_USED_GB-SHARED_POOL_USED_GB-OTHER_POOL_USED_GB)*100/SGA_TARGET_GB),1)
||';'||(SHARED_POOL_USED_GB+BUFFER_CACHE_USED_GB+OTHER_POOL_USED_GB)
    FROM
    (SELECT round(sum(number_of_blocks*db_block_size/1073741824),1) BUFFER_CACHE_USED_GB
    ,(select round(bytes/1073741824,1) from v\$sgastat where name = 'buffer_cache') BUFFER_CACHE_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%') POOL_USED_GB
    ,(select round(bytes/1073741824,1) GB from v\$sgainfo where name = 'Shared Pool Size') SHARED_POOL_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool = 'shared pool' and name != 'free memory') SHARED_POOL_USED_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool = 'shared pool' and name = 'free memory') SHARED_POOL_FREE_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgainfo where lower(name) like '%pool%' and name != 'Shared Pool Size') OTHER_POOL_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%' and pool != 'shared pool' and name != 'free memory') OTHER_POOL_USED_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%' and pool != 'shared pool' and name = 'free memory') OTHER_POOL_FREE_GB
--    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%' and pool in ('large pool','streams pool','numa pool')) OTHER_POOL_USED_GB
--    ,(select round(sum(df.bytes/1073741824),0) from v\$datafile df, v\$tablespace ts where df.ts#=ts.ts# and ts.NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_GB
--    ,(select round(sum(bytes/1073741824),0) from dba_data_files where TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_GB
--    ,(select round(sum(user_bytes/1073741824),0) from dba_data_files where TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_GB
--    ,(select round(sum(bytes/1073741824),0) from dba_free_space where TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_FREE_GB
    ,SGA_TARGET_GB
      FROM
      (
      SELECT o.object_name, COUNT(*) number_of_blocks
      ,(SELECT value FROM V\$PARAMETER WHERE name = 'db_block_size') db_block_size
      ,(select round(value/1073741824,1) GB from v\$parameter where name='sga_target') SGA_TARGET_GB
       FROM DBA_OBJECTS o, V\$BH bh
       WHERE o.data_object_id = bh.OBJD
       AND o.owner != 'SYS'
       GROUP BY o.object_Name
       --ORDER BY COUNT(*)
      )
    GROUP BY SGA_TARGET_GB
    )
;"


  [ ! -z "${DEBUG}" ] && (PROMPT_COMMAND_PREV=$PROMPT_COMMAND; unset PROMPT_COMMAND) && set -x

  HEADER=${SQL_COLLECTION}
  [[ "${VERBOSE}" == "YES" ]] && HEADER="${SQL_COLLECTION} : ${!SQL_COLLECTION}"
  QUERYRAW="${!SQL_COLLECTION}"    QUERY2EXEC="${SQL_PARAM}${QUERYRAW}"

function ExecPrint_Result {
  for SID in $(ps -eo args | grep pm[o]n_"${DB_FILTER}" | cut -d'_' -f3- | grep -v "^+\|^-\|^$\|^DBA" | sort); do . oraenv <<<${SID}>/dev/null
    ORA_VERSION=$(ORAVER=${ORACLE_HOME##*/product/};ORAVER=${ORAVER%/*};echo "$ORAVER")
    [ ! -z "${ORAVERFILTER}" ] && [[ ! ${ORA_VERSION} =~ ${ORAVERFILTER} ]] && continue
#    echo -e "\nDATE : ${DATE}\n${COLOR_TITLE}${ORACLE_SID} : ${ORA_VERSION}${COLOR_STD}" # : ${COLOR_CMD}${QUERYRAW//\\n/ & }${COLOR_STD}"
    QUERY_OUTPUT=$(echo -e "${QUERY2EXEC}" | sqlplus -S / as sysdba)
    [[ "${QUERY_OUTPUT}" =~ ORA-|TNS-|RMAN-|-bash|KO ]] && OUTCOLOR=${COLOR_KO} || OUTCOLOR=${COLOR_STD}
    [[ "${QUERY_OUTPUT}" =~ "OK" ]] && OUTCOLOR=${COLOR_OK}
#    [[ -z "${VERBOSE}" ]] && echo -e "${COLOR_RESULT}${HEADER}${COLOR_STD}"
#    [[ "${VERBOSE}" == "YES" ]] && echo -e "${COLOR_RESULT}${HEADER}${COLOR_STD}"
    [[ -z "${VERBOSE}" ]] && echo -e "${OUTCOLOR}${QUERY_OUTPUT}${COLOR_STD}"
    [[ "${VERBOSE}" == "YES" ]] && (set -f; echo -e "${OUTCOLOR:-${COLOR_RESULT}}$(echo ${QUERY_OUTPUT})${COLOR_STD}"; set +f);
  done
}

if [ ! -z "${LOOP_TIMER}" ]; then
    #echo "Press [CTRL+C] to stop the loop ..."
    echo "${SGA_DBF_USAGE_HEADER}"
    while : 
    do
        ExecPrint_Result
        sleep ${LOOP_TIMER}
    done
else
    ExecPrint_Result
fi


  [ ! -z "${DEBUG}" ] && PROMPT_COMMAND=$PROMPT_COMMAND_PREV && set +x
}


function oralisthome {
local FILTER
[ ! -z "${1}" ] && FILTER="| grep ${1}"
#printf "%6s %-20s %-80s\n" "PID" "NAME" "ORACLE_HOME"
printf "%6s %-10s %-80s\n" "PID" "NAME" "ORACLE_HOME"
eval "pgrep -af _pmon_ ${FILTER} | sort -k2,2" |
  while read pid pname ; do
    printf "%6s %-10s %-80s\n" $pid ${pname#???_pmon_} $(sudo ls -l /proc/$pid/exe | awk -F'>' '{ print $2 }' | sed 's/bin\/oracle$//' | sort | uniq)
  done
}


function oragetversionpid {
  local db
  [ ! -z "${1}" ] && db=${1} || { echo "Arg is missing : DBNAME"; return 1; }
  [ ${#db} -lt 8 ] && { echo "Arg must contain 8 char : \"${db}\""; return 1; }
  sudo ls -l /proc/$(eval "pgrep -f ora_pmon_${db^^}")/exe | sed 's:.*/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*:\1.\2.\3.\4.\5:'
}


function oralistcnx {
ps -eo "args" | grep L[O]CAL=NO | sort | uniq -c
}


function lsnGetservice_OLD {
LSN_NAME_LIST=$(ps -eo args | grep -w tnsl[s]nr | sed 's/.*lsnr \(.*\) -no.*/\1/')
for LSN_NAME in ${LSN_NAME_LIST}; do
    cmd="lsnrctl status ${LSN_NAME} | grep -m 3 ${1}.*_APPLI"
    host_port=$(lsnrctl status ${LSN_NAME} | grep PORT | sed 's/.*\(.*HOST=.*\)\(PORT=.*\)/Host=\1 Port=\2/')
    echo "${LSN_NAME} :"
    echo ${cmd}
    eval ${cmd}
    #eval ${cmd} | highlight cyan 'lsnrctl status'
done
}


function lsnGetservice {
FORMER_FUNCNAME=${FUNCNAME}
#echo "Usage : Connected as 'grid' ${FUNCNAME} <TRI>.*X1"
## TODO : sudo -u grid || ssh grid@localhost + oraenv +ASM
    function Usage {
    echo "Usage : ${FORMER_FUNCNAME} <DB_STRING>.*X1"
    }

[ -z "${1}" ] && Usage && read -p "List all listener services ? (return to continue) " ANSWER
[ ! -z "${ANSWER}" ] && exit

    MainFunc () {
    #echo "Usage : ${FORMER_FUNCNAME} <TRI>.*X1"
    LSN_SERVICE=${1:-.}
#    LSN_NAME_LIST=$(ps -eo args | grep -w tnsl[s]nr | sed 's/.*lsnr \(.*\) -no.*/\1/')
    LSN_NAME_LIST=$(ps -eo args | grep -w tnsl[s]nr | awk '{print $2}')
    for LSN_NAME in ${LSN_NAME_LIST}; do
        #cmd="lsnrctl status ${LSN_NAME} | grep -m 3 ${LSN_SERVICE}.*_APPLI"
        cmd="lsnrctl status ${LSN_NAME} | grep ${LSN_SERVICE}"
        #host_port=$(lsnrctl status ${LSN_NAME} | grep PORT | sed 's/.*\(.*HOST=.*\))(\(PORT=.*\))))/\1 \2/')
        host_port=$(lsnrctl status ${LSN_NAME} | grep PORT | sed 's:.*(\(.*HOST=.*\))(\(PORT=[0-9]*\)).*:\1 \2:')
        echo -e "\e[7;40;37m${LSN_NAME}\e[0m : "${host_port}
        #echo ${cmd}
        #eval ${cmd}
        RESULT="$(eval ${cmd})"
        echo -e "\e[1;32m${RESULT}\e[0m"
        #eval ${cmd} | highlight cyan 'lsnrctl status'
    done
    }

    if [ "${LOGNAME}" == "grid" ]; then
        if [[ ! "${ORACLE_SID}" =~ "ASM" ]]; then HOST=$(hostname -s); export ORACLE_SID="+ASM${HOST:0,-1}"; export ORAENV_ASK=NO; . oraenv>/dev/null; fi
        MainFunc $1
    else
        #export -f MainFunc
        #su grid -c "bash -c HOST=$(hostname -s); export ORACLE_SID=+ASM${HOST:0,-1}; export ORAENV_ASK=NO; export PATH=${PATH}:/usr/local/bin/; . oraenv>/dev/null; MainFunc $1"
        #su grid -c "bash -c echo "HOST=$(hostname -s); export ORACLE_SID=+ASM${HOST:0,-1}; export ORAENV_ASK=NO; export PATH=${PATH}:/usr/local/bin/; . oraenv; echo ${ORACLE_SID}:${ORACLE_HOME}; MainFunc $1""
        sudo -i -u grid bash -c ". ${BI_PATH}/lib/fgenv &>/dev/null; export PATH=\$PATH:/usr/local/bin/; HOST=\$(hostname -s); export ORACLE_SID=+ASM\${HOST:0,-1}; export ORAENV_ASK=NO; . oraenv>/dev/null; lsnGetservice $1"
        #sudo -u grid bash -c "MainFunc $1"
        #su grid -c "bash -c MainFunc $1"
    fi
}


function asmdu {
# https://blog.pythian.com/amcmd-better-du/
    D=$1
    if [[ -z "$D" ]]; then
        echo "Please provide a directory !"
        return 1
        #exit 1
    fi

    (for DIR in $(asmcmd ls ${D}); do
        echo ${DIR} $(asmcmd du ${D}/${DIR} | tail -1)
    done) | awk -v D="$D" '
    BEGIN { printf("\n\t%30s\n\n", D " subdirectories size");
    printf("%25s%16s%16s\n", "Subdir", "Used MB", "Mirror MB");
    printf("%25s%16s%16s\n", "------", "-------", "---------");
    }
    { printf("%25s%16s%16s\n", $1, $2, $3);
    use += $2;
    mir += $3;
    }
    END { printf("\n\n%25s%16s%16s\n", "------", "-------", "---------");
    printf("%25s%16s%16s\n\n", "Total", use, mir);
    }'
}


function ASMvsDB_DIFF {
    [[ "${LOGNAME}" != "grid" ]] && echo "You must be connected as grid" && return 1
    DG_DATA=DATAC1
    DG_RECO=RECOC1

    echo "DG_DATA = ${DG_DATA}"
    echo "DG_RECO = ${DG_RECO}"
    echo "CRS_DBUNAME = srvctl config"

    ASMDIR_DATA=$(asmcmd ls ${DG_DATA} | sort | grep -E 'D1|D2' | sed s:/::)
    ASMDIR_RECO=$(asmcmd ls ${DG_RECO} | sort | grep -E 'D1|D2' | sed s:/::)
    CRS_DBUNAME=$(srvctl config | grep -E 'D1|D2')

    echo -e "\nDifference between :\nASMDIR_DATA vs ASMDIR_RECO"
    diff --suppress-common-lines -yW 27 <(echo "${ASMDIR_DATA}") <(echo "${ASMDIR_RECO}") | grep -v ','
    unset DIFF_COUNT; DIFF_COUNT=$(diff <(echo "${ASMDIR_DATA}") <(echo "${ASMDIR_RECO}") | grep -vc ",")
    [ "${DIFF_COUNT}" -eq 0 ] && echo "No difference : OK" #|| echo "Difference detected \"${DIFF_COUNT}\" : KO"

    echo -e "\nDifference between :\nASMDIR_DATA vs CRS_DBUNAME"
    diff --suppress-common-lines -yW 27 <(echo "${ASMDIR_DATA}") <(echo "${CRS_DBUNAME}") | grep -v ','
    unset DIFF_COUNT; DIFF_COUNT=$(diff <(echo "${ASMDIR_DATA}") <(echo "${CRS_DBUNAME}") | grep -vc ",")
    [ "${DIFF_COUNT}" -eq 0 ] && echo "No difference : OK" #|| echo "Difference detected \"${DIFF_COUNT}\" : KO"

    echo -e "\nDifference between :\nASMDIR_RECO vs CRS_DBUNAME"
    diff --suppress-common-lines -yW 27 <(echo "${ASMDIR_RECO}") <(echo "${CRS_DBUNAME}") | grep -v ','
    unset DIFF_COUNT; DIFF_COUNT=$(diff <(echo "${ASMDIR_RECO}") <(echo "${CRS_DBUNAME}") | grep -vc ",")
    [ "${DIFF_COUNT}" -eq 0 ] && echo "No difference : OK" #|| echo "Difference detected \"${DIFF_COUNT}\" : KO"
}


function cr_pfile_from_spfile {
	SPFILE_ASM=$(srvctl config database -d ${DBUNAME} | grep spfile | cut -d' ' -f2)
	#export ORACLE_HOME=
	echo -e "create pfile='/tmp/init@.ora' from spfile='${SPFILE_ASM}' ;" | sqlplus -S / as sysdba
}


function set_oracle_wallet {
    local REP_WALLET_INFRA
    REP_WALLET_INFRA="${TOOLKIT_DIR:-/prsyslib/toolunix/bin}/ora/wallet_infra"
    export TNS_ADMIN=${1:-$REP_WALLET_INFRA}
    echo "TNS_ADMIN=${TNS_ADMIN}"
}

function oracle_wallet_infra {
    local REP_WALLET_INFRA
    #hostname | grep prdres &>/dev/null && ENV=PRD
    #hostname | grep intres &>/dev/null && ENV=HPR
    [ "${ENV}" = "HPR" ] && local WALLET_PASSWD=${WALLET_PASSWD:-$(echo "aUZLVVcjSCQhdWhBdHVYCg==" | base64 -d)}
    [ "${ENV}" = "PRD" ] && local WALLET_PASSWD=${WALLET_PASSWD:-$(echo "YXZTU2kjPWRhbUVzUWZHCg==" | base64 -d)}
    # FGR : #orapki wallet change_pwd -wallet ${REP_WALLET_INFRA} -oldpwd '<old_passwd>' -newpwd '<new_passwd>'
    if $(which --skip-alias mkstore &>/dev/null); then echo "ORACLE_HOME=${ORACLE_HOME}"; else echo "ORACLE_HOME not set"; return 0; fi
    REP_WALLET_INFRA="${TOOLKIT_DIR:-/prsyslib/toolunix/bin}/ora/wallet_infra"
    export TNS_ADMIN=${REP_WALLET_INFRA}
    echo "TNS_ADMIN=${TNS_ADMIN}"
    [ -z "${WALLET_PASSWD}" ] && read -p "Enter Wallet Password : " -s WALLET_PASSWD
    if ! $(echo "${WALLET_PASSWD}" | mkstore -wrl ${REP_WALLET_INFRA} -listCredential &>/dev/null) ; then echo 'Wrong Wallet password' ; fi
    action=${1:-PRINT}

    NBR_ENTRIES=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${REP_WALLET_INFRA} -listCredential | grep -c [0-9]:)

    [ "${action}" == "CREATE_WALLET_COMMAND" ] && echo "echo -e \"\${WALLET_PASSWD}\n\${WALLET_PASSWD}\" | mkstore -wrl ${REP_WALLET_INFRA} -create"

    for i in $(seq 1 ${NBR_ENTRIES}) ; do
        unset WLT_USERNAME WLT_PASSWORD WLT_CONNECT_STRING
        WLT_USERNAME=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${REP_WALLET_INFRA} -viewEntry oracle.security.client.username${i} | grep username${i} | awk -F '= ' '{print $NF}')
        WLT_PASSWORD=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${REP_WALLET_INFRA} -viewEntry oracle.security.client.password${i} | grep password${i} | awk -F '= ' '{print $NF}')
        WLT_CONNECT_STRING=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${REP_WALLET_INFRA} -viewEntry oracle.security.client.connect_string${i} | grep connect_string${i}| awk -F '= ' '{print $NF}')

        [ "${action}" == "PRINT" ] && echo "${WLT_USERNAME}@${WLT_CONNECT_STRING}"
        [ "${action}" == "PRINT_PWD" ] && echo "${WLT_USERNAME}/${WLT_PASSWORD}@${WLT_CONNECT_STRING}"
        [ "${action}" == "TEST_CNX" ] && WLT_ENTRY="${WLT_USERNAME}/${WLT_PASSWORD}@${WLT_CONNECT_STRING}"

        if [ "${action}" == "TEST_CNX" ] ; then
            timeout 5 echo exit | sqlplus -L -S ${WLT_USERNAME}/${WLT_PASSWORD}@${WLT_CONNECT_STRING} && WLT_ENTRY+=" : cnx_OK" || WLT_ENTRY+=" : cnx_KO"
        fi

        if [ "${action}" == "CREATE_WALLET_COMMAND" ] ; then
            echo "echo \${WALLET_PASSWD} | mkstore -wrl \${REP_WALLET_INFRA} -createCredential ${WLT_CONNECT_STRING} ${WLT_USERNAME} ${WLT_PASSWORD}"
        fi

    [ "${action}" == "TEST_CNX" ] && echo "${WLT_ENTRY}"
    done
}


# echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} ${WLT_DFT_ARGS} -viewEntry oracle.security.client.default_password | grep =

function oracle_wallet_db {
[ -n "${DBG}" ] && set -x
    local DBUNAME
    local WALLET_PATH=${WALLET_PATH:-.}
    local WALLET_PASSWD=${WALLET_PASSWD}
    local WLT_DFT_ARGS='-nologo'
    local action=${1:-PRINT}

    #if [ ! -f "${WALLET_PATH}/cwallet.sso" -o ! -f "${WALLET_PATH}/ewallet.p12" ] ; then echo -e '\nWallet is inaccessible or does not exist' ; return 1; fi
    if [  -f "${WALLET_PATH}/cwallet.sso" -a -f "${WALLET_PATH}/ewallet.p12" ] ; then 
        #[ -z "${WALLET_PASSWD}" ] && read -p "Enter Wallet Password : " -s WALLET_PASSWD
        echo "Wallet Found : WALLET_PATH=${WALLET_PATH} => $(pwd)"
    elif [ "${WALLET_PATH}" = "." -a -n "${ORACLE_SID}" ] ; then
        [ -z "${DBUNAME}" ] && DBUNAME=$(srvctl config | grep ${ORACLE_SID:0:8})
        [ -x /apps ] && WALLET_PATH=/apps/oracle/${DBUNAME}/wallet/shared
        [ -x /srv ] && WALLET_PATH=/srv/oracle/${DBUNAME}/wallet/shared
        echo "Wallet Found : WALLET_PATH=${WALLET_PATH}"
    else
        echo -e '\nWallet is inaccessible or does not exist' 
        return 1 
    fi

    [ "${WALLET_PATH}" = "." ] && local WALLET_PATH_TEST=$(pwd)
    [[ "${WALLET_PATH_TEST:-$WALLET_PATH}" =~ "/wallet/shared" ]] && local ENV=CNVG

    [ "${ENV}" = "HPR" ] && local WALLET_PASSWD=${WALLET_PASSWD:-$(echo "aUZLVVcjSCQhdWhBdHVYCg==" | base64 -d)}
    [ "${ENV}" = "PRD" ] && local WALLET_PASSWD=${WALLET_PASSWD:-$(echo "YXZTU2kjPWRhbUVzUWZHCg==" | base64 -d)}
    [ "${ENV}" = "CNVG" ] && local WALLET_PASSWD=${WALLET_PASSWD:-$(echo "Vk9QbkQ1SG00N3RXd0pUamU4awo=" | base64 -d)}

    #[ -z "${DBUNAME}" ] && [ -z "${ORACLE_SID}" ] && { echo "ORACLE_SID not set"; return 1; }
    #[ -z "${DBUNAME}" ] && DBUNAME=$(srvctl config | grep ${ORACLE_SID:0:8})
    #WALLET_PATH=${WALLET_PATH:-/apps/oracle/${DBUNAME}/wallet/shared}
    #echo "Wallet Found : WALLET_PATH=${WALLET_PATH}"
    #export TNS_ADMIN=${WALLET_PATH}
    #echo "TNS_ADMIN=${TNS_ADMIN}"

    #if $(which --skip-alias mkstore &>/dev/null); then echo "ORACLE_HOME=${ORACLE_HOME}"; else echo "ORACLE_HOME not set"; return 0; fi
    if ! $(which --skip-alias mkstore &>/dev/null); then 
        echo "mkstore binary not is the path ... Searching ..."
        #if MKSTORE_BIN_PATH=$(dirname `locate -be '\mkstore' | grep grid | tail -1`); 
        #if MKSTORE_BIN_PATH=$(dirname `locate -be '\mkstore' | grep grid | tail -1`); then echo "MKSTORE_BIN_PATH=${MKSTORE_BIN_PATH}"; PATH=${PATH}:${MKSTORE_BIN_PATH}; else echo "! mkstore not found !"; return 0; fi
        if MKSTORE_BIN_PATH=$(dirname `locate -be '\mkstore' | xargs ls -1t | grep grid | head -1`) ;
            then echo "MKSTORE_BIN_PATH=${MKSTORE_BIN_PATH}"; PATH=${PATH}:${MKSTORE_BIN_PATH};
            else echo "! mkstore not found !";
            return 0
        fi
    #else 
    #    #echo "ORACLE_HOME=${ORACLE_HOME}"
    #    echo "MKSTORE_BIN_PATH=${MKSTORE_BIN_PATH}"
    fi

    #if ! $(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} -listCredential &>/dev/null) ; then echo 'Wrong Wallet password' ; fi
    #if [ $(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} ${WLT_DFT_ARGS} -list | grep -c 'incorrect password') -ne 0 ] ; then echo 'Wrong Wallet password' ; return 1; fi

    # orapki wallet display -wallet ${WALLET_PATH:-.}
    # orapki wallet display -wallet ${WALLET_PATH:-.} | grep 'oracle.security.client' |  wc -l
    array_wlt_check=( "$(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} ${WLT_DFT_ARGS} -list)" )
    if [ $(echo "${array_wlt_check}" | grep -c 'incorrect password') -eq 1 ] ; then echo -e '\nWrong Wallet password' ; return 1; fi
    if [ $(echo "${array_wlt_check}" | grep -c 'oracle.security.client') -eq 0 ] ; then echo -e '\nWallet Empty' ; return 1; fi
    if [ $(echo "${array_wlt_check}" | grep -c 'Oracle Secret Store entries') -eq 1 ] ; then echo -e '\nReading the Wallet ...' ; fi

    ## FGR Done above #array_wlt_entries=( "$(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} ${WLT_DFT_ARGS} -list | grep client | sort -t. -Vk4.7,4 | grep oracle.security.client)" )
    array_wlt_default=( $(echo "${array_wlt_check[@]}" | grep '\.default' | sort -rV) )
    array_wlt_entries=( "$(echo "${array_wlt_check}" | grep client | sort -t. -Vk4.7,4 | grep oracle.security.client)" )
    array_wlt_username=( $(echo "${array_wlt_entries}" | grep '\.username') )
    array_wlt_password=( $(echo "${array_wlt_entries}" | grep '\.password') )
    array_wlt_connect_string=( $(echo "${array_wlt_entries}" | grep '\.connect_string') )

    array_wlt_entries_value=( "$(echo ${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} ${array_wlt_entries//oracle./-viewEntry oracle.} | grep oracle.security.client)" )
    array_wlt_default_username_value=( $(echo "${array_wlt_entries_value}" | grep '\.default_username' | awk -F '= ' '{print $NF}') )
    array_wlt_default_password_value=( $(echo "${array_wlt_entries_value}" | grep '\.default_password' | awk -F '= ' '{print $NF}') )
    array_wlt_username_value=( $(echo "${array_wlt_entries_value}" | grep '\.username' | awk -F '= ' '{print $NF}') )
    array_wlt_password_value=( $(echo "${array_wlt_entries_value}" | grep '\.password' | awk -F '= ' '{print $NF}') )
    array_wlt_connect_string_value=( $(echo "${array_wlt_entries_value}" | grep '\.connect_string' | awk -F '= ' '{print $NF}') )

    [ "${action}" == "DBG" ] && echo "DBG : Print Wallet Entries Sorted 'sort -t. -Vk4.7,4'"
    [ "${action}" == "DBG" ] && (
    echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -list | grep client | sort -t. -Vk4.7,4
    echo -e "\narray_wlt_entries" && echo "${array_wlt_entries}"
    echo -e "\narray_wlt_default" && echo "${array_wlt_default[@]}"
    #echo -e "\narray_wlt_username" && echo -e "${array_wlt_username[@]//oracle./\noracle.}"
    #echo -e "\narray_wlt_password" && echo -e "${array_wlt_password[@]//oracle./\noracle.}"
    #echo -e "\narray_wlt_connect_string" && echo -e "${array_wlt_connect_string[@]//oracle./\noracle.}"

    echo -e "\narray_wlt_entries_value" && echo "${array_wlt_entries_value}"
    echo -e "\narray_wlt_default_value" && echo -e "${array_wlt_default_value[@]}"
    echo -e "\narray_wlt_username_value" && echo -e "${array_wlt_username_value[@]}"
    echo -e "\narray_wlt_password_value" && echo -e "${array_wlt_password_value[@]}"
    echo -e "\narray_wlt_connect_string_value" && echo -e "${array_wlt_connect_string_value[@]}"
    echo

    ## Default Credential
    # echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} ${WLT_DFT_ARGS} -viewEntry oracle.security.client.default_username | grep =
    # echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} ${WLT_DFT_ARGS} -viewEntry oracle.security.client.default_password | grep =
    
    if [ "${#array_wlt_default[@]}" -gt "0" ] ; then 
        echo "DBG DFT : ${array_wlt_default_username_value}/${array_wlt_default_password_value}"
        echo
    fi

    for wlt_idx in "${!array_wlt_username[@]}" ; do 
        #echo "idx[$wlt_idx] => ${array_wlt_username[$wlt_idx]} => ${array_wlt_username_value[$wlt_idx]}/${array_wlt_password_value[$wlt_idx]}@${array_wlt_connect_string_value[$wlt_idx]}" 
        echo "DBG : ${array_wlt_username_value[$wlt_idx]}/${array_wlt_password_value[$wlt_idx]}@${array_wlt_connect_string_value[$wlt_idx]}"
    done
    )


    [ "${action}" == "CREATE_WALLET_COMMAND" ] && echo && echo -e "# Create the Wallet :" && echo "echo -e \"\${WALLET_PASSWD}\n\${WALLET_PASSWD}\" | mkstore -wrl \${WALLET_PATH} ${WLT_DFT_ARGS} -create"
    #orapki wallet create -wallet ${WALLET_PATH} -pwd ${WALLET_PASSWD} -auto_login
    #echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} -createEntry oracle.security.client.default_username SYS
    #echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} -createEntry oracle.security.client.default_password ${PASSWORD}
    #echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} -list
    #echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} -deleteEntry oracle.security.client.default_username
    #echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} -deleteEntry oracle.security.client.default_password
    # FGR : #orapki wallet change_pwd -wallet ${WALLET_PATH} -oldpwd '<old_passwd>' -newpwd '<new_passwd>'
    #read -p "Enter SYS Password : " -s SYS_PASSWD ; /apps/dbatools/prod/script/ora_shared_wallet.ksh -I ${ORACLE_SID} -A ADD_DG -P ${SYS_PASSWD}
    #/apps/dbatools/prod/script/ora_shared_wallet.ksh -I ${ORACLE_SID} -A ADD_DG -P gIVQJXDXDjEHWM6
    #/apps/dbatools/prod/script/shared/ora_shared_wallet.ksh -I TBIOREX11 -A REMOVE_ZDLRA
    echo

    ## Loop Credentials
    [ "${action}" != "DBG" ] && (
    echo "# Default Credential :"
    if [ "${#array_wlt_default[@]}" -gt 0 ] ; then 
        [ "${action}" == "PRINT" ] && echo "${array_wlt_default_username_value}"
        [ "${action}" == "PRINT_PWD" ] && echo "${array_wlt_default_username_value}/${array_wlt_default_password_value}"
        [ "${action}" == "TEST_CNX" ] && ( timeout 5 echo exit | sqlplus -L -S ${array_wlt_default_username_value}/${array_wlt_default_password_value}@${array_wlt_connect_string_value} && echo "DFT : cnx_OK" || echo "DFT : cnx_KO" )
        [ "${action}" == "CREATE_WALLET_COMMAND" ] && (
            echo "echo \${WALLET_PASSWD} | mkstore -wrl \${WALLET_PATH} ${WLT_DFT_ARGS} -createEntry oracle.security.client.default_username ${array_wlt_default_username_value}"
            echo "echo \${WALLET_PASSWD} | mkstore -wrl \${WALLET_PATH} ${WLT_DFT_ARGS} -createEntry oracle.security.client.default_password ${array_wlt_default_password_value}"
        )
    fi
    echo
    
    echo "# Named Credential :"
    #NBR_ENTRIES=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -listCredential | grep -c [0-9]:)
    #for i in $(seq 1 ${NBR_ENTRIES}) ; do
    for wlt_idx in "${!array_wlt_username[@]}" ; do
        unset WLT_USERNAME WLT_PASSWORD WLT_CONNECT_STRING
        #WLT_USERNAME=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH}  ${WLT_DFT_ARGS} -viewEntry oracle.security.client.username${i} | grep username${i} | awk -F '= ' '{print $NF}')
        #WLT_PASSWORD=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH}  ${WLT_DFT_ARGS} -viewEntry oracle.security.client.password${i} | grep password${i} | awk -F '= ' '{print $NF}')
        #WLT_CONNECT_STRING=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -viewEntry oracle.security.client.connect_string${i} | grep connect_string${i}| awk -F '= ' '{print $NF}')
        WLT_USERNAME=${array_wlt_username_value[$wlt_idx]}
        WLT_PASSWORD=/${array_wlt_password_value[$wlt_idx]}
        WLT_CONNECT_STRING=@${array_wlt_connect_string_value[$wlt_idx]}

        [ "${action}" == "PRINT" ] && echo "${WLT_USERNAME}${WLT_CONNECT_STRING}"
        [ "${action}" == "PRINT_PWD" ] && echo "${WLT_USERNAME}${WLT_PASSWORD}${WLT_CONNECT_STRING}"

        if [ "${action}" == "TEST_CNX" ] ; then
            WLT_ENTRY="${WLT_USERNAME}${WLT_PASSWORD}${WLT_CONNECT_STRING}"
            timeout 5 echo exit | sqlplus -L -S ${array_wlt_username_value[$wlt_idx]}/${array_wlt_password_value[$wlt_idx]}@${array_wlt_connect_string_value[$wlt_idx]} && WLT_ENTRY+=" : cnx_OK" || WLT_ENTRY+=" : cnx_KO"
            echo "${WLT_ENTRY}"
        fi

        if [ "${action}" == "CREATE_WALLET_COMMAND" ] ; then
            echo "echo \${WALLET_PASSWD} | mkstore -wrl \${WALLET_PATH} ${WLT_DFT_ARGS} -createCredential ${array_wlt_connect_string_value[$wlt_idx]} ${array_wlt_username_value[$wlt_idx]} ${array_wlt_password_value[$wlt_idx]}"
            #echo "echo \${WALLET_PASSWD} | mkstore -wrl \${WALLET_PATH} \${WLT_DFT_ARGS} -createEntry ${array_wlt_connect_string_value[$wlt_idx]} ${array_wlt_username_value[$wlt_idx]} ${array_wlt_password_value[$wlt_idx]}"
        fi
    done
    )
[ -n "${DBG}" ] && set +x
}




## DBATOOLS Integration
# DBATools Source Environment
alias dbtenv='. <(cat ~/.profile | grep -v PS1)'


function oracle_wallet_dbatools {
[ -n "${DBG}" ] && set -x
    local PATH=${PATH}
    local WALLET_PATH
    local WALLET_PASSWD=${WALLET_PASSWD:-$(echo "Vk9QbkQ1SG00N3RXd0pUamU4awo=" | base64 -d)}
    local WLT_DFT_ARGS='-nologo'
    local SYS_PASSWD=${SYS_PASSWD}
    #local action=${1^^:-PRINT}
    local action=${1:-PRINT}
    [ "${action}" == "SET" ] && (
        local SYS_PASSWD=${SYS_PASSWD:-$2}
        [ -z "${SYS_PASSWD}" ] && read -p "Enter SYS Password : " -s SYS_PASSWD
        [ -z "${SYS_PASSWD}" ] && { echo "! Variable SYS_PASSWD must be set !" ; return 1 ; }
        )
    echo 

    #if $(which --skip-alias mkstore &>/dev/null); then echo "ORACLE_HOME=${ORACLE_HOME}"; else echo "ORACLE_HOME not set"; return 0; fi
    if $(which --skip-alias mkstore &>/dev/null); then 
        echo "ORACLE_HOME=${ORACLE_HOME}"
    else 
        echo "ORACLE_HOME not set"
        echo "Searching for mkstore binary :"
    #if BIN=$(dirname `locate -be '\mkstore' | grep grid | tail -1`); 
    #if BIN=$(dirname `locate -be '\mkstore' | grep grid | tail -1`); then echo "BIN=${BIN}"; PATH=${PATH}:${BIN}; else echo "! mkstore not found !"; return 0; fi
        if BIN=$(dirname `locate -be '\mkstore' | xargs ls -1t | grep grid | head -1`) ;
            then echo "BIN=${BIN}"; PATH=${PATH}:${BIN};
            else echo "! mkstore not found !";
            return 0
        fi
    fi

    [ -z "${DBUNAME}" ] && [ -z "${ORACLE_SID}" ] && { echo "ORACLE_SID not set"; return 1; }
    [ -z "${DBUNAME}" ] && DBUNAME=$(srvctl config | grep ${ORACLE_SID:0:8})
    WALLET_PATH=${WALLET_PATH:-/apps/oracle/${DBUNAME}/wallet/shared}
    echo "WALLET_PATH=${WALLET_PATH}"
    #export TNS_ADMIN=${WALLET_PATH}
    #echo "TNS_ADMIN=${TNS_ADMIN}"

    if [ ! -f "${WALLET_PATH}/cwallet.sso" -o ! -f "${WALLET_PATH}/ewallet.p12" ] ; then
#        [ "${action}" == "CMD" ] && \
          echo -e "# Create the Wallet :" #&& \
          [ ! -d "${WALLET_PATH}" ] && echo "=> Create Wallet Directory : ${WALLET_PATH}" || echo "=> Wallet Directory EXIST : ${WALLET_PATH}"
          echo "echo -e \"\${WALLET_PASSWD}\n\${WALLET_PASSWD}\" | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -create"
          #echo "echo -e \"${WALLET_PASSWD}\n${WALLET_PASSWD}\" | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -create"

          [ "${action}" == "SET" ] && (
              [ ! -d "${WALLET_PATH}" ] && if mkdir -p ${WALLET_PATH} ; then echo "Wallet Directory Created : ${WALLET_PATH}"; else echo "Unable to create the Wallet Directory : ${WALLET_PATH}"; fi
              echo -e "${WALLET_PASSWD}\n${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -create
              )

    fi

    [ -z "${WALLET_PASSWD}" ] && read -p "Enter Wallet Password : " -s WALLET_PASSWD
    if [ $(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -list | grep -c 'incorrect password') -ne 0 ] ; then echo 'Wrong Wallet password' ; return 1; fi
    COUNT_DFT_CRED=$(orapki wallet display -wallet ${WALLET_PATH:-.} ${WLT_DFT_ARGS} | grep 'oracle.security.client.default' | wc -l)

    if [ "${COUNT_DFT_CRED}" -eq 0 ] ; then
        echo "# Create Default Credentials :"
        #echo "echo \${WALLET_PASSWD} | mkstore -wrl \${WALLET_PATH} \${WLT_DFT_ARGS} -createCredential ${WLT_CONNECT_STRING} ${WLT_USERNAME} ${WLT_PASSWORD}"
        echo "echo \${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -createEntry oracle.security.client.default_username SYS"
        echo "echo \${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -createEntry oracle.security.client.default_password \${SYS_PASSWD}"

        [ "${action}" == "SET" ] && (
            echo ${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -createEntry oracle.security.client.default_username SYS  | grep -v 'Enter wallet password:'
            echo ${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -createEntry oracle.security.client.default_password ${SYS_PASSWD}  | grep -v 'Enter wallet password:'
            ) || return 0
    elif [ "${COUNT_DFT_CRED}" -eq 2 ] ; then
        echo "# Update Default Credentials Password :"
            WLT_SYS_PASSWD=$(echo ${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -viewEntry oracle.security.client.default_password | grep '\.default_password' | awk -F '= ' '{print $NF}')
            if [ "${SYS_PASSWD}" == "${WLT_SYS_PASSWD}" ] ; then
                echo "=> SYS password is identical to the stored wallet password"
                echo "echo \${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -modifyEntry oracle.security.client.default_password \${SYS_PASSWD}"

                [ "${action}" == "SET" ] && [ -n "${FORCE}" ] && (
                  [ "${action}" == "SET" ] && echo ${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -modifyEntry oracle.security.client.default_password ${SYS_PASSWD} | grep -v 'Enter wallet password:'
                ) || return 0
            else
                echo "echo \${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -modifyEntry oracle.security.client.default_password \${SYS_PASSWD}"
                [ "${action}" == "SET" ] && echo ${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -modifyEntry oracle.security.client.default_password ${SYS_PASSWD} | grep -v 'Enter wallet password:'
            fi
    fi
[ -n "${DBG}" ] && set +x
}


# RMARCHMON Resource
function lsarchmon {
CSSD_DIR=`dirname $( ps -eo args | grep ocssd.bin | grep -v grep | awk '{print $1}' )` &&  ${CSSD_DIR}/crsctl stat res -w "( NAME coi prc. ) AND ( NAME en .arc )"|grep STATE|cut -d ',' -f1,2|sed 's/STATE=/archmon /';
CSSD_DIR=`dirname $( ps -eo args | grep ocssd.bin | grep -v grep | awk '{print $1}' )` &&  ${CSSD_DIR}/crsctl stat res -w "( NAME coi prc.${ORACLE_SID:0:8} ) AND ( NAME en .arc )"|grep STATE|cut -d ',' -f1,2|sed 's/STATE=/archmon /';
}

function lsarchmon_not_ONLINE {
CSSD_DIR=`dirname $( ps -eo args | grep ocssd.bin | grep -v grep | awk '{print $1}' )` &&  ${CSSD_DIR}/crsctl stat res -w "( NAME coi prc. ) AND ( NAME en .arc ) AND (STATE != ONLINE)";
}

## DBMS.TAB
function DBMS_TAB_DIFF {
grep OB /etc/oratab|awk -F: '{printf("%8s %s\n",substr($1,0,8),$2);}'|sort -u >/tmp/temporatab
grep OB /srv/dbatools/etc/dbms.tab|awk -F: '{printf("%8s %s\n",substr($2,0,8),$3);}'|sort -u >/tmp/tempdbmstab
diff /tmp/temporatab /tmp/tempdbmstab|grep OB|awk '{print $2}'|sort -u
rm /tmp/temporatab /tmp/tempdbmstab
}




## ALIAS COMMON
alias fgdbg='bash -xc '\''echo "0:$0 ; 0-modded:${0#bash} ; 1:$1"'\'''
alias yumrepo="egrep -Hi '(^\[|^enabled)' /etc/yum.repos.d/*"
alias resetenv='env -i PS1="[\u@\h \W]\$ " bash --norc --noprofile'


## ALIAS SYSTEM
alias ls='ls --color=auto'
alias l='ls -ail'
alias ll='ls -al'
alias lt='ls -alt'
alias ltr='ls -altr'
alias ltrh='ls -altrh'
alias lh='ls -alh'
alias lht='ls -alht'
alias lhtr='ls -alhtr'
alias lsinode="ls . -AiR1U | sed -rn '/^[./]/{h;n;}; G; s|^ *([0-9][0-9]*)[^0-9][^/]*([~./].*):|\1:\2|p' | sort -t : -uk1.1,1n | cut -d: -f2 | sort -V | uniq -c | sort -rn | head -n10"
alias duinode="du --inodes --separate-dirs | sort -rh | sed -n '1,50{/^.\{71\}/s/^\(.\{30\}\).*\(.\{37\}\)$/\1...\2/;p}' | sort -r"
alias grep='grep --color=auto'
#alias echopath='echo $PATH | tr : \\n'
alias echopath='echo -e ${PATH//:/\\n}'
alias lspath='echo -e ${PATH//:/\\n}'
alias psg="ps aux | grep -v grep | grep -i"
#alias dmesg='dmesg -H'
alias vim='vim -u ${LIBDIR}/.vimrc'
alias vi=vim
[ ! -d '/usr/share/vim/vim74' ] && export VIMRUNTIME=${LIBDIR}/share/vim/vim74
alias ssh='ssh -o ServerAliveInterval=30'
alias netbreakdown="netstat -nat | awk '{print $6}' | sort | uniq -c | sort -n"


## ALIAS APPS
alias iperf3_stop='pkill -ecnf "iperf3 -sD"'
alias nmon=${BINDIR}/nmon
alias nmon14g=${BINDIR}/nmon14g_x86_rhel7


## SCREEN
# To avoid error : screen Cannot open your terminal '/dev/pts/0' - please check.
#script /dev/null => bash -c '\''script /dev/null -q -c

## FGR 2022-02-04 : Force the use of the custom screen in case other screen rpm is installed
alias screen='${BI_PATH}/bin/screen -h 50000'
#alias screen='screen -h 50000'
alias sc='screen -h 50000'
alias scls='screen -ls'
#alias scls='screen -ls | \grep "${1}"'
alias sclsa='find /var/run/screen/ -type s'
alias scr='screen -r'
alias scs='screen -S'
# Command SCRIPT is used as a workaround when not connected as root : "Cannot open your terminal '/dev/pts/0' - please check."
alias scr='bash -c '\''script /dev/null -q -c "screen -r ${0#bash}"'\'''
alias scrd='bash -c '\''script /dev/null -q -c "screen -rd ${0#bash}"'\'''
alias scx='bash -c '\''script /dev/null -q -c "screen -x ${0#bash}"'\'''
alias scrx='bash -c '\''script /dev/null -q -c "screen -rx ${0#bash}"'\'''
alias scs='bash -c '\''script /dev/null -q -c "screen -h 50000 -S ${0#bash}"'\'''

export SCREENRC=${LIBDIR}/.screenrc
# .screenrc
# Enable mouse scroll
#termcapinfo xterm* ti@:te@

# Keep scrollback n lines
#defscrollback 50000

# Enable screen caption
#hardstatus on
#hardstatus alwayslastline

# Forward $STY to screen session after a SUDO
#screen
#screen $SHELL -c 'screen -X caption always "$STY"'
#caption always "%{= kc}Screen session on %H (system load: %l) %-28=%{= .m} %Y-%m-%d %0c"
#caption always "%{= kc}Screen session on %H (system load: %l) %-28=%{= .m} %D %d-%m-%Y %0c"


## FUNCTIONS
#du -sk ./* | /usr/bin/sort -n | /usr/bin/awk 'BEGIN{ pref[1]="K"; pref[2]="M"; pref[3]="G";} { total = total + $1; x = $1; y = 1; while( x > 1024 ) { x = (x + 1023)/1024; y++; } printf("%g%s\t%s\n",int(x*10)/10,pref[y],$2); } END { y = 1; while( total > 1024 ) { total = (total + 1023)/1024; y++; } printf("Total: %g%s\n",int(total*10)/10,pref[y]); }'
#du -sk * | awk '{ total = total + $1 } END { print total }'
#ls -l | awk '{sum += $5} END {print sum}'


function ethlink {
  for i in 1 2 3 4 ; do echo "=== eth$i === : $(ethtool eth$i 2>&1 | egrep "Speed|Duplex|Link|Auto" | grep -Ev 'Unknown|Operation not permitted' | paste -s -)" ; done
}


## TMUX
alias tmux='tmux -f ${LIBDIR}/.tmux.conf'
alias tms='tmux new -s'
alias tma='tmux attach'
alias tmls='tmux ls'
alias tmkill='tmux kill-session -t'
alias tmkillall="tmux ls | grep : | cut -d. -f1 | awk '{print substr($1, 0, length($1)-1)}' | xargs kill"
alias tmkillall2='while [ $? -ne 1 ]; do tmux kill-session; done'


## ANSIBLE
export ANSIBLE_CONFIG=~/ansible/ansible.cfg
ANSIBLE_HOST_KEY_CHECKING=False
export ANSIBLE_REMOTE_USER=root
#export ANSIBLE_INVENTORY=~/ansible/inventory/
#export ANSIBLE_HOST_KEY_CHECKING=False
#export ANSIBLE_LIBRARY=${MYDIR}/../library
#export ANSIBLE_MODULE_UTILS=${MYDIR}/../module_utils
#export ANSIBLE_VAULT_PASSWORD_FILE=~/.vault_pass.txt


## Builtin Enhancement
function dufg {
ARG1=${1:-*}
du -sk ./${ARG1} | /usr/bin/sort -n | /usr/bin/awk 'BEGIN{ pref[1]="K"; pref[2]="M"; pref[3]="G";} { total = total + $1; x = $1; y = 1; while( x > 1024 ) { x = (x + 1023)/1024; y++; } printf("%g%s\t%s\n",int(x*10)/10,pref[y],$2); } END { y = 1; while( total > 1024 ) { total = (total + 1023)/1024; y++; } printf("Total: %g%s\n",int(total*10)/10,pref[y]); }'
}


function ts1 {
[ -n "$1" ] && filter="$*" || filter="*"
du -sk ${filter} | sort -n | awk '
     BEGIN {
        split("KB,MB,GB,TB,PB,EB,ZB,YB", Units, ",");
     }
     {
        total = total + $1
        u = 1;
        while ($1 >= 1024) {
           $1 = $1 / 1024;
           u += 1
        }
        $1 = sprintf("%.1f %s", $1, Units[u]);
        print $0;
     }
    END {
      u = 1;
      while (total >= 1024) {
        total = total / 1024;
        u += 1
      }
      printf("\n%.1f %s Total\n", total, Units[u]);
    }
'
}

function ts {
[ -n "$1" ] && filter="$*" || filter="*"
du -sk ${filter} | sort -n | awk '
    BEGIN {
      split("KB,MB,GB,TB,PB,EB,ZB,YB", Units, ",");
    }
    {
      total = total + $1
      u = 1;
      while ($1 >= 1024) {
        $1 = $1 / 1024;
        u += 1
      }
      $1 = sprintf("%.1f %s", $1, Units[u]);
      #$3 = system("bash -c '\''stat -c %y "$2"'\''");
      #fdate = system("stat -c %y " $2);
      fdate_cmd="stat -c %y "$2" | cut -d. -f1"
      if (Units[u] != "KB") {fdate_cmd | getline fdate; close(fdate_cmd);} #else {fdate=""}
      #print $0
      #print $1" "fdate"   "$2
      print $0"   "fdate
      #printf("%.1f %s %s %s\n", $1, Units[u], fdate, $2);
    }
    END {
      u = 1;
      while (total >= 1024) {
        total = total / 1024;
        u += 1
      }
      printf("\n%.1f %s Total\n", total, Units[u]);
    }
'
}

## Find big files
#find . -xdev -type f -size +50M -print | xargs ls -lh | sort -k5,5 -h -r | head

alias nbfilebyday="stat -c "%y" * |cut -d' ' -f1|sort|uniq -c"
alias nbhfilebyday="stat -c "%y" * .*|cut -d' ' -f1|sort|uniq -c|tr -d "-""
function sizebyDay { ls -l --time-style=long-iso * | awk '{sum[$6] += $5/1048576;} END { for (date in sum) {printf "%s MB %d\n", date, sum[date];} }' | sort -k1 | column -t ; }
function sizebyDay2 { ls -l --time-style=long-iso * | WHINY_USERS=-9 awk 'END { for (date in sum) printf "%s\t MB %-15d\n", date, sum[date];} { sum[$6] += $5/1048576;}' ; }

## Only files, from current directory only, sorted by date and summed
function sizebyDayf { find ./ -maxdepth 1 -type f -printf '%TY-%Tm-%Td %s\n' | awk '{sum[$1] += $2/1048576;} END { for (date in sum){printf "%-15s MB %d\n", date, sum[date];} }' | sort ; }

## Only files, recursively, sorted by date and summed
function sizebyDayfr { find ./ -type f -printf '%TY-%Tm-%Td %s\n' | awk '{sum[$1] += $2/1048576; total += $2/1048576} END { for (date in sum){printf "%-15s MB %d\n", date, sum[date];} printf "Total MB %d\n", total; }' | sort ; }
function sizebyMonthfr { find ./ -type f -printf '%TY-%Tm %s\n' | awk '{sum[$1] += $2/1048576; total += $2/1048576} END { for (date in sum){printf "%-15s MB %d\n", date, sum[date];} printf "Total MB %d\n", total; }' | sort ; }

#time find -type f -ctime +90 | xargs -ifile du file | cut -d'/' -f1,2 | awk '{sum[$2] += $1/1024; total += $1/1048576} END { for (dir in sum){printf "%-30s MB %d\n", dir, sum[dir];} printf "Total MB %d\n", total; }' | sort -nk3


adGetuserInfo () {
    [ -z "$1" ] && echo Arg 1 is Required && return 1
    getent passwd $1
    [ -n "$2" ] && GREP_GROUP="| grep -i $2" && \
      eval "getent group | grep -i $1 | cut -d: -f1 ${GREP_GROUP}"
}

adGetgroupInfo () {
    [ -z "$1" ] && echo Arg 1 is Required && return 1
    echo $(getent group $1 | cut -d: -f1) GID:$(getent group $1 | cut -d: -f3)
    for aduser in $(getent group $1 | cut -d: -f4 | sed "s/,/\n/g" | sort)
    do
        [ -z "$2" ] && getent passwd $aduser | cut -d: -f1,5
        [ "$2" == "-v" ] && adGetuserInfo $aduser $3
    done
}


nfsgetacl() { nfs4_getfacl "$@" | grep -Ev "OWNER|GROUP|EVERYONE"; };


## Locate Enhancement
locd () {
    locate -0 -b -A "$@" | xargs -0 -I {} bash -c '[ -d "{}" ] && echo "{}"'
}

locf () {
    locate -0 -b -A "$@" | xargs -0 -I {} bash -c '[ -f "{}" ] && echo "{}"'
}


function MemRpt {

## https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt
## HugePages_Total is the size of the pool of huge pages.
## HugePages_Free  is the number of huge pages in the pool that are not yet
##                 allocated.
## HugePages_Rsvd  is short for "reserved," and is the number of huge pages for
##                 which a commitment to allocate from the pool has been made,
##                 but no allocation has yet been made.  Reserved huge pages
##                 guarantee that an application will be able to allocate a
##                 huge page from the pool of huge pages at fault time.
## HugePages_Surp  is short for "surplus," and is the number of huge pages in
##                 the pool above the value in /proc/sys/vm/nr_hugepages. The
##                 maximum number of surplus huge pages is controlled by
##                 /proc/sys/vm/nr_overcommit_hugepages.
## Hugepagesize    is the default hugepage size (in Kb).
## Hugetlb         is the total amount of memory (in kB), consumed by huge
##                 pages of all sizes.
##                 If huge pages of different sizes are in use, this number
##                 will exceed HugePages_Total * Hugepagesize. To get more
##                 detailed information, please, refer to
##                 /sys/kernel/mm/hugepages (described below).
## AnonHugePages entry lists the number of pages that the newer Transparent Huge Page mechanism currently has in use


    args=$*
    for argv in $* ; do
        case $argv in
        -h*)     Usage;;
        --csv)   local CSV=1 ; shift 1 ;;
        --int)   local INT=1 ; shift 1 ;;
        --float) local FLOAT=1 ; shift 1 ;;
        *) Usage;;
        #-exemple_1)    export EX=YES ; shift 1 ;;
        #-exemple_2*)    export EX=$2 ;  if [ "$2" = "" ]; then Usage ; else shift 2 ; fi ;;
        esac
    done

    [ -z "${INT}" -a -z "${FLOAT}" ] && local FLOAT=1
    [ -n "${FLOAT}" ] && local BC_SCALE='scale=2; '
    #[ -n "${CSV}" ] && stty flusho

    local MEM_TOTAL_GB=$(free -g | grep Mem | awk '{print $2}')
    local MEM_USED_GB=$(free -g | grep Mem | awk '{print $3}')
    local MEM_FREE_GB=$(free -g | grep Mem | awk '{print $4}')
    local MEM_CACHE_GB=$(free -g | grep Mem | awk '{print $6}')
    local MEM_AVAIL_GB=$(free -g | grep Mem | awk '{print $7}')
    local SWAP_TOTAL_GB=$(free -g | grep Swap | awk '{print $2}')
    local SWAP_USED_GB=$(free -g | grep Swap | awk '{print $3}')
    local SWAP_FREE_GB=$(free -g | grep Swap | awk '{print $4}')

    echo "Memory_Total GB : ${MEM_TOTAL_GB}"
    echo "Memory_Used  GB : ${MEM_USED_GB}"
    echo "Memory_Free  GB : ${MEM_FREE_GB}"
    echo "Memory_Cache GB : ${MEM_CACHE_GB}"
    echo "Memory_Avail GB : ${MEM_AVAIL_GB}"
    echo "Swap_Total GB : ${SWAP_TOTAL_GB}"
    echo "Swap_Used  GB : ${SWAP_USED_GB}"
    echo "Swap_Free  GB : ${SWAP_FREE_GB}"

    local PAGE_SIZE=$(getconf PAGE_SIZE)
    local SHMALL=$(cat /proc/sys/kernel/shmall)

    if [ "${INT}" == "1" ]; then
    local SHM_LIMIT_GB=$(( ${PAGE_SIZE} * ${SHMALL} / 1073741824 ))
    local SHM_USED_GB=$(ipcs -m | grep oracle | awk '{sum += $5} END {printf "%.0f", sum/1073741824}')
    local SHM_FREE_GB=$(( ${SHM_LIMIT_GB} - ${SHM_USED_GB} ))
    elif [ "${FLOAT}" == "1" ]; then
    local SHM_LIMIT_GB=$(echo "${BC_SCALE} ${PAGE_SIZE} * ${SHMALL} / 1073741824" | bc)
    local SHM_USED_GB=$(ipcs -m | grep oracle | awk '{sum += $5} END {printf "%.0f", sum/1073741824}')
    local SHM_FREE_GB=$(echo "${BC_SCALE} ${SHM_LIMIT_GB} - ${SHM_USED_GB}" | bc)
    fi
    echo "Shared_Memory_Limit GB : ${SHM_LIMIT_GB}"
    echo "Shared_Memory_Used  GB : ${SHM_USED_GB}"
    echo "Shared_Memory_Free  GB : ${SHM_FREE_GB}"

    local HPG_SIZE=$(grep Hugepagesize /proc/meminfo | awk '{print $2}')
    local HPG_TOTAL=$(grep HugePages_Total /proc/meminfo | awk '{print $2}')
    local HPG_FREE=$(grep HugePages_Free /proc/meminfo | awk '{print $2}')
    local HPG_RSVD=$(grep HugePages_Rsvd /proc/meminfo | awk '{print $2}')

    if [ "${INT}" == "1" ]; then
    local HPG_TOTAL_GB=$(( ${HPG_SIZE} * ${HPG_TOTAL} / 1048576 ))
    local HPG_RAWUSED_GB=$(( ${HPG_SIZE} * (${HPG_TOTAL} - ${HPG_FREE}) / 1048576 ))
    local HPG_RAWFREE_GB=$(( ${HPG_SIZE} * ${HPG_FREE} / 1048576 ))
    local HPG_RSVD_GB=$(( ${HPG_SIZE} * ${HPG_RSVD} / 1048576 ))
    local HPG_USED_GB=$(( ${HPG_SIZE} * (${HPG_TOTAL} - ${HPG_FREE} + ${HPG_RSVD}) / 1048576 ))
    local HPG_FREE_GB=$(( ${HPG_SIZE} * (${HPG_FREE} - ${HPG_RSVD}) / 1048576 ))
    local HPG_USED_PERCENT=$(( ${HPG_USED_GB} * 100 / ${HPG_TOTAL_GB} ))
    local HPG_FREE_PERCENT=$(( ${HPG_FREE_GB} * 100 / ${HPG_TOTAL_GB} ))
    elif [ "${FLOAT}" == "1" ]; then
    local HPG_TOTAL_GB=$(echo "${BC_SCALE} ${HPG_SIZE} * ${HPG_TOTAL} / 1048576" | bc)
    local HPG_RAWUSED_GB=$(echo "${BC_SCALE} ${HPG_SIZE} * (${HPG_TOTAL} - ${HPG_FREE}) / 1048576" | bc)
    local HPG_RAWFREE_GB=$(echo "${BC_SCALE} ${HPG_SIZE} * ${HPG_FREE} / 1048576" | bc)
    local HPG_RSVD_GB=$(echo "${BC_SCALE} ${HPG_SIZE} * ${HPG_RSVD} / 1048576" | bc)
    local HPG_USED_GB=$(echo "${BC_SCALE} ${HPG_SIZE} * (${HPG_TOTAL} - ${HPG_FREE} + ${HPG_RSVD}) / 1048576" | bc)
    local HPG_FREE_GB=$(echo "${BC_SCALE} ${HPG_SIZE} * (${HPG_FREE} - ${HPG_RSVD}) / 1048576" | bc)
    local HPG_USED_PERCENT=$(echo "${BC_SCALE}  ${HPG_USED_GB} * 100 / ${HPG_TOTAL_GB}" | bc)
    local HPG_FREE_PERCENT=$(echo "${BC_SCALE} ${HPG_FREE_GB} * 100 / ${HPG_TOTAL_GB}" | bc)
    fi

    echo "HugePages_Total   GB : ${HPG_TOTAL_GB}"
    echo "HugePages_RawUsed GB : ${HPG_RAWUSED_GB}"
    echo "HugePages_RawFree GB : ${HPG_RAWFREE_GB}"
    echo "HugePages_Rsvd    GB : ${HPG_RSVD_GB}"
    echo "HugePages_Used    GB : ${HPG_USED_GB}"
    echo "HugePages_Free    GB : ${HPG_FREE_GB}"
    echo "HugePages_Used     % : ${HPG_USED_PERCENT}"
    echo "HugePages_Free     % : ${HPG_FREE_PERCENT}"

    if [ "${INT}" == "1" ]; then
    local MEM_FREE_GDTOTAL=$(( ${MEM_AVAIL_GB} + ${HPG_FREE_GB} ))
    local MEM_USED_GDTOTAL_PERCENT=$(( (${MEM_USED_GB} - ${HPG_TOTAL_GB} + ${HPG_USED_GB}) * 100 / ${MEM_TOTAL_GB} ))
    local MEM_FREE_GDTOTAL_PERCENT=$(( (${MEM_AVAIL_GB} + ${HPG_FREE_GB}) * 100 / ${MEM_TOTAL_GB} ))
    elif [ "${FLOAT}" == "1" ]; then
    local MEM_FREE_GDTOTAL=$(echo "${BC_SCALE} ${MEM_AVAIL_GB} + ${HPG_FREE_GB}" | bc)
    local MEM_USED_GDTOTAL_PERCENT=$(echo "${BC_SCALE} (${MEM_USED_GB} - ${HPG_TOTAL_GB} + ${HPG_USED_GB}) * 100 / ${MEM_TOTAL_GB}" | bc)
    local MEM_FREE_GDTOTAL_PERCENT=$(echo "${BC_SCALE} (${MEM_AVAIL_GB} + ${HPG_FREE_GB}) * 100 / ${MEM_TOTAL_GB}" | bc)
    fi

    echo "Memory_Grand_Total_Free  GB : ${MEM_FREE_GDTOTAL} / ${MEM_TOTAL_GB}"
    echo "Memory_Grand_Total_Used  %  : ${MEM_USED_GDTOTAL_PERCENT}"
    echo "Memory_Grand_Total_Free  %  : ${MEM_FREE_GDTOTAL_PERCENT}"

    #[ -n "${CSV}" ] && stty -flusho
    #[ "${1^^}" == "CSV" ] && 
    [ "${CSV}" == "1" ] && echo "$(date "+%d/%m/%Y"),$(hostname -s),${MEM_FREE_GDTOTAL}" || return 0
}


function hugepages_calculator {
#!/bin/bash
#
# hugepages_setting.sh
#
# Linux bash script to compute values for the
# recommended HugePages/HugeTLB configuration
#
# Note: This script does calculation for all shared memory
# segments available when the script is run, no matter it
# is an Oracle RDBMS shared memory segment or not.
# Check for the kernel version
KERN=`uname -r | awk -F. '{ printf("%d.%d\n",$1,$2); }'`
# Find out the HugePage size
HPG_SZ=`grep Hugepagesize /proc/meminfo | awk {'print $2'}`
# Start from 1 pages to be on the safe side and guarantee 1 free HugePage
NUM_PG=1
# Cumulative number of pages required to handle the running shared memory segments
for SEG_BYTES in `ipcs -m | awk {'print $5'} | grep "[0-9][0-9]*"`
do
   MIN_PG=`echo "$SEG_BYTES/($HPG_SZ*1024)" | bc -q`
   if [ $MIN_PG -gt 0 ]; then
      NUM_PG=`echo "$NUM_PG+$MIN_PG+1" | bc -q`
   fi
done
# Finish with results
case $KERN in
   '2.4') HUGETLB_POOL=`echo "$NUM_PG*$HPG_SZ/1024" | bc -q`;
          echo "Recommended setting : vm.hugetlb_pool = $HUGETLB_POOL" ;;
   '2.6' | '3.8' | '3.10' | '4.1' | '4.14' ) echo "Recommended setting : vm.nr_hugepages = $NUM_PG" ;;
    *) echo "Unrecognized kernel version $KERN. Exiting." ;;
esac

echo "Current HugePages Allocated : 2K hugepages = " $(cat /proc/sys/vm/nr_hugepages)
# End
}


function pshugepage {
  HUGEPAGECOUNT=0
  for num in $(grep 'anon_hugepage.*dirty=' /proc/$@/numa_maps | awk '{print $6}' | sed 's/dirty=//') ; do
    HUGEPAGECOUNT=$((HUGEPAGECOUNT+num))
  done
  echo "NUMA_MAPS : Process $@ using $(( ${HUGEPAGECOUNT} * 2048 / 1048576 )) GB of HugePages : (${HUGEPAGECOUNT} HugePages)"

  HP_SMAPS_GB=$(grep -B 11 'KernelPageSize: *2048 kB' /proc/$@/smaps | grep "^Size:" | awk 'BEGIN{sum=0}{sum+=$2}END{print sum/1048576}')
  printf "SMAPS     : Process $@ using %.2f GB of HugePages\n" "${HP_SMAPS_GB}"
}


function EXA_TEST_FLUX {
    EXA_CNVG_HPR="..." ; ENDPOINT_PORT=10198
    EXA_CNVG_BCH="..." ; ENDPOINT_PORT=10198
    EXA_CNVG_PRD="..." ; ENDPOINT_PORT=10098
    for EXA_LIST in $(set | grep EXA_CNVG_ | cut -d= -f1); do 
        echo "${EXA_LIST}=${!EXA_LIST}"
        for endpoint in ${!EXA_LIST}; do echo "${endpoint}:${ENDPOINT_PORT} :" ; nc -vzw1 ${endpoint} ${ENDPOINT_PORT} 2>&1 | grep -v 'Version' ; done
    done
}


## BASH COMPLETION
# .inputrc
bind 'set completion-query-items 300'
#bind 'set print-completions-horizontally off'
#set rl_completion_query_items 1000

#bind 'set mark-directories on'
#bind 'set mark-symlinked-directories on'
#bind 'set page-completions off'
#bind 'set show-all-if-ambiguous on'
#bind 'set visible-stats on'

#alias oenv='bash -xc '\''script /dev/null -q -c "export ORAENV_ASK=NO;  export ORACLE_SID=$0; source /usr/local/bin/oraenv; echo ${ORACLE_SID}:${ORACLE_HOME}"'\'''
#alias oenv='script /dev/null -q -c "echo export ORAENV_ASK=NO;  export ORACLE_SID=$0; source /usr/local/bin/oraenv; echo ${ORACLE_SID}:${ORACLE_HOME}"'

## FUNCTIONS COMPLETION
oenv() {
    ORAENV_ASK=NO
    ORACLE_SID=$1
    . oraenv >/dev/null
    echo ${ORACLE_SID}:${ORACLE_HOME}
    unset ORAENV_ASK
    # OR #ORAENV_ASK=YES . oraenv <<<${1} 1>/dev/null

    ## FGR : To reload some alias
    fgenv -s
    ## Remove GRID path if exist to make sure we use the RDBMS path
    pathremove ${GI_BIN}
}
export -f oenv


_word_list_instance() {
## FGR 2023-11-06 : PGREG is Faster than PS
#    [ -z "${word_list_instance}" ] && word_list_instance=$(ps -eo args | grep pm[o]n | grep -v APX | cut -d'_' -f3- | cut -c1-10)
    [ -z "${word_list_instance}" ] && word_list_instance=$(pgrep -a pmon | grep -v APX | cut -d'_' -f3- | cut -c1-10)
#    [ -z "${word_list_dbname}" ] && word_list_dbname=$(ps -eo args | grep pm[o]n | grep -v APX | cut -d'_' -f3- | cut -c1-8)
#    [ -z "${word_list_dbname}" ] && word_list_dbname=$(pgrep -a pmon | grep -v APX | cut -d'_' -f3- | cut -c1-8)
    word_list_bisudo=$(grep "^[^#|^$|^ *$]" ${SCRIPT_DIR}/ora/env/init.allow 2>/dev/null | cut -d' ' -f2 | uniq)
}
_word_list_instance


_ora_completion() {
    local cur prev ante
    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}
    ante=${COMP_WORDS[COMP_CWORD-2]}
    first=${COMP_WORDS[0]}
    array_scripts=$(ls -p ${SCRIPT_DIR} | grep -v '/')
#    array_scripts=$(grep "^[^#|^$|^ *$]" ${SCRIPT_DIR}/ora/env/init.allow | cut -d' ' -f2 | uniq -u)
#    array_scripts_args=( "${array_scripts[@]//ora_shell.sh}" )

    #word_list=$(cat /etc/oratab | cut -d':' -f1 | grep -v '#')
    #word_list=$(crsctl status resource -w "TYPE = ora.database.type" -p|grep USR_ORA_INST_NAME|sed "s:.*=::"|sort -u)
    #word_list=$(grep -v -e "^#\|^ \|^$" /etc/oratab | cut -f1 -d: | paste -sd " " -)
    #word_list=$(grep -v -e "^#\|^ \|^$" /etc/oratab | cut -f1 -d: | grep "$(ps -eo args | grep pm[o]n | cut -d'_' -f3- | cut -c1-10)" | paste -sd " " -)
#    word_list_instance=$(ps -eo args | grep pm[o]n | grep -v APX | cut -d'_' -f3- | cut -c1-10)
    [[ "${prev}" =~ "oenv" ]] && [ -z "${word_list_instance}" ] && word_list_instance=$(pgrep -a pmon | grep -v APX | cut -d'_' -f3- | cut -c1-10)
#    word_list_dbname=$(ps -eo args | grep pm[o]n | grep -v APX | cut -d'_' -f3- | cut -c1-8)
    [[ "${prev}" =~ "sudo" ]] && [ -z "${word_list_dbname}" ] && word_list_dbname=$(pgrep -a pmon | grep -v APX | cut -d'_' -f3- | cut -c1-8)
#    word_list_bisudo=$(grep "^[^#|^$|^ *$]" ${SCRIPT_DIR}/ora/env/init.allow 2>/dev/null | cut -d' ' -f2 | uniq)
    #word_list_scripts=$(ls -p ${SCRIPT_DIR} | grep -v '/')
    word_list_tns=$(grep '^[^ ].*=$' ${SCRIPT_DIR}/ora/wallet_infra/tnsnames.ora 2>/dev/null | cut -d= -f1)

    [ -n "${DEBUG}" ] && echo "0=$0 1=$1 cur=$cur prev=$prev ante=$ante first=$first" #array_scripts="${array_scripts[@]}""

    [[ "${prev}" =~ "oenv" ]] && COMPREPLY=( $(compgen -W "${word_list_instance}" -- $cur) ) && return
    [[ "${prev}" =~ "bisudo" ]] && COMPREPLY=( $(compgen -W "${word_list_bisudo}" -- $cur) ) && return
    [[ "${1}" == "sudo" ]] && [[ "${prev}" =~ "oracle" ]] && COMPREPLY=( $(compgen -W "${word_list_bisudo}" -- $cur) ) && return
    [[ "${1}" == "sudo" ]] && [[ "${array_scripts[@]}" =~ "${prev}" ]] && COMPREPLY=( $(compgen -W "${word_list_dbname}" -- $cur) ) && return
#    [[ "${array_scripts[@]}" =~ "${prev}" ]] && COMPREPLY=( $(compgen -W "${word_list_dbname}" -- $cur) ) && return
#    [[ "${array_scripts[@]}" =~ "${prev}" ]] && COMPREPLY=( $(compgen -W "-d" -- $cur) ) && return
#    [[ "${array_scripts[@]}" =~ "${ante}" && "${prev}" == "-d" ]] && COMPREPLY=( $(compgen -W "${word_list_dbname}"
    [[ $(grep -c -w -x "${prev//-/}" <<< "${array_scripts[@]}") == 1 ]] && COMPREPLY=( $(compgen -W "-d" -- $cur) ) && return
    [[ $(grep -c -w -x "${ante//-/}" <<< "${array_scripts[@]}") == 1 && "${prev}" == "-d" ]] && COMPREPLY=( $(compgen -W "${word_list_dbname}" -- $cur) ) && return
    [[ "${prev}" == "-db"  || "${prev}" == "-d" ]] && COMPREPLY=( $(compgen -W "${word_list_dbname}" -- $cur) ) && return
    [[ "${1}" =~ "sqlplus" ]] && [[ "${prev}" == "@" ]] && COMPREPLY=( $(compgen -W "${word_list_tns}" -- $cur) ) && return

    ## If nothing matched
    #[ ${#COMPREPLY[@]} == 0 ] && COMPREPLY=( $(compgen -W "${word_list_dbname}" -- ${cur}) ) && return
    #COMPREPLY=( $(compgen -W "${word_list}" -- ${cur}) )
}
complete -F _ora_completion oenv rlsqlplus
complete -F _ora_completion sqlplus srvctl exp expdp imp impdp
#complete -F _ora_completion ora_sql.sh ora_dgmgrl.sh ora_rman.sh ora_rman_backup.sh ora_rman_config.sh ora_status_instance.sh ora_status_backup.sh
#complete -F _ora_completion sql.sh dgmgrl.sh rman.sh rman_backup.sh rman_config.sh rman_config_to_tape.sh status_instance.sh status_backup.sh
[ -x "${SCRIPT_DIR}" ] && complete -F _ora_completion $(ls -p ${SCRIPT_DIR} | grep -v '/' | grep '.sh$')
#complete -F _ora_completion $(ls -p /oracle/exploit | grep -v '/' | grep '.sh$' ; ls -p /oracle/scripts | grep -v '/' | grep '.sh$')
#complete -D -F _ora_completion oralisthome -o bashdefault -o nospace -o default

## FG : Allow "sudo" to complete
#complete -cf sudo


_listener_completion() {
    COMPREPLY=()
    local cur="${COMP_WORDS[COMP_CWORD]}"
    word_list=$(ps -eo "cmd" | grep l[s]n | cut -d' ' -f2 | paste -sd " " -)
    COMPREPLY=( $(compgen -W "${word_list}" -- ${cur}) )
}

complete -F _listener_completion lsnrctl lsn


_example_complete()
{
    local cur_word prev_word word_list
# COMP_WORDBREAKS+==

    # COMP_WORDS is an array of words in the current command line.
    # COMP_CWORD is the index of the current word (the one the cursor is
    # in). So COMP_WORDS[COMP_CWORD] is the current word; we also record
    # the previous word here, although this specific script doesn't
    # use it yet.
    cur_word="${COMP_WORDS[COMP_CWORD]}"
    prev_word="${COMP_WORDS[COMP_CWORD-1]}"

    # Generate a list words
    word_list=`ps -ef|grep pm[o]n | cut -d_ -f3`

    # Only perform completion if the current word starts with a dash ('-'),
    # meaning that the user is trying to complete an option.
#    if [[ -n ${cur_word} ]] ; then
        # COMPREPLY is the array of possible completions, generated with
        # the compgen builtin.
        COMPREPLY=( $(compgen -W "${word_list}" -- ${cur_word}) )
#    else
#        COMPREPLY=()
#    fi
    return 0
}

# Register _example_complete to provide completion for the following commands
complete -F _example_complete oraup


## BASH TIMER
# https://github.com/jichu4n/bash-command-timer
BCT_ENABLE=1
BCT_SUCCESS_COLOR='32'
BCT_ERROR_COLOR='91'
#BCT_TIME_FORMAT='%b %d %I:%M%p'
BCT_TIME_FORMAT='%a %b %d %H:%M:%S'
BCT_MILLIS=1
BCT_WRAP=0
# FGR : Print the clock to the LEFT or RIGHT
BCT_PRINT=LEFT

if date +'%N' | grep -qv 'N'; then
  BCTTime="date '+%s%N'"
  function BCTPrintTime {
    date --date="@$1" +"$BCT_TIME_FORMAT"
  }
elif hash gdate 2>/dev/null && gdate +'%N' | grep -qv 'N'; then
  BCTTime="gdate '+%s%N'"
  function BCTPrintTime {
    gdate --date="@$1" +"$BCT_TIME_FORMAT"
  }
elif hash perl 2>/dev/null; then
  BCTTime="perl -MTime::HiRes -e 'printf(\"%d\",Time::HiRes::time()*1000000000)'"
  function BCTPrintTime {
    date -r "$1" +"$BCT_TIME_FORMAT"
  }
else
  echo 'No compatible date, gdate or perl commands found, aborting'
  exit 1
fi

BCT_AT_PROMPT=1
function BCTPreCommand {
  local EXIT="$?"
  if [ $EXIT == 0 ]
  then
    # colour for exit without error
    BCT_COLOR=$BCT_SUCCESS_COLOR
  else
    # colour for exit with error
    BCT_COLOR=$BCT_ERROR_COLOR
  fi
  if [ -z "$BCT_AT_PROMPT" ]; then
    return
  fi
  unset BCT_AT_PROMPT
  BCT_COMMAND_START_TIME=$(eval $BCTTime)
}
trap 'BCTPreCommand' DEBUG

# Bash will automatically set COLUMNS to the current terminal width.
export COLUMNS

# Flag to prevent printing out the time upon first login.
BCT_FIRST_PROMPT=1
# This is executed before printing out the prompt.
function BCTPostCommand {
  BCT_AT_PROMPT=1

  if [ -n "$BCT_FIRST_PROMPT" ]; then
    unset BCT_FIRST_PROMPT
    return
  fi

  if [ -z "$BCT_ENABLE" ] || [ $BCT_ENABLE -ne 1 ]; then
    return
  fi

  # BCTTime prints out time in nanoseconds.
  local MSEC=1000000
  local SEC=$(($MSEC * 1000))
  local MIN=$((60 * $SEC))
  local HOUR=$((60 * $MIN))
  local DAY=$((24 * $HOUR))

  local command_start_time=$BCT_COMMAND_START_TIME
  local command_end_time=$(eval $BCTTime)
  local command_time=$(($command_end_time - $command_start_time))
  local num_days=$(($command_time / $DAY))
  local num_hours=$(($command_time % $DAY / $HOUR))
  local num_mins=$(($command_time % $HOUR / $MIN))
  local num_secs=$(($command_time % $MIN / $SEC))
  local num_msecs=$(($command_time % $SEC / $MSEC))
  local time_str=""
  if [ $num_days -gt 0 ]; then
    time_str="${time_str}${num_days}d "
  fi
  if [ $num_hours -gt 0 ]; then
    time_str="${time_str}${num_hours}h "
  fi
  if [ $num_mins -gt 0 ]; then
    time_str="${time_str}${num_mins}m "
  fi
  local num_msecs_pretty=''
  if [ -n "$BCT_MILLIS" ] && [ $BCT_MILLIS -eq 1 ]; then
    local num_msecs_pretty=$(printf '%03d' $num_msecs)
  fi
  time_str="${time_str}${num_secs}s${num_msecs_pretty}"
  now_str=$(BCTPrintTime $(($command_end_time / $SEC)))
  if [ -n "$now_str" ]; then
    local output_str="[ $time_str | $now_str ]"
  else
    local output_str="[ $time_str ]"
  fi
  if [ -n "$BCT_COLOR" ]; then
    local output_str_colored="\033[${BCT_COLOR}m${output_str}\033[0m"
  else
    local output_str_colored="${output_str}"
  fi
  # Trick to make sure the output wraps to the next line if there is not
  # enough room for the string (only when BCT_WRAP == 1)
  if [ -n "$BCT_WRAP" ] && [ $BCT_WRAP -eq 1 ]; then
    # we'll print as many spaces as characters exist in output_str, plus 2
    local wrap_space_prefix="${output_str//?/ }  "
  else
    local wrap_space_prefix=""
  fi

  # Move to the end of the line. This will NOT wrap to the next line
  # unless you have BCT_WRAP == 1
  # FGR : Print the clock to the left or right
  if [ -n "$BCT_PRINT" ] && [ $BCT_PRINT = "RIGHT" ]; then
    echo -ne "$wrap_space_prefix\033[${COLUMNS}C"
  elif [ -n "$BCT_PRINT" ] && [ $BCT_PRINT = "LEFT" ]; then
    #echo -ne "$wrap_space_prefix"
    [ -n "$BCT_WRAP" ] && [ $BCT_WRAP -eq 0 ] \
      && echo -ne "$wrap_space_prefix\033[${#output_str}C" \
      || echo -ne "$wrap_space_prefix"
  fi
  # Move back (length of output_str) columns.
  echo -ne "\033[${#output_str}D"
  # Finally, print output.
  echo -e "${output_str_colored}"
}
PROMPT_COMMAND='BCTPostCommand'
## END - BASH TIMER

## Print a clock
function prompt_command {
let prompt_x=$COLUMNS-6
PROMPT_COMMAND=prompt_command
}

function print_clock {
local       BLUE="\[\033[0;34m\]"
local        RED="\[\033[0;31m\]"
local  LIGHT_RED="\[\033[1;31m\]"
local      WHITE="\[\033[1;37m\]"
local  NO_COLOUR="\[\033[0m\]"
case $TERM in
    xterm*)
        TITLEBAR='\[\033]0;\u@\h:\w\007\]'
        ;;
    *)
        TITLEBAR=""
        ;;
esac

PS1_CURRENT=${PS1}
PS1="${TITLEBAR}\
\[\033[s\033[1;\$(echo -n \${prompt_x})H\]\
$BLUE[$LIGHT_RED\$(date +%Hh%M)$BLUE]\
\[\033[u\033[1A\]\
${PS1_CURRENT}"
#$BLUE[$LIGHT_RED\u@\h:\w$BLUE]\
#$WHITE\$$NO_COLOUR "
}
## END - Print a clock


function sudo_function {
export -f $1
su $2 -c "bash -c $1"
}


function highlight {
    declare -A fg_color_map
    fg_color_map[black]=30
    fg_color_map[red]=31
    fg_color_map[green]=32
    fg_color_map[yellow]=33
    fg_color_map[blue]=34
    fg_color_map[magenta]=35
    fg_color_map[cyan]=36

    fg_c=$(echo -e "\e[1;${fg_color_map[$1]}m")
    c_rs=$'\e[0m'
    sed -u s"/$2/$fg_c\0$c_rs/g"
}
#export -f highlight

alias listdbprmy='dbinfo | grep Open | grep $(hostname -s) | cut -d'.' -f2 | tr "[:lower:]" "[:upper:]"'
# CUT --complement
#LIST_INSTANCE=GCETSTX01,GCETSTX02,GCETSTX03
#echo $LIST_INSTANCE | cut -d',' --complement -f1




#### FG : TODO ####

### FUNCTIONS : TODO
function SQL_PROCESS {
echo $1
SQL=$(cat <<-EOF
echo -e $1
EOF
)
echo SQL=$SQL
}


function SendMail {
	STATUS=$1
	COMMENT=$2
	hostname | grep prdres && ENV=PRD
	hostname | grep intres && ENV=HPR

	MAIL_FILE=Report_Mail.msg
	MAIL_FROM=ANSIBLE_${ENV}_$(hostname -s)
	[ "${ENV}" == "HPR" ] && MAIL_TO=<my_email> || MAIL_TO=<goup_email>
	MAIL_SUBJECT="[ANSIBLE][${ENV}] Deploiement des scripts du GIT en environnement \"${ENV}\""
	#LOG_CONTENTS_FILE=$( awk 'BEGIN{print "<div>"} {print "<br>";for(i=1;i<=NF;i++)print $i;} END{print "</div>"}' < <(tail -10 ~/${LOG_FILE}) )
	#LOG_CONTENTS_FILE=$( while read line; do BLINE="<b>$(cut -d: -f1<<<${line}) :</b>"; ELINE="$(cut -d: -f2-<<<${line})";  echo "<br>${BLINE}${ELINE}"; done < <(tail -10 ~/${LOG_FILE}) )
	#LOG_CONTENTS_FILE=$( while read line; do echo "${line}"; done < <(tail -10 ~/${LOG_FILE}) )

#Content-Type: multipart/mixed; boundary="."
#awk 'BEGIN{print "<table>"} {print "<tr>";for(i=1;i<=NF;i++)print "<td>" $i"</td>";print "</tr>"} END{print "</table>"}' test >> email.html

	MAIL_CONTENTS="From: ${MAIL_FROM}
To: ${MAIL_TO}
Subject: ${MAIL_SUBJECT}
Mime-Version: 1.0
Content-Type: text/html; charset="us-ascii"

<!-- --. -->
<html><body>
<p>
<br><b>Compte rendu d'execution ${COMMENT}:</b> $(basename ${0})
<br><b>Statut :</b> ${STATUS}
<br>
<br><b>Log Git :</b> ${GIT2SYNC_DIR#${HOME}/}/${GIT2SYNC_FILE}
<pre>${GIT_OUT}</pre>
<br><b>Log Ansible :</b> ${cmd}
<pre>${ANSIBLE_OUT}</pre>
</p>
</body></html>
"

	echo "${MAIL_CONTENTS}"
	echo "${MAIL_CONTENTS}" | /usr/sbin/sendmail -t
	#/usr/sbin/sendmail -t <<< "${MAIL_CONTENTS}"

#	echo ${MAIL_CONTENTS}>${MAIL_FILE}
#	cat ${MAIL_FILE} | /usr/sbin/sendmail -t
}


## PROMPT BEFORE and AFTER a command
# https://jichu4n.com/posts/debug-trap-and-prompt_command-in-bash/
# This will run before any command is executed.
function PreCommand {
  if [ -z "$AT_PROMPT" ]; then
    return
  fi
  unset AT_PROMPT

  # Do stuff.
  echo "Running PreCommand"
}
#trap "PreCommand" DEBUG

# This will run after the execution of the previous full command line.  We don't
# want it PostCommand to execute when first starting a bash session (i.e., at
# the first prompt).
FIRST_PROMPT=1
function PostCommand {
  AT_PROMPT=1

  if [ -n "$FIRST_PROMPT" ]; then
    unset FIRST_PROMPT
    return
  fi

  # Do stuff.
  echo "Running PostCommand"
}
#PROMPT_COMMAND="PostCommand"

## Print command before execute
#trap 'echo "# $BASH_COMMAND"' DEBUG


### ALIASES : TODO
## GIT Alias : git config --global alias.<alias_name> 'command'
# Show git conf : git config --global -l
# git config --global http.sslVerify "false"
# git config --global credential.helper "store"
## Set Alias
# git config --global alias.gl 'config --global -l'
# git config --global alias.changes '!git log --name-status HEAD..@{u}'
# git config --global alias.diffpull '!git fetch && git diff HEAD..@{u}'
# git config --global alias.st 'status -sb'
# git config --global alias.ll 'log --oneline'
# git config --global alias.last 'log -1 HEAD --stat'
# git config --global alias.dv 'difftool -t vimdiff -y'
# git config --global alias.se '!git rev-list --all | xargs git grep -F'
# git config --global help.autocorrect 20


### COMMANDS : TODO
## Search in traces :
#    grep 'ns main err code: 12599' /u01/app/oracle/diag/rdbms/*/*/trace/alert*.log | sort|uniq -c|sort -n
#    grep -cH 'ns main err code: 12599' /u01/app/oracle/diag/rdbms/*/*/trace/alert*.log | grep -E '_1|_2|11|12|13' | awk -F: '{print $2" "$1}' | sort -n | awk -F/ '{ print $0" : Is Instance Running: "("ps -ef | grep pm[o]n_"$8 | getline $ps); $ps}'
# sed 's/[^"]*"\([^"]*\).*/\1/'
#s - tells sed to substitute
#/ - start of regex string to search for
#[^"]* - any character that is not ", any number of times. (matching parameter name=)
#" - just a ".
#([^"]*) - anything inside () will be saved for reference to use later. The \ are there so the brackets are not considered as characters to search for. [^"]* means the same as above. (matching RemoteHost for example)
#.* - any character, any number of times. (matching " access="readWrite"> /parameter)
#/ - end of the search regex, and start of the substitute string.
#\1 - reference to that string we found in the brackets above.
#/ end of the substitute string.


## SAR
#sar -n DEV 1 60 | grep -E 'Average:        IFACE|Average:    bondeth0.3375' | awk '{ print $1"  "$2"  "$5" "$6}' | column -t
#sar -n DEV 1 5 | grep -E 'Average:' | awk '{ print $1"  "$2"  "$5" "$6}' | sort |  column -t


## CRSCTL grouping
# List all RSS (line) 
crsctl status res |grep -v "^$"|awk -F "=" 'BEGIN {print " "} {printf("%s",NR%4 ? $2"|" : $2"\n")}'|sed -e 's/  *, /,/g' -e 's/, /,/g'|awk -F "|" 'BEGIN { printf "%-40s%-35s%-20s%-50s\n","Resource Name","Resource Type","Target ","State" }{ split ($3,trg,",") split ($4,st,",")}{for (i in trg) {printf "%-40s%-35s%-20s%-50s\n",$1,$2,trg[i],st[i]}}' | sed -r 's:.*ONLINE on (.*):\1:g'
# List RSS (group)
crsctl status res -w "TYPE = ora.service.type" |grep -v "^$"|awk -F "=" 'BEGIN {print " "} {printf("%s",NR%4 ? $2"|" : $2"\n")}'|sed -e 's/  *, /,/g' -e 's/, /,/g'|awk -F "|" 'BEGIN { printf "%-40s%-35s%-20s%-50s\n","Resource Name","Resource Type","Target ","State" }{ split ($3,trg,",") split ($4,st,",")}{for (i in trg) {printf "%-40s%-35s%-20s%-50s\n",$1,$2,trg[i],st[i]}}' \
 | sed -r 's:.*ONLINE on (.*):\1:g' | sort | uniq -c
# Count per RSS type
crsctl status res -w "TYPE = ora.service.type" -t | grep 'ONLINE  ONLINE' | sed -r 's:.*ONLINE  ONLINE(.*\w.* ).*:\1:g' | sort | uniq -c


## IS CRS Autostart Enable or Disable
root@exa01:~
# dcli -l root -g ~/dbs_group 'ls -d /etc/oracle/scls_scr/* ; cat /etc/oracle/scls_scr/*/root/ohasdstr'
exa01: /etc/oracle/scls_scr/exa01
exa01: enable
exa02: /etc/oracle/scls_scr/exa02
exa02: enable
exa03: /etc/oracle/scls_scr/exa03
exa03: enable
exa04: /etc/oracle/scls_scr/exa04
exa04: enable

#### List item per Oracle version / Architecture / Process
### Instances number
#Répartition de toutes les instances par nœud :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -c ora_pm[o]n"
#Répartition de des instances RACOne par nœud :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -Ec 'ora_pmon.*[0-9]_[1-2]{1}$'"
#Répartition de des instances RAC2/3/4 par nœud :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -Ec 'ora_pm[o]n_.*[0-9]{2}$'"
#Répartition de des instances Standalone par nœud :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -Ec 'ora_pmon.*[A-Z][0-9]{1}$'"
#Répartition de toutes les instances 19c par nœud :
## Using oralisthome
dcli -g ~/dbs_group -l root ". /opt/bpce-it/lib/fgenv -s 2>/dev/null; oralisthome | grep -Ev 'grid|ORACLE_HOME' | awk -F' ' '{ print \$3}' | awk -F'/' '{ print \$6}' | sort | uniq -c | grep '19\.'"
## Generic
dcli -g ~/dbs_group -l root "ps -efu oracle | grep ora_pm[o]n | awk '{ print \$2 }' | xargs -IvPIDv ls -l /proc/vPIDv/exe | sed 's:.*/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*:\1.\2.\3.\4.\5:' | grep '19\.' | sort | uniq -c"
#Répartition de des instances RACOne 19c par nœud :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -E 'ora_pmon.*[0-9]_[1-2]{1}$' | awk '{ print \$2 }' | xargs -IvPIDv ls -l /proc/vPIDv/exe | sed 's:.*/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*:\1.\2.\3.\4.\5:' | grep '19\.' | sort | uniq -c"
#Répartition de des instances RAC2/3/4 19c par nœud :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -E 'ora_pm[o]n_.*[0-9]{2}$' | awk '{ print \$2 }' | xargs -IvPIDv ls -l /proc/vPIDv/exe | sed 's:.*/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*:\1.\2.\3.\4.\5:' | grep '19\.' | sort | uniq -c"
#Répartition de des instances Standalone 19c par nœud :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -E 'ora_pmon.*[A-Z][0-9]{1}$' | awk '{ print \$2 }' | xargs -IvPIDv ls -l /proc/vPIDv/exe | sed 's:.*/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*:\1.\2.\3.\4.\5:' | grep '19\.' | sort | uniq -c"

### HugePages
#Répartition des HugePages de toutes les instances par nœud en GB :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -E 'ora_pm[o]n' | awk '{ print \$2 }' | xargs -IvPIDv grep -B 11 'KernelPageSize: *2048 kB' /proc/vPIDv/smaps | grep '^Size:' | awk 'BEGIN{sum=0}{sum+=\$2}END{printf(\"%.0f\n\",sum/1024/1024)}'"
#Répartition des HugePages des instances RACOne par nœud en GB :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -E 'ora_pmon.*[0-9]_[1-2]{1}$' | awk '{ print \$2 }' | xargs -IvPIDv grep -B 11 'KernelPageSize:.*2048 kB' /proc/vPIDv/smaps | grep '^Size:' | awk 'BEGIN{sum=0}{sum+=\$2}END{printf(\"%.0f\n\",sum/1024/1024)}'"
#Répartition des HugePages des instances RAC2/3/4 par nœud en GB :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -E 'ora_pm[o]n_.*[0-9]{2}$' | awk '{ print \$2 }' | xargs -IvPIDv grep -B 11 'KernelPageSize: *2048 kB' /proc/vPIDv/smaps | grep '^Size:' | awk 'BEGIN{sum=0}{sum+=\$2}END{printf(\"%.0f\n\",sum/1024/1024)}'"
#HugePages par instance (top5) en GB :
dcli -g ~/dbs_group -l root "for i in \$(ps -efu oracle | grep -E 'ora_pmon.*[A-Z][0-9]*$' | awk '{ print \$2\":\"\$NF}') ; do printf \"%-9s = \" \${i#*n_} ; grep -B11 'KernelPageSize: *2048 kB' /proc/\${i%:*}/smaps | awk '/^Size:/ {sum+=\$2}END{printf(\"%.0f\n\",sum/1024/1024)}'; done | sort -rnk3 | head -5"
#HugePages par instance pour un node (top10) en GB :
for i in $(ps -efu oracle | grep -E 'ora_pmon.*[A-Z][0-9]*$' | awk '{ print $2":"$NF}') ; do printf "%-9s = " ${i#*n_} ; grep -B11 'KernelPageSize: *2048 kB' /proc/${i%:*}/smaps | awk '/^Size:/ {sum+=$2}END{printf("%.0f\n",sum/1024/1024)}'; done | sort -nk3 | tail

## Service
. oraenv<<<crs
#Répartition par nœud des services APPLI Oracle pour les bases 19c :
for dbuname in $(crsctl status res -w " ( TYPE = ora.database.type ) && ( ORACLE_HOME coi 19.1 )" -p -attr NAME | sed -e '/^$/d' -e 's/^NAME=ora.\(.*\).db/\1 /'); do crsctl stat res ora.${dbuname}.${dbuname:0:8}_appli.svc | awk -v dbu=${dbuname} -v svc=${dbuname:0:8}_appli.svc -F= '/^STATE=/ { print dbu" "svc" "$2" "$3}'; done | awk '{ if ( $0 ~ /dbadm01/ ) { first++ } if ( $0 ~ /dbadm02/ ) { second++ } if ( $0 ~ /dbadm03/ ) { third++ } if ( $0 ~ /dbadm04/ ) { fourth++ } } END { print "mexi02dbadm01: "first "\nmexi02dbadm02: "second "\nmexi02dbadm03: "third "\nmexi02dbadm04: "fourth }'
#Etat des lieux groupé des services APPLI Oracle pour les bases 19c 
for dbuname in $(crsctl status res -w "(TYPE = ora.database.type) && (ORACLE_HOME coi 19.1)" -p -attr NAME | sed -e '/^$/d' -e 's/^NAME=ora.\(.*\).db/\1 /'); do eval "crsctl stat res ora.${dbuname}.${dbuname:0:8}_appli.svc | awk -v dbu=${dbuname} -v svc=${dbuname:0:8}_appli.svc -F= '/^STATE=/ { print dbu\" \"svc\" \"\$2\" \"\$3}'"; done | cut -d' ' -f3- | sort | uniq -c
#Etat des lieux détaillé des services APPLI Oracle pour les bases 19c :
for dbuname in $(crsctl status res -w " ( TYPE = ora.database.type ) && ( ORACLE_HOME coi 19.1 )" -p -attr NAME | sed -e '/^$/d' -e 's/^NAME=ora.\(.*\).db/\1 /'); do eval "crsctl stat res ora.${dbuname}.${dbuname:0:8}_appli.svc | awk -v dbu=${dbuname} -v svc=${dbuname:0:8}_appli.svc -F= '/^STATE=/ { print dbu\" \"svc\" \"\$2\" \"\$3}'"; done;


#### END : TODO #####