#!/bin/bash

# GENERAL
#WORKDIR="${0%/*}" # Not working when script is not executed but sourced
#if [ -z "${WORKDIR}" ]
#then
#    [ -x "${BPCEIT_PATH}" ] && WORKDIR=${BPCEIT_PATH}
#else
    [ -h "${BASH_SOURCE}" ] && echo ${BASH_SOURCE} is a link && CURRENT_DIR=$(readlink ${BASH_SOURCE}) || CURRENT_DIR=${BASH_SOURCE}
    WORKDIR=$(dirname ${CURRENT_DIR})
    [ -d "${WORKDIR}/../bin" ] && WORKDIR=$(dirname ${WORKDIR})
#fi
#EXADATA_WORKDIR=/oracle/tmp
#VIOLET_WORKDIR=/tech/FGR

BINDIR=${WORKDIR}/bin
LIBDIR=${WORKDIR}/lib
[ $(grep -c "${BINDIR}" <<< ${PATH}) -eq 0 ] && export PATH=$PATH:${BINDIR}:.
[ $(grep -c "${LIBDIR}" <<< ${LD_LIBRARY_PATH}) -eq 0 ] && export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:${LIBDIR}

## IF EXADATA
if [ $(hostname | grep "dbadm") ]
then
  PLATFORM=EXADATA
  echo "Environnement ${PLATFORM}"
  #WORKDIR=${EXADATA_WORKDIR}
  [ ! -d "/prsyslib" ] && [ $(grep -c "/oracle/scripts" <<< ${PATH}) -eq 0 ] && export PATH=$PATH:/oracle/scripts:/oracle/exploit
else
  PLATFORM=LINUX
  echo "Environnement VIOLET (Hors Exadata)"
  #WORKDIR=${VIOLET_WORKDIR}
  #export PATH=$PATH:${WORKDIR}/bin:.
  alias fgenv=". ${LIBDIR}/fgenv"
  [ ! -f /etc/profile.d/zz-fgenv.sh ] && [ $(id -u) -eq 0 ] && echo ln -s ${LIBDIR}/fgenv /etc/profile.d/zz-fgenv.sh
  export LANG=C
fi


if [ -n "${DBG}" ]
then
echo "0=$0 1=$1 2=$2"
env | grep FGR
echo "which fgenv"
which fgenv
echo "locate fgenv"
locate fgenv
echo WORKDIR=${WORKDIR}
echo BINDIR=${BINDIR}
echo LIBDIR=${LIBDIR}
sysctl net.ipv4.tcp_keepalive_time net.ipv4.tcp_keepalive_intvl net.ipv4.tcp_keepalive_probes
fi


alias ls='ls --color=auto'
alias l='ls -ail'
alias ll='ls -al'
alias lt='ls -altr'
alias grep='grep --color=auto'
alias psg="ps aux | grep -v grep | grep -i"
#alias dmesg='dmesg -H'
alias iperf3_stop='pkill -ecnf "iperf3 -sD"'
alias vim='vim -u ${LIBDIR}/.vimrc'
alias vi=vim
export VIMRUNTIME=${LIBDIR}/share/vim/vim74
alias ssh='ssh -o ServerAliveInterval=30'
alias nmon=${BINDIR}/nmon
alias nmon14g=${BINDIR}/nmon14g_x86_rhel7

# WORKAROUND DEFAULT ENV
# Default Shell Deconnection Timeout
[ -n "${TMOUT}" ] && echo -e TMOUT=${TMOUT} unsetting TMOUT; unset TMOUT


## COLOR
function display_all_colors_16()
{
for clbg in {40..47} {100..107} 49 ; do
    #Foreground
    for clfg in {30..37} {90..97} 39 ; do
        #Formatting
        for attr in 0 1 2 4 5 7 ; do
            #Print the result
            echo -en "\e[${attr};${clbg};${clfg}m ^[${attr};${clbg};${clfg}m \e[0m"
        done
        echo #Newline
    done
done
}

# PROMPT
# Noir 0;30
# Gris foncÃ© 1;30
# Bleu 0;34
# Bleu clair 1;34
# Vert 0;32
# Vert clair 1;32
# Cyan 0;36
# Cyan clair 1;36
# Rouge 0;31
# Rouge clair 1;31
# Violet 0;35
# Violet clair 1;35
# Brun 0;33
# Jaune 1;33
# Gris clair 0;37
# Blanc 1;37

#case ${USER} in
#    root)
#        export PS1='\[\033[01;31m\]\u\[\033[00m\]@\[\033[01;34m\]\h\[\033[00m\]:\[\033[01;37m\]\w\[\033[00m\] \n\[\033[1;31m\]$ORACLE_SID\[\033[00m\][$(date "+%a %m/%d %H:%M:%S")]\$ '
#        ;;
#    oracle)
#        export PS1='\[\033[01;32m\]\u\[\033[00m\]@\[\033[01;34m\]\h\[\033[00m\]:\[\033[01;37m\]\w\[\033[00m\] \n\[\033[1;31m\]$ORACLE_SID\[\033[00m\][$(date "+%a %m/%d %H:%M:%S")]\$ '
#        ;;
#esac

#export PS1='\[\e[1;31m\]\u\[\e[0;0m\]@\[\e[1;34m\]\h\[\e[0;0m\]:\w\$ '

#[ -z "$ORACLE_HOME" ] && unset ORAVER || ORAVER=${ORACLE_HOME##*/product/}; ORAVER=${ORAVER%/*}
#ORAVER=$(ORAVER=${ORACLE_HOME##*/product/}; ORAVER=${ORAVER%/*}; echo $ORAVER)

## HighLight Color
case $(hostname | grep -ic 'XE') in
    0)  echo "Env : HPR"
        HL_COLOR=
        HL_COLOR2=
        ;;
    1)  echo "Env : PRD"
        HL_COLOR=';41'
        HL_COLOR2=';47'
        ;;
esac

## Screen
[ "${TERM}" = "screen" ] && SCREEN_FLAG=" screen:${STY#*.}" || unset SCREEN_FLAG
## Software Collection
[ -n "${X_SCLS}" ] && SCL_FLAG=" scl:${X_SCLS}" || unset SCL_FLAG
## Oracle Version
[ -n "${EXADATA_ENV}" ] && ORA_VERSION='$(ORAVER=${ORACLE_HOME##*/product/};ORAVER=${ORAVER%/*};echo "$ORAVER")' && GRID_VERSION='$(ORAVER=${ORACLE_HOME##*/u01/app/};echo "$ORAVER")'
[ -z "${EXADATA_ENV}" ] && ORA_VERSION='$(ORAVER=${ORACLE_HOME##*/tech/oracle/dbhome/};echo "$ORAVER")' && GRID_VERSION='$(ORAVER=${ORACLE_HOME##*/tech/oracle/grid/};echo "$ORAVER")'

case ${USER} in
    root)
        #export PS1='\e[1;31m\u\e[0m@\e[1;31m\h\e[0m:\e[1;37m\w\e[0m \e[1;31m$ORACLE_SID $SCREEN_FLAG\e[0m\n[$(date "+%a %m/%d %H:%M:%S")]\e[1;31m\$\e[0m\[ '
        export PS1='\[\e[1;31${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;31${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${ORACLE_SID} \[\e[1;33m\]$(eval echo ${ORA_VERSION})\[\e[0m\]\[\e[1;36m\]${SCREEN_FLAG}${SCL_FLAG}\[\e[0m\]\n[$(date "+%a %m/%d %H:%M:%S")]\[\e[1;31m\]\$\[\e[0m\] '
        ;;
    oracle)
        export PS1='\[\e[1;32${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${ORACLE_SID} \[\e[1;33m\]$(eval echo ${ORA_VERSION})\[\e[0m\]\[\e[1;36m\]${SCREEN_FLAG}${SCL_FLAG}\[\e[0m\]\n[$(date "+%a %m/%d %H:%M:%S")]\[\e[1;32m\]\$\[\e[0m\] '
        ;;
    grid)
        export PS1='\[\e[1;33${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${ORACLE_SID} \[\e[1;33m\]$(eval echo ${GRID_VERSION})\[\e[0m\]\[\e[1;36m\]${SCREEN_FLAG}${SCL_FLAG}\[\e[0m\]\n[$(date "+%a %m/%d %H:%M:%S")]\[\e[1;32m\]\$\[\e[0m\] '
        ;;
    postgres)
        export PS1='\[\e[1;33${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${PGS_INSTANCE} \[\e[1;33m\]${PGS_VERSION}\[\e[0m\]\[\e[1;36m\]${SCREEN_FLAG}${SCL_FLAG}\[\e[0m\]\n[$(date "+%a %m/%d %H:%M:%S")]\[\e[1;32m\]\$\[\e[0m\] ' 
        ;;
    admb*)
        export PS1='\[\e[1;36${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${ORACLE_SID} \[\e[1;33m\]$(eval echo ${ORA_VERSION})\[\e[0m\]\[\e[1;36m\]${SCREEN_FLAG}${SCL_FLAG}\[\e[0m\]\n[$(date "+%a %m/%d %H:%M:%S")]\[\e[1;32m\]\$\[\e[0m\] '
        ;;
    *)
        export PS1='\[\e[1;35${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w \[\e[1;36m\]${SCREEN_FLAG}${SCL_FLAG}\[\e[0m\]\n[$(date "+%a %m/%d %H:%M:%S")]\[\e[1;32m\]\$\[\e[0m\] '
        ;;
esac


# ORACLE
if [ "${LOGNAME}" == "oracle" -o "${LOGNAME}" == "grid" ]
then
    #.oracle_profile
    #export PS1='\[\033[01;32m\]\u\[\033[00m\]@\[\033[01;34m\]\h\[\033[00m\]:\[\033[01;37m\]\w\[\033[00m\] \n\[\033[1;31m\]$ORACLE_SID\[\033[00m\][$(date "+%a %m/%d %H:%M:%S")]\$ '
    #export NLS_LANG=AMERICAN_AMERICA.WE8MSWIN1252
    export NLS_LANG=AMERICAN_AMERICA.US7ASCII
    export NLS_DATE_FORMAT='DD-MON-YY HH24:MI:SS';
    ## FG : Windows=SQLPATH + @ login OR Unix=ORACLE_PATH (Doc ID 2241021.1)
    #export SQLPATH=/oracle/exploit/sql
    #export ORACLE_PATH=/oracle/exploit/sql
    export ORACLE_PATH=${WORKDIR}/sql
    # FG : alias cdoh='cd \${ORACLE_HOME}' # -bash: cd: ${ORACLE_HOME}: No such file or directory
    alias cdoh='cd ${ORACLE_HOME}'
    alias lslsn='ps -ef | grep l[s]n'

    IS_RLWRAP_IN_PATH=$(which --skip-alias rlwrap >/dev/null 2>&1; echo $?)
    IS_RLWRAP_IN_WORKDIR=$(test -x ${BINDIR}/rlwrap; echo $?)
    [ ${IS_RLWRAP_IN_PATH} == 0 ] && RLWRAP_BIN=rlwrap || echo "rlwrap binary not present or not executable : ${BINDIR}/rlwrap"
    [ ${IS_RLWRAP_IN_WORKDIR} == 0 ] && RLWRAP_BIN=${BINDIR}/rlwrap && [ -d ${LIBDIR}/.rlwrap ] && RLWRAP_DIR=${LIBDIR}/.rlwrap
    #[ -z "${RLWRAP_BIN}" ] && RLWRAP_BIN=$(locate -be '\rlwrap')
    #[ -z "${RLWRAP_DIR}" ] && RLWRAP_DIR=$(locate -be '\.rlwrap')
    IS_RLWRAP_PREREQ_OK=$(${RLWRAP_BIN} -v >/dev/null 2>&1; echo $?)
    if [ -n "${RLWRAP_BIN}" -a -n "${RLWRAP_DIR}" -a ${IS_RLWRAP_PREREQ_OK} -eq 0 ]
    then
      alias rlwrap=${RLWRAP_BIN}
      alias rlsqlplus='rlwrap -f ${RLWRAP_DIR}/sqlplus_completions sqlplus'
      alias rlrman='rlwrap -f ${RLWRAP_DIR}/rman_completions rman'
      alias rldgmgrl='rlwrap -f ${RLWRAP_DIR}/dgmgrl_completions dgmgrl'
      alias rlasmcmd='rlwrap -f ${RLWRAP_DIR}/asmcmd_completions asmcmd'
      alias rladrci='rlwrap -f ${RLWRAP_DIR}/adrci_completions adrci'
      alias rllsn='rlwrap -f ${RLWRAP_DIR}/lsnrctl_completions lsnrctl'
      alias rlsql='rlwrap -f ${RLWRAP_DIR}/sqlplus_completions sqlplus / as sysdba @ login_noauto'
      alias sql='rlsql'
      alias rmn='rlrman target /'
      alias dgb='rldgmgrl /'
      alias asm='rlasmcmd'
      alias adr='rladrci'
      alias lsn='rllsn'
    else
      alias sql='sqlplus / as sysdba @ login_noauto'
    fi
fi

alias setoh='. ${LIBDIR}/setoh.sh'
alias env11='. ${LIBDIR}/env11.sh'
alias env12='. ${LIBDIR}/env12.sh'

## COMMON
alias fgdbg='bash -xc '\''echo "0:$0 ; 0-modded:${0#bash} ; 1:$1"'\'''
alias netbreakdown="netstat -nat | awk '{print $6}' | sort | uniq -c | sort -n"

## SCREEN
# To avoid error : screen Cannot open your terminal '/dev/pts/0' - please check.
#script /dev/null => bash -c '\''script /dev/null -q -c

alias screen='screen -h 50000'
alias sc='screen -h 50000'
alias scls='screen -ls'
alias scr='screen -r'
alias scs='screen -S'
# Command SCRIPT is used as a workaround when not connected as root : "Cannot open your terminal '/dev/pts/0' - please check."
alias scr='bash -c '\''script /dev/null -q -c "screen -r ${0#bash}"'\'''
alias scrd='bash -c '\''script /dev/null -q -c "screen -rd ${0#bash}"'\'''
alias scx='bash -c '\''script /dev/null -q -c "screen -x ${0#bash}"'\'''
alias scrx='bash -c '\''script /dev/null -q -c "screen -rx ${0#bash}"'\'''
alias scs='bash -c '\''script /dev/null -q -c "screen -h 50000 -S ${0#bash}"'\'''

export SCREENRC=${LIBDIR}/.screenrc
# .screenrc
# Enable mouse scroll
#termcapinfo xterm* ti@:te@

# Keep scrollback n lines
#defscrollback 50000

# Enable screen caption
#hardstatus on
#hardstatus alwayslastline

# Forward $STY to screen session after a SUDO
#screen
#screen $SHELL -c 'screen -X caption always "$STY"'
#caption always "%{= kc}Screen session on %H (system load: %l) %-28=%{= .m} %Y-%m-%d %0c"
#caption always "%{= kc}Screen session on %H (system load: %l) %-28=%{= .m} %D %d-%m-%Y %0c"


# FUNCTION

function oralisthome () {
printf "%6s %-20s %-80s\n" "PID" "NAME" "ORACLE_HOME"
pgrep -af _pmon_ |
  while read pid pname  y ; do
    printf "%6s %-20s %-80s\n" $pid $pname `ls -l /proc/$pid/exe | awk -F'>' '{ print $2 }' | sed 's/bin\/oracle$//' | sort | uniq`
  done
}

function oralistcnx () {
ps -eo "args" | grep LOCAL=NO | sort | uniq -c
}

function lsnGetservice () {
LSN_NAME_LIST=$(ps -eo args | grep -w tnsl[s]nr | sed 's/.*lsnr \(.*\) -no.*/\1/')
for LSN_NAME in ${LSN_NAME_LIST}; do
    cmd="lsnrctl status ${LSN_NAME} | grep -m 3 ${1}.*_APPLI"
    host_port=$(lsnrctl status ${LSN_NAME} | grep PORT | sed 's/.*\(.*HOST=.*\)\(PORT=.*\)/Host=\1 Port=\2/')
    echo "${LSN_NAME} :"
    echo ${cmd}
    eval ${cmd}
    #eval ${cmd} | highlight cyan 'lsnrctl status'
done
}


#du -sk ./* | /usr/bin/sort -n | /usr/bin/awk 'BEGIN{ pref[1]="K"; pref[2]="M"; pref[3]="G";} { total = total + $1; x = $1; y = 1; while( x > 1024 ) { x = (x + 1023)/1024; y++; } printf("%g%s\t%s\n",int(x*10)/10,pref[y],$2); } END { y = 1; while( total > 1024 ) { total = (total + 1023)/1024; y++; } printf("Total: %g%s\n",int(total*10)/10,pref[y]); }'
#du -sk * | awk '{ total = total + $1 } END { print total }'
#lsÂ -lÂ |Â awkÂ '{sum += $5} END {print sum}'

function dufg {
ARG1=${1:-*}
du -sk ./${ARG1} | /usr/bin/sort -n | /usr/bin/awk 'BEGIN{ pref[1]="K"; pref[2]="M"; pref[3]="G";} { total = total + $1; x = $1; y = 1; while( x > 1024 ) { x = (x + 1023)/1024; y++; } printf("%g%s\t%s\n",int(x*10)/10,pref[y],$2); } END { y = 1; while( total > 1024 ) { total = (total + 1023)/1024; y++; } printf("Total: %g%s\n",int(total*10)/10,pref[y]); }'
}


function ts_old {
du -sk * | sort -n | awk '
     BEGIN {
        split("KB,MB,GB,TB,PB,EB,ZB,YB", Units, ",");
     }
     {
        u = 1;
        while ($1 >= 1024) {
           $1 = $1 / 1024;
           u += 1
        }
        $1 = sprintf("%.1f %s", $1, Units[u]);
        print $0;
     }
    '
}


function ts () {
[ -n "$1" ] && filter="$*" || filter="*"
du -sk ${filter} | sort -n | awk '
    BEGIN {
      split("KB,MB,GB,TB,PB,EB,ZB,YB", Units, ",");
    }
    {
      total = total + $1
      u = 1;
      while ($1 >= 1024) {
        $1 = $1 / 1024;
        u += 1
      }
      $1 = sprintf("%.1f %s", $1, Units[u]);
      #$3 = system("bash -c '\''stat -c %y "$2"'\''");
      #fdate = system("stat -c %y " $2);
      fdate_cmd="stat -c %y "$2" | cut -d. -f1"
      if (Units[u] != "KB") {fdate_cmd | getline fdate; close(fdate_cmd);} #else {fdate=""}
      #print $0
      #print $1" "fdate"   "$2
      print $0"   "fdate
      #printf("%.1f %s %s %s\n", $1, Units[u], fdate, $2);
    }
    END {
      u = 1;
      while (total >= 1024) {
        total = total / 1024;
        u += 1
      }
      printf("\n%.1f %s Total\n", total, Units[u]);
    }
'
}


alias nbfilebyday="stat -c "%y" * |cut -d' ' -f1|sort|uniq -c"
alias nbhfilebyday="stat -c "%y" * .*|cut -d' ' -f1|sort|uniq -c|tr -d "-""
function sizebyDay () { ls -l --time-style=long-iso * | awk '{sum[$6] += $5/1048576;} END { for (date in sum) {printf "%s MB %d\n", date, sum[date];} }' | sort -k1 | column -t ; }
function sizebyDay2 () { ls -l --time-style=long-iso * | WHINY_USERS=-9 awk 'END { for (date in sum) printf "%s\t MB %-15d\n", date, sum[date];} { sum[$6] += $5/1048576;}' ; }

## Only files, from current directory only, sorted by date and summed
function sizebyDayf () { find ./ -maxdepth 1 -type f -printf '%TY-%Tm-%Td %s\n' | awk '{sum[$1] += $2/1048576;} END { for (date in sum){printf "%-15s MB %d\n", date, sum[date];} }' | sort ; }

## Only files, recursively, sorted by date and summed
function sizebyDayfr () { find ./ -type f -printf '%TY-%Tm-%Td %s\n' | awk '{sum[$1] += $2/1048576; total += $2/1048576} END { for (date in sum){printf "%-15s MB %d\n", date, sum[date];} printf "Total MB %d\n", total; }' | sort ; }
function sizebyMonthfr () { find ./ -type f -printf '%TY-%Tm %s\n' | awk '{sum[$1] += $2/1048576; total += $2/1048576} END { for (date in sum){printf "%-15s MB %d\n", date, sum[date];} printf "Total MB %d\n", total; }' | sort ; }

#time find -type f -ctime +90 | xargs -ifile du file | cut -d'/' -f1,2 | awk '{sum[$2] += $1/1024; total += $1/1048576} END { for (dir in sum){printf "%-30s MB %d\n", dir, sum[dir];} printf "Total MB %d\n", total; }' | sort -nk3

adGetuserInfo () {
    [ -z "$1" ] && echo Arg 1 is Required && return 1
    [ -n "$2" ] && GREP_GROUP="| grep -i $2"
    getent passwd $1
    eval "getent group | grep -i $1 | cut -d: -f1 ${GREP_GROUP}"
}

adGetgroupInfo () {
    [ -z "$1" ] && echo Arg 1 is Required && return 1
    for aduser in $(getent group $1 | cut -d: -f4 | sed "s/,/\n/g" | sort)
    do
        [ -z "$2" ] && getent passwd $aduser | cut -d: -f1,5
        [ "$2" == "-v" ] && adGetuserInfo $aduser $3
    done
}


pathmunge () {
## Add to PATH if not exists (default before or specify after)
    if ! echo $PATH | /bin/egrep -q "(^|:)$1($|:)" ; then
        if [ "$2" = "after" ] ; then
            PATH=$PATH:$1
        else
            PATH=$1:$PATH
        fi
    fi
}

pathremove () {
    PATH=:$PATH:
    PATH=${PATH//:$1:/:}
    PATH=${PATH#:}; PATH=${PATH%:}
}



#### FG : TODO ####
## sed 's/[^"]*"\([^"]*\).*/\1/'
#s - tells sed to substitute
#/ - start of regex string to search for
#[^"]* - any character that is not ", any number of times. (matching parameter name=)
#" - just a ".
#([^"]*) - anything inside () will be saved for reference to use later. The \ are there so the brackets are not considered as characters to search for. [^"]* means the same as above. (matching RemoteHost for example)
#.* - any character, any number of times. (matching " access="readWrite"> /parameter)
#/ - end of the search regex, and start of the substitute string.
#\1 - reference to that string we found in the brackets above.
#/ end of the substitute string.

function highlight() {
    declare -A fg_color_map
    fg_color_map[black]=30
    fg_color_map[red]=31
    fg_color_map[green]=32
    fg_color_map[yellow]=33
    fg_color_map[blue]=34
    fg_color_map[magenta]=35
    fg_color_map[cyan]=36

    fg_c=$(echo -e "\e[1;${fg_color_map[$1]}m")
    c_rs=$'\e[0m'
    sed -u s"/$2/$fg_c\0$c_rs/g"
}
#export -f highlight

alias listdbprmy='dbinfo | grep Open | grep $(hostname -s) | cut -d'.' -f2 | tr "[:lower:]" "[:upper:]"'
# CUT --complement
#LIST_INSTANCE=GCETSTX01,GCETSTX02,GCETSTX03
#echo $LIST_INSTANCE | cut -d',' --complement -f1


# BASH COMPLETION
# .inputrc
bind 'set completion-query-items 300'
#bind 'set print-completions-horizontally off'
#set rl_completion_query_items 1000

#bind 'set mark-directories on'
#bind 'set mark-symlinked-directories on'
#bind 'set page-completions off'
#bind 'set show-all-if-ambiguous on'
#bind 'set visible-stats on'

#alias oenv='bash -xc '\''script /dev/null -q -c "export ORAENV_ASK=NO;  export ORACLE_SID=$0; source /usr/local/bin/oraenv; echo ${ORACLE_SID}:${ORACLE_HOME}"'\'''
#alias oenv='script /dev/null -q -c "echo export ORAENV_ASK=NO;  export ORACLE_SID=$0; source /usr/local/bin/oraenv; echo ${ORACLE_SID}:${ORACLE_HOME}"'
#alias oenv='eval export ORACLE_SID='
#alias oenv='bash -xc 'export ORACLE_SID=$0'''
#alias oenv='echo export ORACLE_SID=$1'

oenv()
{
export ORAENV_ASK=NO
export ORACLE_SID=$1
. oraenv >/dev/null
echo ${ORACLE_SID}:${ORACLE_HOME}
}
export -f oenv

_oraenv_completion() {
    COMPREPLY=()
    [[ -f /etc/oratab ]] || return 0

    local cur="${COMP_WORDS[COMP_CWORD]}"
    #word_list=$(cat /etc/oratab | cut -d':' -f1 | grep -v '#')
    #word_list=$(crsctl status resource -w "TYPE = ora.database.type" -p|grep USR_ORA_INST_NAME|sed "s:.*=::"|sort -u)
    #word_list=$(grep -v -e "^#\|^ \|^$" /etc/oratab | cut -f1 -d: | paste -sd " " -)
    word_list=$(grep -v -e "^#\|^ \|^$" /etc/oratab | cut -f1 -d: | grep "$(ps -eo args | grep pm[o]n | cut -d'_' -f3 | cut -c1-8)" | paste -sd " " -)
    COMPREPLY=( $(compgen -W "${word_list}" -- ${cur}) )
}

complete -F _oraenv_completion oenv srvctl
complete -F _oraenv_completion sql.sh dgmgrl.sh rman.sh rman_backup.sh rman_config.sh rman_config_to_tape.sh status_instance.sh status_backup.sh
complete -F _oraenv_completion ora_sql.sh ora_dgmgrl.sh ora_rman.sh ora_rman_backup.sh ora_rman_config.sh ora_status_instance.sh ora_status_backup.sh

## FG : Allow "sudo" to complete
#complete -cf sudo

_listener_completion() {
    COMPREPLY=()
    local cur="${COMP_WORDS[COMP_CWORD]}"
    word_list=$(ps -eo "cmd" | grep l[s]n | cut -d' ' -f2 | paste -sd " " -)
    COMPREPLY=( $(compgen -W "${word_list}" -- ${cur}) )
}

complete -F _listener_completion lsnrctl lsn


_example_complete()
{
    local cur_word prev_word word_list
# COMP_WORDBREAKS+==

    # COMP_WORDS is an array of words in the current command line.
    # COMP_CWORD is the index of the current word (the one the cursor is
    # in). So COMP_WORDS[COMP_CWORD] is the current word; we also record
    # the previous word here, although this specific script doesn't
    # use it yet.
    cur_word="${COMP_WORDS[COMP_CWORD]}"
    prev_word="${COMP_WORDS[COMP_CWORD-1]}"

    # Generate a list words
    word_list=`ps -ef|grep pm[o]n | cut -d_ -f3`

    # Only perform completion if the current word starts with a dash ('-'),
    # meaning that the user is trying to complete an option.
#    if [[ -n ${cur_word} ]] ; then
        # COMPREPLY is the array of possible completions, generated with
        # the compgen builtin.
        COMPREPLY=( $(compgen -W "${word_list}" -- ${cur_word}) )
#    else
#        COMPREPLY=()
#    fi
    return 0
}

# Register _example_complete to provide completion for the following commands
complete -F _example_complete oraup

