#!/bin/bash
#
# fgenv
#
# ------------------------------------------------------------------------------
# Author          : Frederic GROUSSELLE
# Initial version : 2016-Jan
# Script Name     : fgenv
# Usage           : fgenv [-s]
# Description     : Load a Shell environment with specific prompt and functions
#                 : Allow the use of scripts collection under ./bin ./lib ./sql
#                 : Environment; Aliases, Functions for System and Oracle
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
#    GENERAL DEFINITION AND VARIABLES
# ------------------------------------------------------------------------------

## WORKAROUND TO DEFAULT ENV
# Unset the Default Shell disconnection Timeout
[ -n "${TMOUT}" ] && echo -e TMOUT=${TMOUT} unsetting TMOUT; unset TMOUT || { echo "TMOUT is ReadOnly: executing 'exec env TMOUT=0 bash'"; exec env TMOUT=0 bash; }


## Execution mode of "fgenv"
# Silent Mode : No output except is Debug is set "${DBG}"
[ "${1}" == "-s" ] && SILENT=TRUE || unset SILENT
# Reload Mode : Force the reload of some variable (eg. word_list)
[ "${1}" == "-r" ] && RELOAD=TRUE || unset RELOAD


#### Miscellaneous
#TIMEFORMAT="Time Elapsed : %3Rs"


### History control
#HISTFILE
#HISTSIZE=10000
#HISTFILESIZE=20000


### KSH Portability
# teach ksh 93 about local
case "$KSH_VERSION" in *' 93'*) alias local='typeset -x' ;; esac


### BASH Portability
# FG : teach BASH to set variable after pipe "|"
# set +m;shopt -s lastpipe, echo toto titi | read VAR1 VAR2


## Set the Working Directory
#WORKDIR="${0%/*}" # Not working when script is not executed but sourced
#if [ -z "${WORKDIR}" ] ; then [ -x "${BI_PATH}" ] && WORKDIR=${BI_PATH}
#else
  [ -h "${BASH_SOURCE}" ] && echo ${BASH_SOURCE} is a link && SOURCED_FILE_PATH=$(readlink ${BASH_SOURCE}) || SOURCED_FILE_PATH=${BASH_SOURCE}
  WORKDIR=$(dirname ${SOURCED_FILE_PATH})
  [ -d "${WORKDIR}/../bin" ] && WORKDIR=$(dirname ${WORKDIR})
  [ -z "${BI_PATH}" ] && BI_PATH=${WORKDIR}
#fi


## Set Environment Path for scripts collection
BINDIR=${WORKDIR}/bin
EXADIR=${WORKDIR}/exadata
ZRADIR=${WORKDIR}/zdlra
APPLIANCEDIR=${WORKDIR}/appliance
LIBDIR=${WORKDIR}/lib
[ $(grep -c "${BINDIR}" <<< ${PATH}) -eq 0 ] && export PATH=$PATH:${BINDIR}
[ $(grep -c "${EXADIR}" <<< ${PATH}) -eq 0 ] && export PATH=$PATH:${EXADIR}
[ $(grep -c "${ZRADIR}" <<< ${PATH}) -eq 0 ] && export PATH=$PATH:${ZRADIR}
[ $(grep -c "${APPLIANCEDIR}" <<< ${PATH}) -eq 0 ] && export PATH=$PATH:${APPLIANCEDIR}
[ $(grep -cE ':?\.:?' <<< ${PATH}) -eq 0 ] && export PATH=$PATH:.
[ $(grep -c "${LIBDIR}" <<< ${LD_LIBRARY_PATH}) -eq 0 ] && export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:${LIBDIR}
[ $(grep -c "${WORKDIR}" <<< ${MANPATH}) -eq 0 ] && export MANPATH="$(manpath -g):${WORKDIR}/usr/share/man"


## Set the BI Toolkit Path
# FGR : Managed by prsyslib.sh #[ ! -d "/prsyslib" ] && [ $(grep -c "/oracle/scripts" <<< ${PATH}) -eq 0 ] && export PATH=$PATH:/oracle/scripts:/oracle/exploit
# FGR : SCRIPT_DIR is from /etc/profile.d/prsyslib.sh (previously from bienv.sh)
#SCRIPT_DIR=${TOOLKIT_BIN:-/oracle/exploit}
#[ -x /prsyslib/toolunix/bin ] && SCRIPT_DIR=/prsyslib/toolunix/bin
#[ -x /oracle/exploit ] && SCRIPT_DIR=/oracle/exploit
#[ -z "${SCRIPT_DIR}" ] && SCRIPT_DIR=${TOOLKIT_BIN:-$(dirname $(which --skip-alias ora_functions.sh) >/dev/null 2>&1)}
## FGR 2025-01-15 : Lookup for BI Tools script directory if not previously set
[ -z "${SCRIPT_DIR}" ] && SCRIPT_DIR=${TOOLKIT_BIN:-$(eval ls -d /prsyslib/toolunix/bin/ 2>/dev/null)}
## FGR 2025-01-15 : Lookup for DBATools script directory
[ -z "${SCRIPT_DIR}" ] && SCRIPT_DIR=$(eval ls -d /{apps,srv}/dbatools/prod/script/ 2>/dev/null)
[ -z "${SCRIPT_LIST}" ] && [ -n "${SCRIPT_DIR}" ] && SCRIPT_LIST=$(cd ${SCRIPT_DIR}; eval ls -p ora_* vtom_* expl_* 2>/dev/null)


## DEBUG
if [ -n "${DBG}" ] ; then
  echo "0=$0 1=$1 2=$2"
  env | grep FGR
  echo "which fgenv" ; which fgenv
  echo "locate fgenv" ; locate fgenv
  echo WORKDIR=${WORKDIR}
  echo BINDIR=${BINDIR}
  echo LIBDIR=${LIBDIR}
  sysctl net.ipv4.tcp_keepalive_time net.ipv4.tcp_keepalive_intvl net.ipv4.tcp_keepalive_probes
fi


# ------------------------------------------------------------------------------
#    Environment Configuration
# ------------------------------------------------------------------------------

## CHECK IF IT IS AN APPLIANCE (EXADATA,ZDLRA) OR STANDARD SERVER
if [ $(hostname | grep -E "dbadm|biexa|bizra") ]; then
  PLATFORM=ORACLE_APPLIANCE
  [ $(hostname | grep "mez") ]            && WELCOME_MSG="Plateform : ZDLRA (BI)"               && PLATFORM_TYPE=ZDLRA_BI
  [ $(hostname | grep -E "mex|bfx") ]     && WELCOME_MSG="Plateform : EXADATA (BI)"             && PLATFORM_TYPE=EXA_BI
  [ $(hostname | grep "dbadm") ]          && WELCOME_MSG+=" BI Legacy (BI VIOLET)"
  [ $(hostname | grep "biexa") ]          && WELCOME_MSG="Plateform : EXADATA Converged (CNVG)" && PLATFORM_TYPE=EXA_CNVG
  [ $(hostname | grep "bizra") ]          && WELCOME_MSG="Plateform : ZDLRA Converged (CNVG)"   && PLATFORM_TYPE=ZDLRA_CNVG
  [ $(hostname | grep -E "ora[0-9]{4}") ] && WELCOME_MSG="Plateform : EXADATA (NX)"             && PLATFORM_TYPE=EXA_NX
  alias fgenv >/dev/null 2>&1 || alias fgenv=". ${LIBDIR}/fgenv"
  HN=$(hostname -s)
  HN_BASE=${HN%?}
  HN_NUM=${HN#${HN%?}}
  HN_PRIV_NAME=$(hostname -A | awk -F. '{print $1}')
  APPLIANCE_NAME=$(echo $HN_PRIV_NAME | sed -E 's:^([a-z]+[0-9]+).*:\U\1:g')
  #HOSTNAME_NUM=$(v=$(hostname -s);echo ${v: -1})
  #INSTANCE_NUM=$(v=$(hostname -s); [ $((${v: -1} % 2)) = 1 ] && echo 1 || echo 2)
else
  PLATFORM=SERVER ; PLATFORM_TYPE=LINUX
  WELCOME_MSG="Plateform : VIOLET (Hors Exadata)"
  #export PATH=$PATH:${WORKDIR}/bin:.
  alias fgenv=". ${LIBDIR}/fgenv"
  [ ! -f /etc/profile.d/zz-fgenv.sh ] && [ $(id -u) -eq 0 ] && echo ln -s ${LIBDIR}/fgenv /etc/profile.d/zz-fgenv.sh
  export LANG=C
fi


## Get Environment and WELCOME Message
case $(hostname --fqdn | cut -d'.' -f2- | tr '[:upper:]' '[:lower:]') in
  *prdres) ENV=PRD ; WELCOME_MSG+="\nEnvironment : PRD" ;;
  *intres) ENV=HPR ; WELCOME_MSG+="\nEnvironment : HPR (INT)" ;;
  *mapres) ENV=HPR : WELCOME_MSG+="\nEnvironment : HPR (MAP)" ;;
  *fr.intranet)
    case "${HN:2:1}" in
      p) ENV=PRD ; WELCOME_MSG+="\nEnvironment : PRD" ;;
      b) ENV=BCH ; WELCOME_MSG+="\nEnvironment : BENCH" ;;
      d) ENV=HPR ; WELCOME_MSG+="\nEnvironment : HPR (DEV)" ;;
    esac
  ;;
esac


# ------------------------------------------------------------------------------
#    Prompt Configuration
# ------------------------------------------------------------------------------

## COLOR CODES
CNC='[0m'                                            # Remove Color Format (No Color)
CN='[0;49;30m' ; CNB='[1;49;30m' ; CNBH='[1;49;40m'  # Black  0;30  # Dark Grey   1;30
CR='[0;49;31m' ; CRB='[1;49;31m' ; CRBH='[1;49;41m'  # Red    0;31  # Bold Red    1;31
CG='[0;49;32m' ; CGB='[1;49;32m' ; CGBH='[1;49;42m'  # Green  0;32  # Bold Green  1;32
CY='[0;49;33m' ; CYB='[1;49;33m' ; CYBH='[1;49;43m'  # Yellow 0;33  # Bold Yellow 1;33
CB='[0;49;34m' ; CBB='[1;49;34m' ; CBBH='[1;49;44m'  # Blue   0;34  # Bold Blue   1;34
CP='[0;49;35m' ; CPB='[1;49;35m' ; CPBH='[1;49;45m'  # Purple 0;35  # Bold Purple 1;35
CC='[0;49;36m' ; CCB='[1;49;36m' ; CCBH='[1;49;46m'  # Cyan   0;36  # Bold Cyan   1;36
CW='[0;49;37m' ; CWB='[1;49;37m' ; CWBH='[1;49;47m'  # White  0;37  # Bold White  1;37


## Default Prompt Colors (PS1)
USR_COLOR=${CWB}
SRV_COLOR=${CWB}
SRV_ENV_COLOR=${CWB}
SRV_NUM_COLOR=${CCB}
PATH_COLOR=${CWB}
INST_COLOR=${CGB} ; [ "$(grep -Ec '+ASM|crs' <<<${ORACLE_SID})" -ge "1" ] && INST_COLOR=${CRB}
VER_COLOR=${CYB}
SCR_FLAG_COLOR=${CCB}
TMX_FLAG_COLOR=${CGB}
SCL_FLAG_COLOR=${CPB}
SH_MARK_COLOR=${CWB}


## Prompt Configuration based on Environment
case ${ENV} in
  PRD) #HL_COLOR=';41' : HL_COLOR2=';47'
    SRV_COLOR=${CRB}
    SRV_ENV_COLOR=${CRBH}
    SRV_NUM_COLOR=${CCB}
  ;;
  BCH)
    SRV_COLOR=${CWB}
    SRV_ENV_COLOR=${CCB}
    SRV_NUM_COLOR=${CPB}
  ;;
  HPR)
    SRV_COLOR=${CCB}
    SRV_ENV_COLOR=${CYB}
    SRV_NUM_COLOR=${CWB}
  ;;
  DEV) ;;
esac


## Prompt Configuration based on USER connected
case ${USER} in
  root) USR_COLOR=${CRB}
    SRV_COLOR=${CRB}
    SH_MARK_COLOR=${CRB}
    ;;
  oracle) USR_COLOR=${CGB}
    ;;
  grid) USR_COLOR=${CYB}
    ;;
  postgres) USR_COLOR=${CYB}
    ;;
  admb*) USR_COLOR=${CPB}
    ;;
  *) USR_COLOR=${CPB}
    ;;
esac


## Hostname Multi-Colors
if [ $(grep -c 'BI' <<< ${PLATFORM_TYPE} ) -eq 1 ] ; then
  HN_COLORED=$(echo $(hostname -s) | sed -E "s:([a-z]+)([0-9]+)([a-z]+)([0-9]+)([0-9]):\x1b$SRV_COLOR\1\x1b$SRV_ENV_COLOR\2\x1b$SRV_COLOR\3\x1b$SRV_ENV_COLOR\4\x1b$SRV_NUM_COLOR\5\x1b$CNC:g;t")
elif [ $(grep -c 'CNVG' <<< ${PLATFORM_TYPE} ) -eq 1 ] ; then
  HN_COLORED=$(echo $(hostname -s) | sed -E "s:([a-z]{2})([dbp])([a-z]{3})([a-z]{5})([0-9]{3})([0-9]):\x1b$SRV_COLOR\1\x1b$SRV_ENV_COLOR\U\2\E\x1b$SRV_COLOR\3\x1b$SRV_ENV_COLOR\4\x1b$SRV_ENV_COLOR\5\x1b$SRV_NUM_COLOR\6\x1b$CNC:g;t")
elif [ $(grep -c 'NX' <<< ${PLATFORM_TYPE} ) -eq 1 ] ; then
  HN_COLORED=$(echo $(hostname -s) | sed -E "s:([a-z]{2})([dbp])([a-z]{3})([a-z]{5})([0-9]{3})([0-9]):\x1b$SRV_COLOR\1\x1b$SRV_ENV_COLOR\U\2\E\x1b$SRV_COLOR\3\x1b$SRV_ENV_COLOR\4\x1b$SRV_ENV_COLOR\5\x1b$SRV_NUM_COLOR\6\x1b$CNC:g;t")
else
  HN_COLORED=$(echo $(hostname -s) | sed -E "s:(.*):\x1b$SRV_COLOR\1:g;t")
fi


## Oracle Version
#GI_HOME=$(grep ^+ASM /etc/oratab | cut -d: -f2)  ## FGR TOFIX : 2025-01-10 : oratab is deprecated, retrieve GI_HOME from process ocssd.bin
## FGR : To speedup GI_HOME lookup : use of oratab first then search the path from the process ocssd.bin
[ -z "${GI_HOME}" ] && { GI_HOME=$(awk -F: '/^+ASM/ {print $2}' /etc/oratab); [ -n "$DBG" ] && echo "Set GI_HOME from oratab : GI_HOME=${GI_HOME}" ;}
[ -n "${GI_HOME}" -a -x "${GI_HOME}/bin/oracle" ] || { GI_HOME=$(dirname $(ps -eo args | grep [o]cssd.bin) | awk '{print substr( $1, 1, length($1)-4)}'); [ -n "$DBG" ] && echo "Set GI_HOME from process : GI_HOME=${GI_HOME}" ;}

[ "${ORACLE_HOME}" = "${GI_HOME}" ] && { OH_TYPE='(GI)' ; OH_TYPE_COLOR=${CRB} ;} || { OH_TYPE='(DB)' ; OH_TYPE_COLOR=${CCB} ;}
#[ "${PLATFORM}" == "ORACLE_APPLIANCE" ] && ORA_VERSION='$(ORAVER=${ORACLE_HOME##*/product/};ORAVER=${ORAVER%/*};echo "$ORAVER")' && GRID_VERSION='$(ORAVER=${ORACLE_HOME##*/u01/app/};ORAVER=${ORAVER%/*};echo "$ORAVER")'
#[ "${PLATFORM}" == "ORACLE_APPLIANCE" ] && ORA_VERSION='$(ORAVER=${ORACLE_HOME##*/product/};ORAVER=${ORAVER%/*};echo "$ORAVER")' && GRID_VERSION='$(ORAVER=${ORACLE_HOME##*/u01/app/};echo "$ORAVER")'
#[ "${PLATFORM}" != "ORACLE_APPLIANCE" ] && ORA_VERSION='$(ORAVER=${ORACLE_HOME##*/tech/oracle/dbhome/};echo "$ORAVER")' && GRID_VERSION='$(ORAVER=${ORACLE_HOME##*/tech/oracle/grid/};echo "$ORAVER")'
ORA_VERSION=$(echo "${ORACLE_HOME}" | sed -E "s:.*/([0-9]*)\.([0-9]*)\.([0-9]*)\.([0-9]*)\.([0-9]*).*:\1.\2.\3.\4.\5'\x1b${OH_TYPE_COLOR}${OH_TYPE}':")
## Screen flag
#[ "${TERM}" = "screen" ] && [ -z "${TMUX}" ] && SCREEN_FLAG=$(echo -e " \e[1;36mscreen:${STY#*.}\e[0m") || unset SCREEN_FLAG
[ "${TERM}" = "screen" ] && [ -z "${TMUX}" ] && SCREEN_FLAG=$(echo -e " \e${SCR_FLAG_COLOR}screen:${STY#*.}\e${CNC}") || unset SCREEN_FLAG
## Tmux flag
#[[ "${TERM}" =~ "screen" ]] && [ -n "${TMUX}" ] && TMUX_FLAG=$(echo -e " \e[1;32mtmux:${TMUX/*tmux/tmux}\e[0m") || unset TMUX_FLAG
[[ "${TERM}" =~ "screen" ]] && [ -n "${TMUX}" ] && TMUX_FLAG=$(echo -e " \e${TMX_FLAG_COLOR}tmux:${TMUX/*tmux/tmux}\e${CNC}") || unset TMUX_FLAG
## Software Collection flag
#[ -n "${X_SCLS}" ] && SCL_FLAG=$(echo -e " \e[1;35mscl:${X_SCLS}\e[0m") || unset SCL_FLAG
[ -n "${X_SCLS}" ] && SCL_FLAG=$(echo -e " \e${SCL_FLAG_COLOR}scl:${X_SCLS}\e${CNC}") || unset SCL_FLAG
## Date flag
#DATE_PS1='[$(date "+%a %m/%d %H:%M:%S")]' ## FG : Decommenter pour avoir la date dans le prompt


# ------------------------------------------------------------------------------
#    Print the Prompt PS1
# ------------------------------------------------------------------------------

## FGR : First Prompt #export PS1='\[\e[1;31m\]\u\[\e[0;0m\]@\[\e[1;34m\]\h\[\e[0;0m\]:\w\$ '
## FGR 2023-09 : Date at the bottom #export PS1="\[\e[32m\]\$(printf %s%s\ %-\$((\$(tput cols)-12))s '## ' \$(date '+%d/%m/%y %H:%M:%S'))\[\e[0m\]\n\[\e[0;96m\]\u\[\e[0m\]@\[\e[0;93m\]\h:\[\e[0m\]\[\e[0;92m\]\W\[\e[0m\]# "

# BI Legacy :
  # ROOT # HN_COLORED=$(echo $(hostname -s) | sed -E "s:([a-z]+)([0-9]+)([a-z]+)([0-9])([0-9]):\x1b$CRB\1\x1b$CWB\2\x1b$CR\3\x1b$CRB\4\x1b$CWB\5\x1b$CNC:g;t")
  # USER # HN_COLORED=$(echo $(hostname -s) | sed -E "s:([a-z]+)([0-9]+)([a-z]+)([0-9]+)([0-9]):\x1b$CCB\1\x1b$CWB\2\x1b$CC\3\x1b$CCB\4\x1b$CWB\5\x1b$CNC:g;t")
# Converged : 
  # ROOT # HN_COLORED=$(echo $(hostname -s) | sed -E "s:([a-z]{2})([dbp])([a-z]{3})([a-z]{5})([0-9]{3})([0-9]):\x1b$CWB\1\x1b$CRB\U\2\E\x1b$CWB\3\x1b$CRB\4\x1b$CCB\5\x1b$CWB\6\x1b$CNC:g;t")
  # USER # HN_COLORED=$(echo $(hostname -s) | sed -E "s:([a-z]{2})([dbp])([a-z]{3})([a-z]{5})([0-9]{3})([0-9]):\x1b$CWB\1\x1b$CRB\U\2\E\x1b$CW\3\x1b$CWB\4\x1b$CCB\5\x1b$CWB\6\x1b$CNC:g;t")
#export PS1='\e${USR_COLOR}\u\e[0m@\e${SRV_COLOR}${HN_BASE}\e${SRV_NUM_COLOR}${HN_NUM}\e[0m:\e${PATH_COLOR}m\w\e[0m \e${INST_COLOR}${ORACLE_SID} \e${VER_COLOR}$(eval echo ${ORA_VERSION})\e[0m${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\e${SH_MARK_COLOR}m\$\e[0m '
#export PS1='\e${CGB}\u\e${CNC}@${HN_COLORED}:\e${CWB}\w\e${CNC} \e${CGB}${APPLIANCE_NAME}\e${CNC}-\e${CRB}${HN_NUM}\e${CNC} \e${CRB}${ORACLE_SID} \e${CYB}$(eval echo ${ORA_VERSION})\e${CNC}${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\e${CGB}\$\e${CNC} '
#export PS1='\e${USR_COLOR}\u\e${CNC}@${HN_COLORED}:\e${PATH_COLOR}\w\e${CNC} \e${SRV_ENV_COLOR}${APPLIANCE_NAME}\e${CNC}-\e${SRV_NUM_COLOR}${HN_NUM}\e${CNC} \e${INST_COLOR}${ORACLE_SID} \e${VER_COLOR}$(eval echo ${ORA_VERSION})\e${SCR_FLAG_COLOR}${SCREEN_FLAG}${TMUX_FLAG}\e${SCR_FLAG_COLOR}${SCL_FLAG}\e${CNC}\n$(eval echo ${DATE_PS1})\e${SH_MARK_COLOR}\$\e${CNC} '
## FGR : Need the open square bracket \[ and close square bracket \] to avoid screen prompt break
export PS1='\[\e${USR_COLOR}\]\u\[\e${CNC}\]@${HN_COLORED}:\[\e${PATH_COLOR}\]\w\[\e${CNC}\] \[\e${SRV_ENV_COLOR}\]${APPLIANCE_NAME}\[\e${CNC}\]-\[\e${SRV_NUM_COLOR}\]${HN_NUM}\[\e${CNC}\] \[\e${INST_COLOR}\]${ORACLE_SID} \[\e${VER_COLOR}\]$(eval echo ${ORA_VERSION})\[\e${SCR_FLAG_COLOR}\]${SCREEN_FLAG}${TMUX_FLAG}\[\e${SCR_FLAG_COLOR}\]${SCL_FLAG}\[\e${CNC}\]\n$(eval echo ${DATE_PS1})\[\e${SH_MARK_COLOR}\]\$\[\e${CNC}\] '


case ${USER} in
  root)
    #export PS1='\[\033[01;31m\]\u\[\033[00m\]@\[\033[01;34m\]\h\[\033[00m\]:\[\033[01;37m\]\w\[\033[00m\] \n\[\033[1;31m\]$ORACLE_SID\[\033[00m\][$(date "+%a %m/%d %H:%M:%S")]\# '
    #export PS1='\e[1;31m\u\e[0m@\e[1;31m\h\e[0m:\e[1;37m\w\e[0m \e[1;31m$ORACLE_SID $SCREEN_FLAG\e[0m\n[$(date "+%a %m/%d %H:%M:%S")]\e[1;31m\$\e[0m\[ '
    #export PS1='\[\e[1;31${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;31${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${ORACLE_SID} \[\e[1;33m\]$(eval echo ${ORA_VERSION})\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;31m\]\$\[\e[0m\] '
    #export PS1='\[\e[1;${USR_COLOR}${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;${SRV_COLOR}${HL_COLOR2}m\]${HN_BASE}\[\e[0m\]\[\e[1;${SRV_NUM_COLOR}${HL_COLOR2}m\]${HN_NUM}\[\e[0m\]:\[\e[1;${PATH_COLOR}m\]\w\[\e[0m\] \[\e[1;${INST_COLOR}m\]${ORACLE_SID} \[\e[1;${VER_COLOR}m\]$(eval echo ${ORA_VERSION})\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;${SH_MARK_COLOR}m\]\$\[\e[0m\] '
    ;;
  oracle)
    #export PS1='\[\033[01;32m\]\u\[\033[00m\]@\[\033[01;34m\]\h\[\033[00m\]:\[\033[01;37m\]\w\[\033[00m\] \n\[\033[1;31m\]$ORACLE_SID\[\033[00m\][$(date "+%a %m/%d %H:%M:%S")]\$ '
    #export PS1='\[\e[1;32${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${ORACLE_SID} \[\e[1;33m\]$(eval echo ${ORA_VERSION})\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;32m\]\$\[\e[0m\] '
    #export PS1='\[\e[1;32${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]${HN_BASE}\[\e[0m\]\[\e[1;36${HL_COLOR2}m\]${HN_NUM}\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${ORACLE_SID} \[\e[1;33m\]$(eval echo ${ORA_VERSION})\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;32m\]\$\[\e[0m\] '
    #export PS1='\[\e[1;${USR_COLOR}${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;${SRV_COLOR}${HL_COLOR2}m\]${HN_BASE}\[\e[0m\]\[\e[1;${SRV_NUM_COLOR}${HL_COLOR2}m\]${HN_NUM}\[\e[0m\]:\[\e[1;${PATH_COLOR}m\]\w\[\e[0m\] \[\e[1;${INST_COLOR}m\]${ORACLE_SID} \[\e[1;${VER_COLOR}m\]$(eval echo ${ORA_VERSION})\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;${SH_MARK_COLOR}m\]\$\[\e[0m\] '
    ;;
  grid)
    #export PS1='\[\e[1;33${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${ORACLE_SID} \[\e[1;33m\]$(eval echo ${GRID_VERSION})\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;32m\]\$\[\e[0m\] '
    ;;
  postgres)
    #export PS1='\[\e[1;33${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${PGS_INSTANCE} \[\e[1;33m\]${PGS_VERSION}\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;32m\]\$\[\e[0m\] '
    ;;
  admb*)
    #export PS1='\[\e[1;36${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] \[\e[1;31m\]${ORACLE_SID} \[\e[1;33m\]$(eval echo ${ORA_VERSION})\[\e[0m\]${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;32m\]\$\[\e[0m\] '
    ;;
  *)
    #export PS1='\[\e[1;35${HL_COLOR}m\]\u\[\e[0m\]@\[\e[1;34${HL_COLOR2}m\]\h\[\e[0m\]:\[\e[1;37m\]\w\[\e[0m\] ${SCREEN_FLAG}${TMUX_FLAG}${SCL_FLAG}\n$(eval echo ${DATE_PS1})\[\e[1;32m\]\$\[\e[0m\] '
    ;;
esac


## https://www.thegeekstuff.com/2008/09/bash-shell-take-control-of-ps1-ps2-ps3-ps4-and-prompt_command/
# PS1 – Default interaction prompt : Default "\s-\v\$"
# PS2 – Continuation interactive prompt : Default '>'
#PS2="continue->"
# PS3 – Prompt used by “select” inside shell script
#PS3="Select a day (1-4): "
# PS4 – Used by “set -x” to prefix tracing output : Default '+'
export PS4='$0.$LINENO+ '


## COLOR
function display_all_colors_16 {
  for clbg in {40..47} {100..107} 49 ; do
    #Foreground
    for clfg in {30..37} {90..97} 39 ; do
      #Formatting
      for attr in 0 1 2 4 5 7 ; do
        #Print the result
        echo -en "\e[${attr};${clbg};${clfg}m ^[${attr};${clbg};${clfg}m \e[0m"
      done
    echo #Newline
    done
  done
}


## BI Specific
if [ -z "${SILENT}" ]; then
  echo -e "${WELCOME_MSG}"
  ## ANONYMIZED BI ##
fi


## Functions (Needed for below code)
function pathmunge {
## Add to PATH if not exists (default before or specify after)
  if ! echo $PATH | /bin/egrep -q "(^|:)$1($|:)" ; then
    if [ "$2" = "after" ] ; then
      PATH=$PATH:$1
    else
      PATH=$1:$PATH
    fi
  fi
}

function pathremove {
  PATH=:$PATH:
  PATH=${PATH//:$1:/:}
  PATH=${PATH#:}
  PATH=${PATH%:}
}




## ORACLE Environment
function GI_SetEnv {
## Set : GI_HOME, GI_BIN, GI_OWNER

  ## Retrieve the GI path from ocssd.bin process
  #GI_HOME=$(dirname $(ps -eo args | grep [o]cssd.bin) | awk '{print substr( $1, 1, length($1)-4)}')
  #GI_BIN=$(dirname $(ps -eo args | grep [o]cssd.bin | awk '{print $1}' ))

  ## FGR : To speedup GI_HOME lookup : use of oratab first then search the path from the process ocssd.bin
  [ -z "${GI_HOME}" ] && { GI_HOME=$(awk -F: '/^+ASM/ {print $2}' /etc/oratab); [ -n "$DBG" ] && echo "Set GI_HOME from oratab : GI_HOME=${GI_HOME}" ;}
  [ -n "${GI_HOME}" -a -x "${GI_HOME}/bin/oracle" ] || { GI_HOME=$(dirname $(ps -eo args | grep [o]cssd.bin) | awk '{print substr( $1, 1, length($1)-4)}'); [ -n "$DBG" ] && echo "Set GI_HOME from process : GI_HOME=${GI_HOME}" ;}
  GI_BIN=${GI_HOME}/bin

  ## Retrieve the GI bin owner from ${GI_HOME}/bin/oracle file
  GI_OWNER=$(find ${GI_HOME}/bin/oracle -prune -printf '%u')
  #export PATH=${PATH}:${GI_BIN}
  #[ "${LOGNAME}" == "${GI_OWNER}" ] && pathmunge ${GI_BIN} after || pathremove ${GI_BIN}

  ## Move GI binaries path if exist to the end of PATH to make sure we use the RDBMS path
  pathremove ${GI_BIN}
  pathmunge ${GI_BIN} after
}


if [ "${LOGNAME}" == "oracle" -o "${LOGNAME}" == "grid" ]
then
    GI_SetEnv
    ## FGR 2025-01-15 : Get ORACLE_BASE
    #[ -z "${ORACLE_BASE}" -a -n "${ORACLE_HOME}" ] && ORA_BASE=$(${ORACLE_HOME}/bin/orabase)
    #.oracle_profile
    #export PS1='\[\033[01;32m\]\u\[\033[00m\]@\[\033[01;34m\]\h\[\033[00m\]:\[\033[01;37m\]\w\[\033[00m\] \n\[\033[1;31m\]$ORACLE_SID\[\033[00m\][$(date "+%a %m/%d %H:%M:%S")]\$ '
    #export NLS_LANG=AMERICAN_AMERICA.WE8MSWIN1252
    export NLS_LANG=AMERICAN_AMERICA.US7ASCII
    export NLS_DATE_FORMAT='DD-MON-YY HH24:MI:SS';
    ## FG : Windows=SQLPATH + @ login OR Unix=ORACLE_PATH (Doc ID 2241021.1)
    #export SQLPATH=/oracle/exploit/sql
    #export ORACLE_PATH=/oracle/exploit/sql
    export ORACLE_PATH=${WORKDIR}/sql
    # FG : alias cdoh='cd \${ORACLE_HOME}' # -bash: cd: ${ORACLE_HOME}: No such file or directory
    alias cdoh='cd ${ORACLE_HOME}'
    alias lslsn='ps -ef | grep l[s]n'
    [ -f "${ORACLE_HOME}/suptools/oratop/oratop" ] && ORATOP_PATH=${ORACLE_HOME}/suptools/oratop || ORATOP_PATH=${BI_PATH}/bin
    alias oratop="${ORATOP_PATH}/oratop -f -r / as sysdba"
    alias alrt="echo /u01/app/oracle/diag/rdbms/$(echo ${ORACLE_SID:0:8}D* | tr '[:upper:]' '[:lower:]')/${ORACLE_SID}/trace/alert_${ORACLE_SID}.log"
    alias alrttail="tail -100f /u01/app/oracle/diag/rdbms/$(echo ${ORACLE_SID:0:8}D* | tr '[:upper:]' '[:lower:]')/${ORACLE_SID}/trace/alert_${ORACLE_SID}.log"
    alias alrtvi="view /u01/app/oracle/diag/rdbms/$(echo ${ORACLE_SID:0:8}D* | tr '[:upper:]' '[:lower:]')/${ORACLE_SID}/trace/alert_${ORACLE_SID}.log"
    IS_RLWRAP_IN_PATH=$(which --skip-alias rlwrap >/dev/null 2>&1; echo $?)
    IS_RLWRAP_IN_WORKDIR=$(test -x ${BINDIR}/rlwrap; echo $?)
    [ ${IS_RLWRAP_IN_PATH} == 0 ] && RLWRAP_BIN=rlwrap || echo "rlwrap binary not present or not executable : ${BINDIR}/rlwrap"
    [ ${IS_RLWRAP_IN_WORKDIR} == 0 ] && RLWRAP_BIN=${BINDIR}/rlwrap && [ -d ${LIBDIR}/.rlwrap ] && RLWRAP_DIR=${LIBDIR}/.rlwrap
    #[ -z "${RLWRAP_BIN}" ] && RLWRAP_BIN=$(locate -be '\rlwrap')
    #[ -z "${RLWRAP_DIR}" ] && RLWRAP_DIR=$(locate -be '\.rlwrap')
    IS_RLWRAP_PREREQ_OK=$(${RLWRAP_BIN} -v >/dev/null 2>&1; echo $?)

    if [ -n "${RLWRAP_BIN}" -a -n "${RLWRAP_DIR}" -a ${IS_RLWRAP_PREREQ_OK} -eq 0 ]
    then
      alias rlwrap="${RLWRAP_BIN} --histsize 5000"
      alias rlsqlplus='rlwrap -f ${RLWRAP_DIR}/sqlplus_completions sqlplus'
      alias rlsqlcl='SQLPATH=${ORACLE_PATH} rlwrap -f ${RLWRAP_DIR}/sqlplus_completions \sql'
      alias rlrman='rlwrap -f ${RLWRAP_DIR}/rman_completions rman'
      alias rldgmgrl='rlwrap -f ${RLWRAP_DIR}/dgmgrl_completions dgmgrl'
      alias rlasmcmd='rlwrap -f ${RLWRAP_DIR}/asmcmd_completions asmcmd -p'
      alias rlasmcmdora='ORACLE_HOME=${GI_HOME} rlwrap -f ${RLWRAP_DIR}/asmcmd_completions asmcmd -p --privilege sysdba'
      alias rladrci='rlwrap -f ${RLWRAP_DIR}/adrci_completions adrci'
      alias rllsn='rlwrap -f ${RLWRAP_DIR}/lsnrctl_completions lsnrctl'
      alias rlsql='rlwrap -f ${RLWRAP_DIR}/sqlplus_completions sqlplus / as sysdba @ login_noauto ${COLUMNS}'
      alias rlsqlc='SQLPATH=${ORACLE_PATH} rlwrap -f ${RLWRAP_DIR}/sqlplus_completions \sql / as sysdba @ login_noauto_sqlcl ${COLUMNS}'
      alias rlsqlasm='rlwrap -f ${RLWRAP_DIR}/sqlplus_completions sqlplus / as sysasm @ login_noauto ${COLUMNS}'
      alias sql='rlsql'
      #[ "${LOGNAME}" == "grid" ] && [[ "${ORACLE_SID^^}" ~= "ASM" ]] && alias sql='rlsqlasm'
      [ "${LOGNAME}" == "grid" ] && alias sql='rlsqlasm'
      alias sqlc='rlsqlc'
      alias sqlasm='rlsqlasm'
      alias rmn='rlrman target /'
      alias dgb='rldgmgrl /'
      alias asm='rlasmcmd'
      alias asmora='rlasmcmdora'
      [ "${LOGNAME}" == "oracle" ] && alias asm='rlasmcmdora'
      alias adr='rladrci'
      alias lsn='rllsn'
    else
      alias sql='sqlplus / as sysdba @ login_noauto ${COLUMNS}'
    fi
fi


## ORACLE Common Environment
alias unsetoh='unset ORACLE_HOME; unset ORACLE_SID; unset ORA_VERSION'
alias setoh='. ${LIBDIR}/setoh.sh'
alias env11='. ${LIBDIR}/env11.sh'
alias env12='. ${LIBDIR}/env12.sh'
[ -n "${ORACLE_HOME}" ] && alias opatch='${ORACLE_HOME}/OPatch/opatch'




#### FUNCTIONS (Oracle)
function loopdb {
  local DB_FILTER ORAVERFILTER VERBOSE=0 DEBUG SQL_COLLECTION HEADER DEFINED_HEADER OPEN_ONLY TIMING
  SQL_COLLECTION=${1} ; shift 1

  function Usage {
  echo "Usage : ${FUNCTNAME} [query template] [options]
  Query template :
  IS_DTG, SGA_DBF_USAGE, DBPSU
  
  Options: 
  -d    <INSTANCE_NAME>  : Filter INSTANCE_NAME or pattern (eg -d ALF)
  --ver <ORACLE_VERSION> : 11.2|12|19.4
  --open                 : Display OPEN database only
  --timing               : Execution timing
  -v                     : Verbose enable
  -vv                    : More verbosity
  -dbg                   : Debug enable 
  "
  }

  #echo args=$*
  [ -z "${SQL_COLLECTION}" ] && Usage && return 1

#  for argv in $@ ; do  ## FGR : Avec FOR le shift n'est pas pris en compte
  while [ "$#" -gt 0 ]; do
    #echo argv=$1
    case "$1" in
      -h*)  Usage ; return 1 ;;
      -d)  DB_FILTER=".*$2.*" ; if [ "$2" = "" ]; then Usage ; return 1 ; else shift 2 ; fi ;;
      --ver|-o)  ORAVERFILTER=$2 ; if [ "$2" = "" ]; then Usage ; return 1 ; else shift 2 ; fi ;;
      --open)  OPEN_ONLY=1 ; shift 1 ;;
      --timing) TIMING=1 ; shift 1 ;;
      -v)  VERBOSE=1 ; shift 1 ;;
      -vv)  VERBOSE=2 ; shift 1 ;;
      -dbg|--debug) DEBUG=YES ;  shift 1 ;;
      -*)  echo "!!! Argument $1 invalide !!!"; Usage ; return 1 ;;
      *)  echo "!!! Argument $1 invalide !!!"; Usage ; return 1 ;;
      #-exemple_1)   export EX=YES ; shift 1 ;;
      #-exemple_2*)  export EX=$2 ;  if [ "$2" = "" ]; then Usage ; else shift 2 ; fi ;;
      #-exemple_3)   EX=$2 ; [ -z "$2" ] && Usage || shift 2 ;;
      #--name=*) name="${1#*=}"; shift 1;;
    esac
  done

## Replace occurrences of $ with \$ to prevent variable substitution:
# filename="${filename//$/\\$}"
## Print dollar : HEXA or OCTAL
# echo -e '\x24' or # echo -e '\044'

  COLOR_OK='\033[30;42m'; COLOR_KO="\033[1;37;41m"; COLOR_WARN="\033[30;43m"; COLOR_CMD="\033[1;37;44m"; COLOR_STD="\033[0;0m"; COLOR_TITLE="\033[30;47m"; COLOR_RESULT="\033[30;46m"
  #alias echo='echo -e'

  SQL_PARAM="WHENEVER SQLERROR EXIT SQL.SQLCODE\nset head off feed off verify off echo off pages 0 trimout on trimspool on termout off wrap off set feed only\n"
  SQL_PARAM="WHENEVER SQLERROR EXIT SQL.SQLCODE\nset head off lines $[${COLUMNS}-${COLUMNS}/3] pages 0 trimout on\n"
  [ -n "${TIMING}" ] && SQL_PARAM+="set timing on\n"

  #column value new_val blksize
  #select value from v$parameter where name = 'db_block_size'
  #ENVSQL="${ENVSQL}"
    #ENVSQL_HEADER="CPU_COUNT"
  DB_VERSION="SELECT VERSION FROM PRODUCT_COMPONENT_VERSION WHERE PRODUCT LIKE '%Oracle Database%';"
  DBID='select dbid from v$database;'
  DBPSU11="SELECT TO_CHAR(action_time, 'YYYY-MM-DD HH24:MI:SS') AS action_time,action,version,id,comments FROM sys.dba_registry_history where comments like 'BP%' ORDER by action_time asc;"
  DBPSU12="SELECT TO_CHAR(action_time, 'YYYY-MM-DD HH24:MI:SS') AS action_time,action,status,description,version FROM sys.dba_registry_sqlpatch where description like '%PSU%' ORDER by action_time;"
  DIRECTORIES="col OWNER for a10\ncol DIRECTORY_NAME for a25\ncol DIRECTORY_PATH for a70\nselect OWNER,DIRECTORY_NAME,DIRECTORY_PATH from dba_directories where DIRECTORY_NAME like '%PUMP%';"
  HEATMAP="col owner for a10\ncol SEGMENT_NAME for a20\nSELECT owner, segment_name, segment_type, SUM(bytes/1048576) seg_size FROM dba_extents WHERE tablespace_name='SYSAUX' AND SEGMENT_NAME = 'HEATMAP' GROUP BY owner,segment_name , segment_type;"
  STARTUP_TIME="select STARTUP_TIME from v\$instance;"
  DB_ROLE="select DATABASE_ROLE from v\$database;"
  DB_OPEN_MODE="select OPEN_MODE from v\$database;"
  INSTANCE_STATUS="select STATUS from v\$instance;"
  IS_DTG="show parameter dg_broker_start"
  IS_RAC="select VALUE from v\$parameter where upper(NAME) = 'CLUSTER_DATABASE_INSTANCES';"
  IS_RAC="select count(*) NBR_INSTANCES from gv\$instance;"
  IS_RAC="select count(*) FROM v\$active_instances;"
  RAC_TYPE="select DECODE(INSTR(instance_name,'_'),0,'RAC','RACONE') RAC_TYPE from v\$instance;"
    RAC_TYPE_HEADER="RAC_TYPE CLUSTER_DATABASE_INSTANCES COUNT_GV\$INSTANCE"
  NB_INST="select count(*) from gv\$instance;"
  NB_THREAD="select count(distinct(THREAD#)) NB_THREAD from v\$log;"
  DIFF_INST_THREAD="select (select DECODE(count(*),1,2,count(*)) FROM v\$active_instances) - (select nvl(count(distinct(THREAD#)),0) from v\$standby_log) DIFF_INST_THREAD from dual;"
  CDI="select VALUE from v\$parameter where upper(NAME) = 'CLUSTER_DATABASE_INSTANCES';"
  FORCE_LOGGING="select FORCE_LOGGING from v\$database;"
  FIX_CONTROL_CHECK="show parameter _fix_control"
  LAST_LOGIN="select to_char(max(LAST_LOGIN),'dd/mm/yyyy') from dba_users where username not in ('ANONYMOUS','APEX_030200','APEX_PUBLIC_USER','APPQOSSYS','BI','CTXSYS','DBSNMP','DIP','EXFSYS','FLOWS_FILES','HR','IX','MDDATA','DMSYS','MDSYS','MGMT_VIEW','OE','OLAPSYS','ORACLE_OCM','ORDDATA','ORDPLUGINS','ORDSYS','OUTLN','OWBSYS','OWBSYS_AUDIT','PM','TSMSYS','SCOTT','SH','SI_INFORMTN_SCHEMA','SPATIAL_CSW_ADMIN_USR','SPATIAL_WFS_ADMIN_USR','SYS','SYSMAN','SYSTEM','WMSYS','XDB','XS$NULL','SYSBACKUP','SYSKM','SYSDG','AUDSYS','GSMCATUSER','GSMUSER','GSMADMIN_INTERNAL','PERFSTAT','OJVMSYS');"
  DB_SIZE="select sum(bytes)/1048576 as MB, round(sum(bytes)/1048576/1024,1) as GB from dba_data_files;"
    DB_SIZE_HEADER="MB   GB"
  DBF_SIZE="select round(sum(df.bytes/1073741824),0) as DBF_GB from v\$datafile df, v\$tablespace ts where df.ts#=ts.ts# and ts.NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS');"
  SGA_DBF_USAGE="COLUMN SGA_USAGE FORMAT A40
  SELECT
  'SGA_TARGET         GB : '||SGA_TARGET_GB
  ||chr(10)||'All Pool Used      GB : '||POOL_USED_GB
  ||chr(10)||'Shared Pool Alloc  GB : '||SHARED_POOL_GB
  ||chr(10)||'Shared Pool Used   GB : '||SHARED_POOL_USED_GB
  ||chr(10)||'Shared Pool Free   GB : '||SHARED_POOL_FREE_GB
  ||chr(10)||'Buffer Cache Alloc GB : '||BUFFER_CACHE_GB
  ||chr(10)||'Buffer Cache Used  GB : '||BUFFER_CACHE_USED_GB
  ||chr(10)||'Other Pool Alloc   GB : '||OTHER_POOL_GB
  ||chr(10)||'Other Pool Used    GB : '||OTHER_POOL_USED_GB
  ||chr(10)||'Other Pool Free    GB : '||OTHER_POOL_FREE_GB
  ||chr(10)||'SGA_USED           GB : '||round((SHARED_POOL_USED_GB+BUFFER_CACHE_USED_GB+OTHER_POOL_USED_GB),1)
  ||chr(10)||'SGA_FREE           GB : '||round((SGA_TARGET_GB-BUFFER_CACHE_USED_GB-SHARED_POOL_USED_GB-OTHER_POOL_USED_GB),1)
  ||chr(10)||'SGA_FREE_PERCENT    % : '||round(((SGA_TARGET_GB-BUFFER_CACHE_USED_GB-SHARED_POOL_USED_GB-OTHER_POOL_USED_GB)*100/SGA_TARGET_GB),1)
  ||chr(10)||'DBF_SIZE           GB : '||DBF_SIZE_GB
  ||chr(10)||'DBF_SIZE_FREE      GB : '||DBF_SIZE_FREE_GB
  ||chr(10)||'DBF_SIZE_USED      GB : '||(DBF_SIZE_GB - DBF_SIZE_FREE_GB)
    FROM
    (SELECT round(sum(number_of_blocks*db_block_size/1073741824),1) BUFFER_CACHE_USED_GB
    ,(select round(bytes/1073741824,1) from v\$sgastat where name = 'buffer_cache') BUFFER_CACHE_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%') POOL_USED_GB
    ,(select round(bytes/1073741824,1) GB from v\$sgainfo where name = 'Shared Pool Size') SHARED_POOL_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool = 'shared pool' and name != 'free memory') SHARED_POOL_USED_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool = 'shared pool' and name = 'free memory') SHARED_POOL_FREE_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgainfo where lower(name) like '%pool%' and name != 'Shared Pool Size') OTHER_POOL_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%' and pool != 'shared pool' and name != 'free memory') OTHER_POOL_USED_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%' and pool != 'shared pool' and name = 'free memory') OTHER_POOL_FREE_GB
--#    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%' and pool in ('large pool','streams pool','numa pool') and name != 'free memory') OTHER_POOL_USED_GB
--#    ,(select round(sum(df.bytes/1073741824),0) from v\$datafile df, v\$tablespace ts where df.ts#=ts.ts# and ts.NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_GB
    ,(select round(sum(bytes/1073741824),0) from dba_data_files where TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_GB
--#    ,(select round(sum(user_bytes/1073741824),0) from dba_data_files where TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_GB
    ,(select round(sum(bytes/1073741824),0) from dba_free_space where TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_FREE_GB
    ,SGA_TARGET_GB
      FROM
      (
      SELECT o.object_name, COUNT(*) number_of_blocks
      ,(SELECT value FROM V\$PARAMETER WHERE name = 'db_block_size') db_block_size
      ,(select round(value/1073741824,1) GB from v\$parameter where name='sga_target') SGA_TARGET_GB
       FROM DBA_OBJECTS o, V\$BH bh
       WHERE o.data_object_id = bh.OBJD
       AND o.owner != 'SYS'
       GROUP BY o.object_Name
       --ORDER BY COUNT(*)
      )
    GROUP BY SGA_TARGET_GB
    )
;"


  [ ! -z "${DEBUG}" ] && (PROMPT_COMMAND_PREV=$PROMPT_COMMAND; unset PROMPT_COMMAND) && set -x

  pad_space="                    "
  pad_size=10

  HEADER=${SQL_COLLECTION}
  DEFINED_HEADER=$(echo ${SQL_COLLECTION}_HEADER)
  [ ! -z "${!DEFINED_HEADER}" ] && HEADER+=" : ${!DEFINED_HEADER}"
  (( ${VERBOSE} >= 2 )) && HEADER+=" : ${!SQL_COLLECTION}"
#echo ${!SQL_COLLECTION}
#echo ${!SQL_COLLECTION//$/\\$}
#echo ${!SQL_COLLECTION//\"/}
  #QUERYRAW=$(set -f; echo "${!SQL_COLLECTION//\"/}" | sed 's:\\$:\\\$:g'; set +f)    QUERY2EXEC="${SQL_PARAM}${QUERYRAW}"
  #QUERYRAW=${!SQL_COLLECTION//$/\\$}
  #QUERYRAW=${!SQL_COLLECTION//\"/}    QUERY2EXEC="${SQL_PARAM}${QUERYRAW}"
  QUERYRAW="${!SQL_COLLECTION}"    QUERY2EXEC="${SQL_PARAM}${QUERYRAW}"

  for SID in $(ps -eo args | grep pm[o]n_"${DB_FILTER}" | cut -d'_' -f3- | grep -v "^+\|^-\|^$\|^DBA" | sort); do . oraenv <<<${SID}>/dev/null
    ORA_VERSION=$(ORAVER=${ORACLE_HOME##*/product/};ORAVER=${ORAVER%/*};echo "$ORAVER")
    [ ! -z "${ORAVERFILTER}" ] && [[ ! ${ORA_VERSION} =~ ${ORAVERFILTER} ]] && continue
    [ "${OPEN_ONLY}" = 1 ] && [ $(echo -e "${INSTANCE_STATUS}" | sqlplus -S / as sysdba | grep -c 'OPEN') -eq 0 ] && continue 
    (( ${VERBOSE} >= 1 )) && echo -e "\n${COLOR_TITLE}${ORACLE_SID} : ${ORA_VERSION}${COLOR_STD}" # : ${COLOR_CMD}${QUERYRAW//\\n/ & }${COLOR_STD}"
    QUERY_OUTPUT=$(echo -e "${QUERY2EXEC}" | sqlplus -S / as sysdba)
    [[ "${QUERY_OUTPUT}" =~ ORA-|TNS-|RMAN-|-bash|KO ]] && OUTCOLOR=${COLOR_KO} || OUTCOLOR=${COLOR_STD}
    [[ "${QUERY_OUTPUT}" =~ "OK" ]] && OUTCOLOR=${COLOR_OK}
    #(( ${VERBOSE} == 0 )) && echo "${ORACLE_SID}${pad_space:0:$((${pad_size}-${#ORACLE_SID}))} (${ORA_VERSION}) : ${HEADER} : ${QUERY_OUTPUT}"
    (( ${VERBOSE} == 0 )) && (set -f; echo "${ORACLE_SID}${pad_space:0:$((${pad_size}-${#ORACLE_SID}))} (${ORA_VERSION}) : ${HEADER} : $(echo ${QUERY_OUTPUT})"; set +f);
    (( ${VERBOSE} >= 1 )) && echo -e "${COLOR_RESULT}${HEADER}${COLOR_STD}"
    (( ${VERBOSE} == 1 )) && (set -f; echo -e "${OUTCOLOR:-${COLOR_RESULT}}$(echo ${QUERY_OUTPUT})${COLOR_STD}"; set +f);
    (( ${VERBOSE} >= 2 )) && echo -e "${OUTCOLOR}${QUERY_OUTPUT}${COLOR_STD}"

  done

  [ ! -z "${DEBUG}" ] && PROMPT_COMMAND=$PROMPT_COMMAND_PREV && set +x
}




function loopdb_tmp {
  unset DB_FILTER VERBOSE DEBUG LOOP_TIMER
  SQL_COLLECTION=${1} ; shift 1

  while [ "$#" -gt 0 ]; do
    case "$1" in
      -h*)  Usage ; return 1 ;;
      -d)  DB_FILTER=".*$2.*" ; if [ "$2" = "" ]; then Usage ; return 1 ; else shift 2 ; fi ;;
      -t)  LOOP_TIMER="$2" ; if [ "$2" = "" ]; then Usage ; return 1 ; else shift 2 ; fi ;;
      -v*)  VERBOSE=YES ; shift 1 ;;
      --debug|-dbg) DEBUG=YES ;  shift 1 ;;
       -*)  echo "!!! Argument $1 invalide !!!"; Usage ; return 1 ;;
        *)  echo "!!! Argument $1 invalide !!!"; Usage ; return 1 ;;
    esac
  done

  COLOR_OK='\033[30;42m'; COLOR_KO="\033[1;37;41m"; COLOR_WARN="\033[30;43m"; COLOR_CMD="\033[1;37;44m"; COLOR_STD="\033[0;0m"; COLOR_TITLE="\033[30;47m"; COLOR_RESULT="\033[30;46m"
  unset COLOR_OK COLOR_KO COLOR_WARN COLOR_CMD COLOR_STD COLOR_TITLE COLOR_RESULT
  DATE=$(date "+%Y-%m-%d_%H:%M:%S")
  SQL_PARAM="WHENEVER SQLERROR EXIT SQL.SQLCODE\nset head off lines $[${COLUMNS}-${COLUMNS}/3] pages 0 trimout on\n"

  export NLS_DATE_FORMAT='YYYY-MM-DD_HH24:MI:SS'
  export NLS_NUMERIC_CHARACTERS=', '
  SGA_DBF_USAGE_HEADER='DATE;HOUR;INSTANCE_NAME;SGA_TARGET_GB;POOL_USED_GB;SHARED_POOL_GB;SHARED_POOL_USED_GB;SHARED_POOL_FREE_GB;BUFFER_CACHE_GB;BUFFER_CACHE_USED_GB;OTHER_POOL_GB;OTHER_POOL_USED_GB;OTHER_POOL_FREE_GB;SGA_FREE;SGA_FREE_PERCENT;SGA_USED'
  SGA_DBF_USAGE="COLUMN SGA_USAGE FORMAT A40
SELECT TO_CHAR(SYSDATE,'YYYY-MM-DD')||';'||TO_CHAR(SYSDATE,'HH24:MI')||';'||(select sys_context('userenv','instance_name') from dual)
||';'||SGA_TARGET_GB
||';'||POOL_USED_GB
||';'||SHARED_POOL_GB
||';'||SHARED_POOL_USED_GB
||';'||SHARED_POOL_FREE_GB
||';'||BUFFER_CACHE_GB
||';'||BUFFER_CACHE_USED_GB
||';'||OTHER_POOL_GB
||';'||OTHER_POOL_USED_GB
||';'||OTHER_POOL_FREE_GB
||';'||(SGA_TARGET_GB-BUFFER_CACHE_USED_GB-SHARED_POOL_USED_GB-OTHER_POOL_USED_GB)
||';'||round(((SGA_TARGET_GB-BUFFER_CACHE_USED_GB-SHARED_POOL_USED_GB-OTHER_POOL_USED_GB)*100/SGA_TARGET_GB),1)
||';'||(SHARED_POOL_USED_GB+BUFFER_CACHE_USED_GB+OTHER_POOL_USED_GB)
    FROM
    (SELECT round(sum(number_of_blocks*db_block_size/1073741824),1) BUFFER_CACHE_USED_GB
    ,(select round(bytes/1073741824,1) from v\$sgastat where name = 'buffer_cache') BUFFER_CACHE_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%') POOL_USED_GB
    ,(select round(bytes/1073741824,1) GB from v\$sgainfo where name = 'Shared Pool Size') SHARED_POOL_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool = 'shared pool' and name != 'free memory') SHARED_POOL_USED_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool = 'shared pool' and name = 'free memory') SHARED_POOL_FREE_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgainfo where lower(name) like '%pool%' and name != 'Shared Pool Size') OTHER_POOL_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%' and pool != 'shared pool' and name != 'free memory') OTHER_POOL_USED_GB
    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%' and pool != 'shared pool' and name = 'free memory') OTHER_POOL_FREE_GB
--    ,(select round(sum(bytes/1073741824),1) GB from v\$sgastat where pool like '%pool%' and pool in ('large pool','streams pool','numa pool')) OTHER_POOL_USED_GB
--    ,(select round(sum(df.bytes/1073741824),0) from v\$datafile df, v\$tablespace ts where df.ts#=ts.ts# and ts.NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_GB
--    ,(select round(sum(bytes/1073741824),0) from dba_data_files where TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_GB
--    ,(select round(sum(user_bytes/1073741824),0) from dba_data_files where TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_GB
--    ,(select round(sum(bytes/1073741824),0) from dba_free_space where TABLESPACE_NAME not in ('SYSTEM','SYSAUX','UNDOTBS1','UNDOTBS2','UNDOTBS3','TEMP','USERS')) DBF_SIZE_FREE_GB
    ,SGA_TARGET_GB
      FROM
      (
      SELECT o.object_name, COUNT(*) number_of_blocks
      ,(SELECT value FROM V\$PARAMETER WHERE name = 'db_block_size') db_block_size
      ,(select round(value/1073741824,1) GB from v\$parameter where name='sga_target') SGA_TARGET_GB
       FROM DBA_OBJECTS o, V\$BH bh
       WHERE o.data_object_id = bh.OBJD
       AND o.owner != 'SYS'
       GROUP BY o.object_Name
       --ORDER BY COUNT(*)
      )
    GROUP BY SGA_TARGET_GB
    )
;"


  [ ! -z "${DEBUG}" ] && (PROMPT_COMMAND_PREV=$PROMPT_COMMAND; unset PROMPT_COMMAND) && set -x

  HEADER=${SQL_COLLECTION}
  [[ "${VERBOSE}" == "YES" ]] && HEADER="${SQL_COLLECTION} : ${!SQL_COLLECTION}"
  QUERYRAW="${!SQL_COLLECTION}"    QUERY2EXEC="${SQL_PARAM}${QUERYRAW}"

function ExecPrint_Result {
  for SID in $(ps -eo args | grep pm[o]n_"${DB_FILTER}" | cut -d'_' -f3- | grep -v "^+\|^-\|^$\|^DBA" | sort); do . oraenv <<<${SID}>/dev/null
    ORA_VERSION=$(ORAVER=${ORACLE_HOME##*/product/};ORAVER=${ORAVER%/*};echo "$ORAVER")
    [ ! -z "${ORAVERFILTER}" ] && [[ ! ${ORA_VERSION} =~ ${ORAVERFILTER} ]] && continue
#    echo -e "\nDATE : ${DATE}\n${COLOR_TITLE}${ORACLE_SID} : ${ORA_VERSION}${COLOR_STD}" # : ${COLOR_CMD}${QUERYRAW//\\n/ & }${COLOR_STD}"
    QUERY_OUTPUT=$(echo -e "${QUERY2EXEC}" | sqlplus -S / as sysdba)
    [[ "${QUERY_OUTPUT}" =~ ORA-|TNS-|RMAN-|-bash|KO ]] && OUTCOLOR=${COLOR_KO} || OUTCOLOR=${COLOR_STD}
    [[ "${QUERY_OUTPUT}" =~ "OK" ]] && OUTCOLOR=${COLOR_OK}
#    [[ -z "${VERBOSE}" ]] && echo -e "${COLOR_RESULT}${HEADER}${COLOR_STD}"
#    [[ "${VERBOSE}" == "YES" ]] && echo -e "${COLOR_RESULT}${HEADER}${COLOR_STD}"
    [[ -z "${VERBOSE}" ]] && echo -e "${OUTCOLOR}${QUERY_OUTPUT}${COLOR_STD}"
    [[ "${VERBOSE}" == "YES" ]] && (set -f; echo -e "${OUTCOLOR:-${COLOR_RESULT}}$(echo ${QUERY_OUTPUT})${COLOR_STD}"; set +f);
  done
}

if [ ! -z "${LOOP_TIMER}" ]; then
  #echo "Press [CTRL+C] to stop the loop ..."
  echo "${SGA_DBF_USAGE_HEADER}"
  while : 
  do
    ExecPrint_Result
    sleep ${LOOP_TIMER}
  done
else
  ExecPrint_Result
fi


  [ ! -z "${DEBUG}" ] && PROMPT_COMMAND=$PROMPT_COMMAND_PREV && set +x
}


function oralisthome {
  local FILTER
  [ ! -z "${1}" ] && FILTER="| grep ${1}"
  #printf "%6s %-20s %-80s\n" "PID" "NAME" "ORACLE_HOME"
  printf "%6s %-10s %-80s\n" "PID" "NAME" "ORACLE_HOME"
  eval "pgrep -af _pmon_ ${FILTER} | sort -k2,2" |
    while read pid pname ; do
      printf "%6s %-10s %-80s\n" $pid ${pname#???_pmon_} $(sudo ls -l /proc/$pid/exe | awk -F'>' '{ print $2 }' | sed 's/bin\/oracle$//' | sort | uniq)
    done
}


function oragetversionpid {
  local db
  [ ! -z "${1}" ] && db=${1} || { echo "Arg is missing : DBNAME"; return 1; }
  [ ${#db} -lt 8 ] && { echo "Arg must contain 8 char : \"${db}\""; return 1; }
  sudo ls -l /proc/$(eval "pgrep -f ora_pmon_${db^^}")/exe | sed 's:.*/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*:\1.\2.\3.\4.\5:'
}


function oralistcnx {
  ps -eo "args" | grep L[O]CAL=NO | sort | uniq -c
}


function lsnGetservice_OLD {
  LSN_NAME_LIST=$(ps -eo args | grep -w tnsl[s]nr | sed 's/.*lsnr \(.*\) -no.*/\1/')
  for LSN_NAME in ${LSN_NAME_LIST}; do
    cmd="lsnrctl status ${LSN_NAME} | grep -m 3 ${1}.*_APPLI"
    host_port=$(lsnrctl status ${LSN_NAME} | grep PORT | sed 's/.*\(.*HOST=.*\)\(PORT=.*\)/Host=\1 Port=\2/')
    echo "${LSN_NAME} :"
    echo ${cmd}
    eval ${cmd}
    #eval ${cmd} | highlight cyan 'lsnrctl status'
  done
}


function lsnGetservice {
  [ "$DBG" == "2" ] && set -x
  FORMER_FUNCNAME=${FUNCNAME[0]:-$0}
  local DBG=${2:-${DBG}}  ## FGR : 2025-01-10 : DBG var must transfered as the function is self-called
  local ORACLE_HOME=${ORACLE_HOME}  ## FGR : 2025-01-17 : Input the current ORACLE_HOME but don't modify it outside the function

  ## Set the GI env if not already done
  [ -z "${GI_HOME}" ] && { GI_HOME=$(awk -F: '/^+ASM/ {print $2}' /etc/oratab); [ -n "$DBG" ] && echo "Set GI_HOME from oratab : GI_HOME=${GI_HOME}" ;}
  [ -n "${GI_HOME}" -a -x "${GI_HOME}/bin/oracle" ] || { GI_HOME=$(dirname $(ps -eo args | grep [o]cssd.bin) | awk '{print substr( $1, 1, length($1)-4)}'); [ -n "$DBG" ] && echo "Set GI_HOME from process : GI_HOME=${GI_HOME}" ;}
  local GI_OWNER=$(find ${GI_HOME}/bin/oracle -prune -printf '%u')

  function Usage {
    echo "Usage : ${FORMER_FUNCNAME} <DB_STRING>.*X1"
  }

  [ -z "${1}" ] && Usage && read -p "List all listener services ? (return to continue) " ANSWER
  [ ! -z "${ANSWER}" ] && exit

  MainFunc () {
    [ -n "$DBG" ] && echo GI_HOME=${GI_HOME}
    [ -n "$DBG" ] && echo GI_BIN=${GI_BIN}
    [ -n "$DBG" ] && echo "(BEFORE) ORACLE_HOME=${ORACLE_HOME}"
#    [ -z "${ORACLE_HOME}" ] && { export ORACLE_HOME=${GI_BIN%/bin}; [ -n "$DBG" ] && echo "ORACLE_HOME absent, setting OH to ${GI_BIN%/bin}"; }
    [ "${ORACLE_HOME}" != "${GI_HOME}" ] && { export ORACLE_HOME=${GI_HOME}; [ -n "$DBG" ] && echo "ORACLE_HOME absent or incorrect, set OH to GI_HOME (${GI_HOME})"; } || { [ -n "$DBG" ] && echo "ORACLE_HOME already set to GI_HOME (${GI_HOME})"; }
    [ -n "$DBG" ] && echo "(AFTER) ORACLE_HOME=${ORACLE_HOME}"
    #echo "Usage : ${FORMER_FUNCNAME} <TRI>.*X1"
  LSN_SERVICE=${1:-.}
#    LSN_NAME_LIST=$(ps -eo args | grep -w tnsl[s]nr | sed 's/.*lsnr \(.*\) -no.*/\1/')
    LSN_NAME_LIST=$(ps -eo args | grep -w tnsl[s]nr | awk '{print $2}')
    for LSN_NAME in ${LSN_NAME_LIST}; do
      #cmd="lsnrctl status ${LSN_NAME} | grep -m 3 ${LSN_SERVICE}.*_APPLI"
      cmd="${GI_HOME}/bin/lsnrctl status ${LSN_NAME} | grep ${LSN_SERVICE}"
      #host_port=$(lsnrctl status ${LSN_NAME} | grep PORT | sed 's/.*\(.*HOST=.*\))(\(PORT=.*\))))/\1 \2/')
      host_port=$(${GI_HOME}/bin/lsnrctl status ${LSN_NAME} | grep PORT | sed 's:.*(\(.*HOST=.*\))(\(PORT=[0-9]*\)).*:\1 \2:')
      echo -e "\e[7;40;37m${LSN_NAME}\e[0m : "${host_port}
      #[ -n "$DBG" ] && echo "EXEC : $(eval echo ${cmd})"
      #eval ${cmd}
      RESULT="$(eval ${cmd})"
      echo -e "\e[1;32m${RESULT}\e[0m"
      #eval ${cmd} | highlight cyan 'lsnrctl status'
    done
  }

  ## FGR : 2025-01-10 : Make sure to execute the command using the GI bin owner
  if [ "${LOGNAME}" == "${GI_OWNER}" ]; then
    [ -n "$DBG" ] && echo "LOGNAME:${LOGNAME} == GI_OWNER:${GI_OWNER} (find ${GI_HOME}/bin/oracle -prune -printf '%u')"
    ## FGR : 2025-01-09 : oratab become deprecated and in the case +ASM* entry does not exist, the below command will break the ORACLE_HOME
    #if [[ ! "${ORACLE_SID}" =~ "ASM" ]]; then HOST=$(hostname -s); export ORACLE_SID="+ASM${HOST:0,-1}"; export ORAENV_ASK=NO; . oraenv>/dev/null; fi
    cmd="MainFunc $1 $DBG"
    [ -n "$DBG" ] && echo "EXEC : $(eval echo ${cmd})"
    eval ${cmd}
  else
    [ -n "$DBG" ] && echo "LOGNAME:${LOGNAME} <> GI_OWNER:${GI_OWNER} (find ${GI_HOME}/bin/oracle -prune -printf '%u')"
    #export -f MainFunc
    #sudo -u grid bash -c "MainFunc $1"
    #su grid -c "bash -c MainFunc $1"
    #su grid -c "bash -c HOST=$(hostname -s); export ORACLE_SID=+ASM${HOST:0,-1}; export ORAENV_ASK=NO; export PATH=${PATH}:/usr/local/bin/; . oraenv>/dev/null; MainFunc $1"
    #su grid -c "bash -c echo "HOST=$(hostname -s); export ORACLE_SID=+ASM${HOST:0,-1}; export ORAENV_ASK=NO; export PATH=${PATH}:/usr/local/bin/; . oraenv; echo ${ORACLE_SID}:${ORACLE_HOME}; MainFunc $1""
    #sudo -i -u grid bash -c ". ${BI_PATH}/lib/fgenv >/dev/null 2>&1; export PATH=\$PATH:/usr/local/bin/; HOST=\$(hostname -s); export ORACLE_SID=+ASM\${HOST:0,-1}; export ORAENV_ASK=NO; . oraenv>/dev/null; lsnGetservice $1"
    #sudo -i -u ${GI_OWNER} bash -c ". ${BI_PATH}/lib/fgenv >/dev/null 2>\&1; export PATH=\${PATH}:${GI_HOME/bin}; export ORACLE_HOME=${GI_HOME}; lsnGetservice $1 $DBG"
    sudo_cmd='sudo -i -u ${GI_OWNER} bash -c ". ${BI_PATH}/lib/fgenv >/dev/null 2>\&1; lsnGetservice $1 $DBG"'
    [ -n "$DBG" ] && echo "EXEC : $(eval echo ${sudo_cmd})"
    eval "${sudo_cmd}"
  fi
  [ "$DBG" == "2" ] && set +x || true  ## FGR : 2025-01-10 : Because this is the last command, if FALSE it will print the "BASH COMMAND TIMER" in RED
}


function asmdu {
# https://blog.pythian.com/amcmd-better-du/
    D=$1
    if [[ -z "$D" ]]; then
        echo "Please provide a directory !"
        return 1
        #exit 1
    fi

    (for DIR in $(asmcmd ls ${D}); do
        echo ${DIR} $(asmcmd du ${D}/${DIR} | tail -1)
    done) | awk -v D="$D" '
    BEGIN { printf("\n\t%30s\n\n", D " subdirectories size");
    printf("%25s%16s%16s\n", "Subdir", "Used MB", "Mirror MB");
    printf("%25s%16s%16s\n", "------", "-------", "---------");
    }
    { printf("%25s%16s%16s\n", $1, $2, $3);
    use += $2;
    mir += $3;
    }
    END { printf("\n\n%25s%16s%16s\n", "------", "-------", "---------");
    printf("%25s%16s%16s\n\n", "Total", use, mir);
    }'
}


function ASMvsDB_DIFF {
    [[ "${LOGNAME}" != "grid" ]] && echo "You must be connected as grid" && return 1
    DG_DATA=DATAC1
    DG_RECO=RECOC1

    echo "DG_DATA = ${DG_DATA}"
    echo "DG_RECO = ${DG_RECO}"
    echo "CRS_DBUNAME = srvctl config"

    ASMDIR_DATA=$(asmcmd ls ${DG_DATA} | sort | grep -E 'D1|D2' | sed s:/::)
    ASMDIR_RECO=$(asmcmd ls ${DG_RECO} | sort | grep -E 'D1|D2' | sed s:/::)
    CRS_DBUNAME=$(srvctl config | grep -E 'D1|D2')

    echo -e "\nDifference between :\nASMDIR_DATA vs ASMDIR_RECO"
    diff --suppress-common-lines -yW 27 <(echo "${ASMDIR_DATA}") <(echo "${ASMDIR_RECO}") | grep -v ','
    unset DIFF_COUNT; DIFF_COUNT=$(diff <(echo "${ASMDIR_DATA}") <(echo "${ASMDIR_RECO}") | grep -vc ",")
    [ "${DIFF_COUNT}" -eq 0 ] && echo "No difference : OK" #|| echo "Difference detected \"${DIFF_COUNT}\" : KO"

    echo -e "\nDifference between :\nASMDIR_DATA vs CRS_DBUNAME"
    diff --suppress-common-lines -yW 27 <(echo "${ASMDIR_DATA}") <(echo "${CRS_DBUNAME}") | grep -v ','
    unset DIFF_COUNT; DIFF_COUNT=$(diff <(echo "${ASMDIR_DATA}") <(echo "${CRS_DBUNAME}") | grep -vc ",")
    [ "${DIFF_COUNT}" -eq 0 ] && echo "No difference : OK" #|| echo "Difference detected \"${DIFF_COUNT}\" : KO"

    echo -e "\nDifference between :\nASMDIR_RECO vs CRS_DBUNAME"
    diff --suppress-common-lines -yW 27 <(echo "${ASMDIR_RECO}") <(echo "${CRS_DBUNAME}") | grep -v ','
    unset DIFF_COUNT; DIFF_COUNT=$(diff <(echo "${ASMDIR_RECO}") <(echo "${CRS_DBUNAME}") | grep -vc ",")
    [ "${DIFF_COUNT}" -eq 0 ] && echo "No difference : OK" #|| echo "Difference detected \"${DIFF_COUNT}\" : KO"
}


function cr_pfile_from_spfile {
	SPFILE_ASM=$(srvctl config database -d ${DBUNAME} | grep spfile | cut -d' ' -f2)
	#export ORACLE_HOME=
	echo -e "create pfile='/tmp/init@.ora' from spfile='${SPFILE_ASM}' ;" | sqlplus -S / as sysdba
}


function set_oracle_wallet {
    local REP_WALLET_INFRA
    REP_WALLET_INFRA="${TOOLKIT_DIR:-/prsyslib/toolunix/bin}/ora/wallet_infra"
    export TNS_ADMIN=${1:-$REP_WALLET_INFRA}
    echo "TNS_ADMIN=${TNS_ADMIN}"
}

function oracle_wallet_infra {
    local REP_WALLET_INFRA
    #hostname | grep prdres >/dev/null 2>&1 && ENV=PRD
    #hostname | grep intres >/dev/null 2>&1 && ENV=HPR
    [ "${ENV}" = "HPR" ] && local WALLET_PASSWD=${WALLET_PASSWD:-$(echo "aUZLVVcjSCQhdWhBdHVYCg==" | base64 -d)}
    [ "${ENV}" = "PRD" ] && local WALLET_PASSWD=${WALLET_PASSWD:-$(echo "YXZTU2kjPWRhbUVzUWZHCg==" | base64 -d)}
    # FGR : #orapki wallet change_pwd -wallet ${REP_WALLET_INFRA} -oldpwd '<old_passwd>' -newpwd '<new_passwd>'
    if $(which --skip-alias mkstore >/dev/null 2>&1); then echo "ORACLE_HOME=${ORACLE_HOME}"; else echo "ORACLE_HOME not set"; return 0; fi
    REP_WALLET_INFRA="${TOOLKIT_DIR:-/prsyslib/toolunix/bin}/ora/wallet_infra"
    export TNS_ADMIN=${REP_WALLET_INFRA}
    echo "TNS_ADMIN=${TNS_ADMIN}"
    [ -z "${WALLET_PASSWD}" ] && read -p "Enter Wallet Password : " -s WALLET_PASSWD
    if ! $(echo "${WALLET_PASSWD}" | mkstore -wrl ${REP_WALLET_INFRA} -listCredential >/dev/null 2>&1) ; then echo 'Wrong Wallet password' ; fi
    action=${1:-PRINT}

    NBR_ENTRIES=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${REP_WALLET_INFRA} -listCredential | grep -c [0-9]:)

    [ "${action}" == "CREATE_WALLET_COMMAND" ] && echo "echo -e \"\${WALLET_PASSWD}\n\${WALLET_PASSWD}\" | mkstore -wrl ${REP_WALLET_INFRA} -create"

    for i in $(seq 1 ${NBR_ENTRIES}) ; do
        unset WLT_USERNAME WLT_PASSWORD WLT_CONNECT_STRING
        WLT_USERNAME=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${REP_WALLET_INFRA} -viewEntry oracle.security.client.username${i} | grep username${i} | awk -F '= ' '{print $NF}')
        WLT_PASSWORD=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${REP_WALLET_INFRA} -viewEntry oracle.security.client.password${i} | grep password${i} | awk -F '= ' '{print $NF}')
        WLT_CONNECT_STRING=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${REP_WALLET_INFRA} -viewEntry oracle.security.client.connect_string${i} | grep connect_string${i}| awk -F '= ' '{print $NF}')

        [ "${action}" == "PRINT" ] && echo "${WLT_USERNAME}@${WLT_CONNECT_STRING}"
        [ "${action}" == "PRINT_PWD" ] && echo "${WLT_USERNAME}/${WLT_PASSWORD}@${WLT_CONNECT_STRING}"
        [ "${action}" == "TEST_CNX" ] && WLT_ENTRY="${WLT_USERNAME}/${WLT_PASSWORD}@${WLT_CONNECT_STRING}"

        if [ "${action}" == "TEST_CNX" ] ; then
            timeout 5 echo exit | sqlplus -L -S ${WLT_USERNAME}/${WLT_PASSWORD}@${WLT_CONNECT_STRING} && WLT_ENTRY+=" : cnx_OK" || WLT_ENTRY+=" : cnx_KO"
        fi

        if [ "${action}" == "CREATE_WALLET_COMMAND" ] ; then
            echo "echo \${WALLET_PASSWD} | mkstore -wrl \${REP_WALLET_INFRA} -createCredential ${WLT_CONNECT_STRING} ${WLT_USERNAME} ${WLT_PASSWORD}"
        fi

    [ "${action}" == "TEST_CNX" ] && echo "${WLT_ENTRY}"
    done
}

# read -s WALLET_PASSWD
# echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} ${WLT_DFT_ARGS} -viewEntry oracle.security.client.default_password | grep =
function oracle_wallet_db {
[ -n "${DBG}" ] && set -x || set +x
    local DBUNAME
    local WALLET_PATH=${WALLET_PATH:-.}
    local WALLET_PASSWD=${WALLET_PASSWD}
    local WLT_DFT_ARGS='-nologo'
    local action=${1:-PRINT}

    #if [ ! -f "${WALLET_PATH}/cwallet.sso" -o ! -f "${WALLET_PATH}/ewallet.p12" ] ; then echo -e '\nWallet is inaccessible or does not exist' ; return 1; fi
    if [  -f "${WALLET_PATH}/cwallet.sso" -a -f "${WALLET_PATH}/ewallet.p12" ] ; then 
        #[ -z "${WALLET_PASSWD}" ] && read -p "Enter Wallet Password : " -s WALLET_PASSWD
        echo "Wallet Found : WALLET_PATH=${WALLET_PATH} => $(pwd)"
    elif [ "${WALLET_PATH}" = "." -a -n "${ORACLE_SID}" ] ; then
        [ -z "${DBUNAME}" ] && DBUNAME=$(srvctl config | grep ${ORACLE_SID:0:8})
        [ -d /apps/oracle/${DBUNAME}/wallet/shared ] && WALLET_PATH=/apps/oracle/${DBUNAME}/wallet/shared
        [ -d /srv/oracle/${DBUNAME}/wallet/shared ] && WALLET_PATH=/srv/oracle/${DBUNAME}/wallet/shared
        [ ! -r ${WALLET_PATH}/cwallet.sso ] && { echo -e '\nWallet is inaccessible or does not exist' ; return 1 ;}
        echo "Wallet Found : WALLET_PATH=${WALLET_PATH}"
    fi

    [ "${WALLET_PATH}" = "." ] && local WALLET_PATH_TEST=$(pwd)
    [[ "${WALLET_PATH_TEST:-$WALLET_PATH}" =~ "/wallet/shared" ]] && local ENV=CNVG

    [ "${ENV}" = "HPR" ] && local WALLET_PASSWD=${WALLET_PASSWD:-$(echo "aUZLVVcjSCQhdWhBdHVYCg==" | base64 -d)}
    [ "${ENV}" = "PRD" ] && local WALLET_PASSWD=${WALLET_PASSWD:-$(echo "YXZTU2kjPWRhbUVzUWZHCg==" | base64 -d)}
    [ "${ENV}" = "CNVG" ] && local WALLET_PASSWD=${WALLET_PASSWD:-$(echo "Vk9QbkQ1SG00N3RXd0pUamU4awo=" | base64 -d)}

    #[ -z "${DBUNAME}" ] && [ -z "${ORACLE_SID}" ] && { echo "ORACLE_SID not set"; return 1; }
    #[ -z "${DBUNAME}" ] && DBUNAME=$(srvctl config | grep ${ORACLE_SID:0:8})
    #WALLET_PATH=${WALLET_PATH:-/apps/oracle/${DBUNAME}/wallet/shared}
    #echo "Wallet Found : WALLET_PATH=${WALLET_PATH}"
    #export TNS_ADMIN=${WALLET_PATH}
    #echo "TNS_ADMIN=${TNS_ADMIN}"

    #if $(which --skip-alias mkstore >/dev/null 2>&1); then echo "ORACLE_HOME=${ORACLE_HOME}"; else echo "ORACLE_HOME not set"; return 0; fi
    if ! $(which --skip-alias mkstore >/dev/null 2>&1); then 
        echo "mkstore binary not is the path ... Searching ..."
        #if MKSTORE_BIN_PATH=$(dirname `locate -be '\mkstore' | grep grid | tail -1`); 
        #if MKSTORE_BIN_PATH=$(dirname `locate -be '\mkstore' | grep grid | tail -1`); then echo "MKSTORE_BIN_PATH=${MKSTORE_BIN_PATH}"; PATH=${PATH}:${MKSTORE_BIN_PATH}; else echo "! mkstore not found !"; return 0; fi
        if MKSTORE_BIN_PATH=$(dirname `locate -be '\mkstore' | xargs ls -1t | grep grid | head -1`) ;
            then echo "MKSTORE_BIN_PATH=${MKSTORE_BIN_PATH}"; PATH=${PATH}:${MKSTORE_BIN_PATH};
            else echo "! mkstore not found !";
            return 0
        fi
    #else 
    #    #echo "ORACLE_HOME=${ORACLE_HOME}"
    #    echo "MKSTORE_BIN_PATH=${MKSTORE_BIN_PATH}"
    fi

    #if ! $(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} -listCredential >/dev/null 2>&1) ; then echo 'Wrong Wallet password' ; fi
    #if [ $(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} ${WLT_DFT_ARGS} -list | grep -c 'incorrect password') -ne 0 ] ; then echo 'Wrong Wallet password' ; return 1; fi

    # orapki wallet display -wallet ${WALLET_PATH:-.}
    # orapki wallet display -wallet ${WALLET_PATH:-.} | grep 'oracle.security.client' |  wc -l
    array_wlt_check=( "$(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} ${WLT_DFT_ARGS} -list)" )
    if [ $(echo "${array_wlt_check}" | grep -c 'incorrect password') -eq 1 ] ; then echo -e '\nWrong Wallet password' ; return 1; fi
    if [ $(echo "${array_wlt_check}" | grep -c 'oracle.security.client') -eq 0 ] ; then echo -e '\nWallet Empty' ; return 1; fi
    if [ $(echo "${array_wlt_check}" | grep -c 'Oracle Secret Store entries') -eq 1 ] ; then echo -e '\nReading the Wallet ...' ; fi

    ## FGR Done above #array_wlt_entries=( "$(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} ${WLT_DFT_ARGS} -list | grep client | sort -t. -Vk4.7,4 | grep oracle.security.client)" )
    array_wlt_default=( $(echo "${array_wlt_check[@]}" | grep '\.default' | sort -rV) )
    array_wlt_entries=( "$(echo "${array_wlt_check}" | grep client | sort -t. -Vk4.7,4 | grep oracle.security.client)" )
    array_wlt_username=( $(echo "${array_wlt_entries}" | grep '\.username') )
    array_wlt_password=( $(echo "${array_wlt_entries}" | grep '\.password') )
    array_wlt_connect_string=( $(echo "${array_wlt_entries}" | grep '\.connect_string') )

    array_wlt_entries_value=( "$(echo ${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} ${array_wlt_entries//oracle./-viewEntry oracle.} | grep oracle.security.client)" )
    array_wlt_default_username_value=( $(echo "${array_wlt_entries_value}" | grep '\.default_username' | awk -F '= ' '{print $NF}') )
    array_wlt_default_password_value=( $(echo "${array_wlt_entries_value}" | grep '\.default_password' | awk -F '= ' '{print $NF}') )
    array_wlt_username_value=( $(echo "${array_wlt_entries_value}" | grep '\.username' | awk -F '= ' '{print $NF}') )
    array_wlt_password_value=( $(echo "${array_wlt_entries_value}" | grep '\.password' | awk -F '= ' '{print $NF}') )
    array_wlt_connect_string_value=( $(echo "${array_wlt_entries_value}" | grep '\.connect_string' | awk -F '= ' '{print $NF}') )

    [ "${action}" == "DBG" ] && echo "DBG : Print Wallet Entries Sorted 'sort -t. -Vk4.7,4'"
    [ "${action}" == "DBG" ] && (
    echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -list | grep client | sort -t. -Vk4.7,4
    echo -e "\narray_wlt_entries" && echo "${array_wlt_entries}"
    echo -e "\narray_wlt_default" && echo "${array_wlt_default[@]}"
    #echo -e "\narray_wlt_username" && echo -e "${array_wlt_username[@]//oracle./\noracle.}"
    #echo -e "\narray_wlt_password" && echo -e "${array_wlt_password[@]//oracle./\noracle.}"
    #echo -e "\narray_wlt_connect_string" && echo -e "${array_wlt_connect_string[@]//oracle./\noracle.}"

    echo -e "\narray_wlt_entries_value" && echo "${array_wlt_entries_value}"
    echo -e "\narray_wlt_default_value" && echo -e "${array_wlt_default_value[@]}"
    echo -e "\narray_wlt_username_value" && echo -e "${array_wlt_username_value[@]}"
    echo -e "\narray_wlt_password_value" && echo -e "${array_wlt_password_value[@]}"
    echo -e "\narray_wlt_connect_string_value" && echo -e "${array_wlt_connect_string_value[@]}"
    echo

    ## Default Credential
    # echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} ${WLT_DFT_ARGS} -viewEntry oracle.security.client.default_username | grep =
    # echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} ${WLT_DFT_ARGS} -viewEntry oracle.security.client.default_password | grep =
    
    if [ "${#array_wlt_default[@]}" -gt "0" ] ; then 
        echo "DBG DFT : ${array_wlt_default_username_value}/${array_wlt_default_password_value}"
        echo
    fi

    for wlt_idx in "${!array_wlt_username[@]}" ; do 
        #echo "idx[$wlt_idx] => ${array_wlt_username[$wlt_idx]} => ${array_wlt_username_value[$wlt_idx]}/${array_wlt_password_value[$wlt_idx]}@${array_wlt_connect_string_value[$wlt_idx]}" 
        echo "DBG : ${array_wlt_username_value[$wlt_idx]}/${array_wlt_password_value[$wlt_idx]}@${array_wlt_connect_string_value[$wlt_idx]}"
    done
    )


    [ "${action}" == "CREATE_WALLET_COMMAND" ] && echo && echo -e "# Create the Wallet :" && echo "echo -e \"\${WALLET_PASSWD}\n\${WALLET_PASSWD}\" | mkstore -wrl \${WALLET_PATH} ${WLT_DFT_ARGS} -create"
    #orapki wallet create -wallet ${WALLET_PATH} -pwd ${WALLET_PASSWD} -auto_login
    #echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} -createEntry oracle.security.client.default_username SYS
    #echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} -createEntry oracle.security.client.default_password ${PASSWORD}
    #echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} -list
    #echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} -deleteEntry oracle.security.client.default_username
    #echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH:-.} -deleteEntry oracle.security.client.default_password
    # FGR : #orapki wallet change_pwd -wallet ${WALLET_PATH} -oldpwd '<old_passwd>' -newpwd '<new_passwd>'
    #read -p "Enter SYS Password : " -s SYS_PASSWD ; /apps/dbatools/prod/script/ora_shared_wallet.ksh -I ${ORACLE_SID} -A ADD_DG -P ${SYS_PASSWD}
    #/apps/dbatools/prod/script/ora_shared_wallet.ksh -I ${ORACLE_SID} -A ADD_DG -P gIVQJXDXDjEHWM6
    #/apps/dbatools/prod/script/shared/ora_shared_wallet.ksh -I TBIOREX11 -A REMOVE_ZDLRA
    echo

    ## Loop Credentials
    [ "${action}" != "DBG" ] && (
    echo "# Default Credential :"
    if [ "${#array_wlt_default[@]}" -gt 0 ] ; then 
        [ "${action}" == "PRINT" ] && echo "${array_wlt_default_username_value}"
        [ "${action}" == "PRINT_PWD" ] && echo "${array_wlt_default_username_value}/${array_wlt_default_password_value}"
        [ "${action}" == "TEST_CNX" ] && ( timeout 5 echo exit | sqlplus -L -S ${array_wlt_default_username_value}/${array_wlt_default_password_value}@${array_wlt_connect_string_value} && echo "DFT : cnx_OK" || echo "DFT : cnx_KO" )
        [ "${action}" == "CREATE_WALLET_COMMAND" ] && (
            echo "echo \${WALLET_PASSWD} | mkstore -wrl \${WALLET_PATH} ${WLT_DFT_ARGS} -createEntry oracle.security.client.default_username ${array_wlt_default_username_value}"
            echo "echo \${WALLET_PASSWD} | mkstore -wrl \${WALLET_PATH} ${WLT_DFT_ARGS} -createEntry oracle.security.client.default_password ${array_wlt_default_password_value}"
        )
    fi
    echo
    
    echo "# Named Credential :"
    #NBR_ENTRIES=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -listCredential | grep -c [0-9]:)
    #for i in $(seq 1 ${NBR_ENTRIES}) ; do
    for wlt_idx in "${!array_wlt_username[@]}" ; do
        unset WLT_USERNAME WLT_PASSWORD WLT_CONNECT_STRING
        #WLT_USERNAME=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH}  ${WLT_DFT_ARGS} -viewEntry oracle.security.client.username${i} | grep username${i} | awk -F '= ' '{print $NF}')
        #WLT_PASSWORD=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH}  ${WLT_DFT_ARGS} -viewEntry oracle.security.client.password${i} | grep password${i} | awk -F '= ' '{print $NF}')
        #WLT_CONNECT_STRING=$(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -viewEntry oracle.security.client.connect_string${i} | grep connect_string${i}| awk -F '= ' '{print $NF}')
        WLT_USERNAME=${array_wlt_username_value[$wlt_idx]}
        WLT_PASSWORD=/${array_wlt_password_value[$wlt_idx]}
        WLT_CONNECT_STRING=@${array_wlt_connect_string_value[$wlt_idx]}

        [ "${action}" == "PRINT" ] && echo "${WLT_USERNAME}${WLT_CONNECT_STRING}"
        [ "${action}" == "PRINT_PWD" ] && echo "${WLT_USERNAME}${WLT_PASSWORD}${WLT_CONNECT_STRING}"

        if [ "${action}" == "TEST_CNX" ] ; then
            WLT_ENTRY="${WLT_USERNAME}${WLT_PASSWORD}${WLT_CONNECT_STRING}"
            timeout 5 echo exit | sqlplus -L -S ${array_wlt_username_value[$wlt_idx]}/${array_wlt_password_value[$wlt_idx]}@${array_wlt_connect_string_value[$wlt_idx]} && WLT_ENTRY+=" : cnx_OK" || WLT_ENTRY+=" : cnx_KO"
            echo "${WLT_ENTRY}"
        fi

        if [ "${action}" == "CREATE_WALLET_COMMAND" ] ; then
            echo "echo \${WALLET_PASSWD} | mkstore -wrl \${WALLET_PATH} ${WLT_DFT_ARGS} -createCredential ${array_wlt_connect_string_value[$wlt_idx]} ${array_wlt_username_value[$wlt_idx]} ${array_wlt_password_value[$wlt_idx]}"
            #echo "echo \${WALLET_PASSWD} | mkstore -wrl \${WALLET_PATH} \${WLT_DFT_ARGS} -createEntry ${array_wlt_connect_string_value[$wlt_idx]} ${array_wlt_username_value[$wlt_idx]} ${array_wlt_password_value[$wlt_idx]}"
        fi
    done
    )
[ -n "${DBG}" ] && set +x
}




## DBATOOLS Integration
# DBATools Source Environment
alias dbtenv='. <(cat ~/.profile | grep -v PS1)'


function dbtconf {
  echo FUNCNAME="${FUNCNAME[0]:-$0}"
  local ORACLE_SID=${1:-$ORACLE_SID}
  [ -z "${ORACLE_SID}" ] && { echo "Please set or provide an ORACLE_SID" ; return 1; }
  echo -e "\e${CWB}DBATools Configuration for Database : \e${CNC}${ORACLE_SID:0:8} ($(eval ls /{apps,srv}/oracle/${ORACLE_SID}/config/${ORACLE_SID}.env 2>/dev/null))" | grep -E "^|${ORACLE_SID:0:8}"
  cat /{apps,srv}/oracle/${ORACLE_SID}/config/${ORACLE_SID}.env 2>/dev/null | grep -v '^#' | grep -E 'DBID|DBUN=|DBNAME|CATALOG|TYPE_RMAN|TYPE_ARCH_RMAN|SBT_TYPE|PARMS_RMAN|PARALLELISM|COMPRESSION' | sed 's:^export ::'
}


function oracle_wallet_dbatools {
[ -n "${DBG}" ] && set -x || set +x
    local PATH=${PATH}
    local WALLET_PATH
    local WALLET_PASSWD=${WALLET_PASSWD:-$(echo "Vk9QbkQ1SG00N3RXd0pUamU4awo=" | base64 -d)}
    local WLT_DFT_ARGS='-nologo'
    local SYS_PASSWD=${SYS_PASSWD}
    #local action=${1^^:-PRINT}
    local action=${1:-PRINT}
    [ "${action}" == "SET" ] && (
        local SYS_PASSWD=${SYS_PASSWD:-$2}
        [ -z "${SYS_PASSWD}" ] && read -p "Enter SYS Password : " -s SYS_PASSWD
        [ -z "${SYS_PASSWD}" ] && { echo "! Variable SYS_PASSWD must be set !" ; return 1 ; }
        )
    echo 

    #if $(which --skip-alias mkstore >/dev/null 2>&1); then echo "ORACLE_HOME=${ORACLE_HOME}"; else echo "ORACLE_HOME not set"; return 0; fi
    if $(which --skip-alias mkstore >/dev/null 2>&1); then 
        echo "ORACLE_HOME=${ORACLE_HOME}"
    else 
        echo "ORACLE_HOME not set"
        echo "Searching for mkstore binary :"
    #if BIN=$(dirname `locate -be '\mkstore' | grep grid | tail -1`); 
    #if BIN=$(dirname `locate -be '\mkstore' | grep grid | tail -1`); then echo "BIN=${BIN}"; PATH=${PATH}:${BIN}; else echo "! mkstore not found !"; return 0; fi
        if BIN=$(dirname `locate -be '\mkstore' | xargs ls -1t | grep grid | head -1`) ;
            then echo "BIN=${BIN}"; PATH=${PATH}:${BIN};
            else echo "! mkstore not found !";
            return 0
        fi
    fi

    [ -z "${DBUNAME}" ] && [ -z "${ORACLE_SID}" ] && { echo "ORACLE_SID not set"; return 1; }
    [ -z "${DBUNAME}" ] && DBUNAME=$(srvctl config | grep ${ORACLE_SID:0:8})
    WALLET_PATH=${WALLET_PATH:-/apps/oracle/${DBUNAME}/wallet/shared}
    echo "WALLET_PATH=${WALLET_PATH}"
    #export TNS_ADMIN=${WALLET_PATH}
    #echo "TNS_ADMIN=${TNS_ADMIN}"

    if [ ! -f "${WALLET_PATH}/cwallet.sso" -o ! -f "${WALLET_PATH}/ewallet.p12" ] ; then
#        [ "${action}" == "CMD" ] && \
          echo -e "# Create the Wallet :" #&& \
          [ ! -d "${WALLET_PATH}" ] && echo "=> Create Wallet Directory : ${WALLET_PATH}" || echo "=> Wallet Directory EXIST : ${WALLET_PATH}"
          echo "echo -e \"\${WALLET_PASSWD}\n\${WALLET_PASSWD}\" | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -create"
          #echo "echo -e \"${WALLET_PASSWD}\n${WALLET_PASSWD}\" | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -create"

          [ "${action}" == "SET" ] && (
              [ ! -d "${WALLET_PATH}" ] && if mkdir -p ${WALLET_PATH} ; then echo "Wallet Directory Created : ${WALLET_PATH}"; else echo "Unable to create the Wallet Directory : ${WALLET_PATH}"; fi
              echo -e "${WALLET_PASSWD}\n${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -create
              )

    fi

    [ -z "${WALLET_PASSWD}" ] && read -p "Enter Wallet Password : " -s WALLET_PASSWD
    if [ $(echo "${WALLET_PASSWD}" | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -list | grep -c 'incorrect password') -ne 0 ] ; then echo 'Wrong Wallet password' ; return 1; fi
    COUNT_DFT_CRED=$(orapki wallet display -wallet ${WALLET_PATH:-.} ${WLT_DFT_ARGS} | grep 'oracle.security.client.default' | wc -l)

    if [ "${COUNT_DFT_CRED}" -eq 0 ] ; then
        echo "# Create Default Credentials :"
        #echo "echo \${WALLET_PASSWD} | mkstore -wrl \${WALLET_PATH} \${WLT_DFT_ARGS} -createCredential ${WLT_CONNECT_STRING} ${WLT_USERNAME} ${WLT_PASSWORD}"
        echo "echo \${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -createEntry oracle.security.client.default_username SYS"
        echo "echo \${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -createEntry oracle.security.client.default_password \${SYS_PASSWD}"

        [ "${action}" == "SET" ] && (
            echo ${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -createEntry oracle.security.client.default_username SYS  | grep -v 'Enter wallet password:'
            echo ${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -createEntry oracle.security.client.default_password ${SYS_PASSWD}  | grep -v 'Enter wallet password:'
            ) || return 0
    elif [ "${COUNT_DFT_CRED}" -eq 2 ] ; then
        echo "# Update Default Credentials Password :"
            WLT_SYS_PASSWD=$(echo ${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -viewEntry oracle.security.client.default_password | grep '\.default_password' | awk -F '= ' '{print $NF}')
            if [ "${SYS_PASSWD}" == "${WLT_SYS_PASSWD}" ] ; then
                echo "=> SYS password is identical to the stored wallet password"
                echo "echo \${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -modifyEntry oracle.security.client.default_password \${SYS_PASSWD}"

                [ "${action}" == "SET" ] && [ -n "${FORCE}" ] && (
                  [ "${action}" == "SET" ] && echo ${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -modifyEntry oracle.security.client.default_password ${SYS_PASSWD} | grep -v 'Enter wallet password:'
                ) || return 0
            else
                echo "echo \${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -modifyEntry oracle.security.client.default_password \${SYS_PASSWD}"
                [ "${action}" == "SET" ] && echo ${WALLET_PASSWD} | mkstore -wrl ${WALLET_PATH} ${WLT_DFT_ARGS} -modifyEntry oracle.security.client.default_password ${SYS_PASSWD} | grep -v 'Enter wallet password:'
            fi
    fi
[ -n "${DBG}" ] && set +x
}


# RMARCHMON Resource
function lsarchmon {
  local ORACLE_SID=${1:-$ORACLE_SID}
  ! $(which --skip-alias crsctl >/dev/null 2>&1) && { CSSD_DIR=`dirname $( ps -eo args | grep ocssd.bin | grep -v grep | awk '{print $1}' )`; pathmunge $CSSD_DIR after; }
  #crsctl stat res -w "( NAME coi prc. ) AND ( NAME en .arc )"|grep STATE|cut -d ',' -f1,2|sed 's/STATE=/archmon /';
  crsctl stat res -w "( NAME coi prc.${ORACLE_SID:0:8} ) AND ( NAME en .arc )"
}

function lsarchmon_not_ONLINE {
  ! $(which --skip-alias crsctl >/dev/null 2>&1) && { CSSD_DIR=`dirname $( ps -eo args | grep ocssd.bin | grep -v grep | awk '{print $1}' )`; pathmunge $CSSD_DIR after; }
  crsctl stat res -w "( NAME coi prc. ) AND ( NAME en .arc ) AND (STATE != ONLINE)";
}

function lsarchmon_sum {
  ! $(which --skip-alias crsctl >/dev/null 2>&1) && { CSSD_DIR=`dirname $( ps -eo args | grep ocssd.bin | grep -v grep | awk '{print $1}' )`; pathmunge $CSSD_DIR after; }
  crsctl stat res -w "(NAME coi arc)" | grep STATE | sort | uniq -c
}

function lsarchmon_diff {
  ! $(which --skip-alias crsctl >/dev/null 2>&1) && { CSSD_DIR=`dirname $( ps -eo args | grep ocssd.bin | grep -v grep | awk '{print $1}' )`; pathmunge $CSSD_DIR after; }
  printf "%s || %s\n" "ARCHMON without DB <=" "=> Database without ARCHMON"
  sdiff -s -w50 <(crsctl stat res -w "(NAME coi arc)" -t | grep 'prc.*arc' | cut -d. -f2) <(crsctl stat res -w "( TYPE = ora.database.type )" | grep NAME | cut -d. -f2 | tr '[a-z]' '[A-Z]')
}

function archmon_config_sid {
  local ORACLE_SID=${1:-$ORACLE_SID}
  ! $(which --skip-alias crsctl >/dev/null 2>&1) && { CSSD_DIR=`dirname $( ps -eo args | grep ocssd.bin | grep -v grep | awk '{print $1}' )`; pathmunge $CSSD_DIR after; }

  for _NODE in $(crsctl stat res -w "NAME coi ${ORACLE_SID:0:8}" -p | grep "GEN_USR_ORA_INST_NAME@" | sort -u) ; do
    _CLUSTER_NODE=$(echo ${_NODE} | cut -d"(" -f2 | cut -d")" -f1)
    _INSTANCE=$(echo ${_NODE} | cut -d"=" -f2)
    echo "ssh ${_CLUSTER_NODE} /apps/dbatools/prod/install/ora_setup.ksh -I ${_INSTANCE} -A ARCHMON_CONF,ARCHMON_RESS"
  done
}


## DBMS.TAB
function DBMS_TAB_DIFF {
  printf "%-57s <= || => %s\n" "ORATAB" "DBMS.TAB"
  sdiff -s <(grep -v '#' /etc/oratab|awk -F: '{printf("%8s %s\n",substr($1,0,8),$2);}'|sort -u) <(grep -v '#' /apps/dbatools/etc/dbms.tab|awk -F: '{printf("%8s %s\n",substr($2,0,8),$3);}'|sort -u)
  #grep OB /etc/oratab|awk -F: '{printf("%8s %s\n",substr($1,0,8),$2);}'|sort -u >/tmp/temporatab
  #grep OB /srv/dbatools/etc/dbms.tab|awk -F: '{printf("%8s %s\n",substr($2,0,8),$3);}'|sort -u >/tmp/tempdbmstab
  #diff /tmp/temporatab /tmp/tempdbmstab|grep OB|awk '{print $2}'|sort -u
  #rm /tmp/temporatab /tmp/tempdbmstab
}




## ALIAS COMMON
alias fgdbg='bash -xc '\''echo "0:$0 ; 0-modded:${0#bash} ; 1:$1"'\'''
alias yumrepo="egrep -Hi '(^\[|^enabled)' /etc/yum.repos.d/*"
alias resetenv='env -i PS1="[\u@\h \W]\$ " bash --norc --noprofile'


## ALIAS SYSTEM
alias ls='ls --color=auto'
alias l='ls -ail'
alias ll='ls -al'
alias lt='ls -alt'
alias ltr='ls -altr'
alias ltrh='ls -altrh'
alias lh='ls -alh'
alias lht='ls -alht'
alias lhtr='ls -alhtr'
alias lsinode="ls . -AiR1U | sed -rn '/^[./]/{h;n;}; G; s|^ *([0-9][0-9]*)[^0-9][^/]*([~./].*):|\1:\2|p' | sort -t : -uk1.1,1n | cut -d: -f2 | sort -V | uniq -c | sort -rn | head -n10"
alias duinode="du --inodes --separate-dirs | sort -rh | sed -n '1,50{/^.\{71\}/s/^\(.\{30\}\).*\(.\{37\}\)$/\1...\2/;p}' | sort -r"
alias grep='grep --color=auto'
#alias echopath='echo $PATH | tr : \\n'
alias echopath='echo -e ${PATH//:/\\n}'
alias lspath='echo -e ${PATH//:/\\n}'
alias psg="ps aux | grep -v grep | grep -i"
#alias dmesg='dmesg -H'
alias vim='vim -u ${LIBDIR}/.vimrc'
alias vi=vim
#[ ! -d '/usr/share/vim/vim74' ] && export VIMRUNTIME=${LIBDIR}/share/vim/vim74
[ ! $(ls -d /usr/share/vi[m]/vim[0-9]* 2>/dev/null) ] && { [ -z "${SILENT}" ] && echo "NoVIMruntimes : export VIMRUNTIME=${LIBDIR}/share/vim/vim74"; export VIMRUNTIME=${LIBDIR}/share/vim/vim74; }
alias ssh='ssh -o ServerAliveInterval=30'
alias netbreakdown="netstat -nat | awk '{print $6}' | sort | uniq -c | sort -n"


## ALIAS APPS
alias iperf3_stop='pkill -ecnf "iperf3 -sD"'
alias nmon=${BINDIR}/nmon
alias nmon14g=${BINDIR}/nmon14g_x86_rhel7


## SCREEN
# To avoid error : screen Cannot open your terminal '/dev/pts/0' - please check.
#script /dev/null => bash -c '\''script /dev/null -q -c
#alias screen='screen -h 50000'
## FGR 2022-02-04 : Force the use of the custom screen in case other screen rpm is installed
#alias screen='${BI_PATH}/bin/screen -h 50000'
if ! $(which --skip-alias screen >/dev/null 2>&1); then alias screen='${BI_PATH}/bin/screen -h 50000' else alias screen='screen -h 50000'; fi
alias sc='screen -h 50000'
alias scls='screen -ls'
#alias scls='screen -ls | \grep "${1}"'
alias sclsa='find /var/run/screen/ -type s'
alias sclsa2='screens=(/var/run/screen/S-*/*); echo "${screens[@]#*S-}"'
alias sckill='\screen -ls | grep "(Detached)" | cut -d. -f1 | tr --delete "\t" | xargs echo kill -9; echo \screen -wipe'
alias sckill='find /var/run/screen/ -type s | grep -E "${1:-.}" | sed -E "s:.*/([0-9]+)\..*:\1:g" | tr --delete "\t" | xargs echo kill -9; echo \screen -wipe'
alias sckill='set +m;shopt -s lastpipe; _sckill(){ find /var/run/screen/ -type s | grep -E "${1:-.}" | sed -E "s:.*S-(.*)/([0-9]+)\..*:\1 \2:g" | read _USER _SCID | xargs echo sudo $_USER \screen ls;}; _sckill ; set -m;shopt -u lastpipe'
alias sckill='_f(){ find /var/run/screen/ -type s | grep -E "${1:-.}" | sed -E "s:.*/([0-9]+)\..*:\1:g" | xargs echo kill -9; echo \\screen -wipe ; unset -f _f; }; _f'
#su <user> -c 'screen -wipe'
alias scs='screen -S'
alias scr='screen -r'
alias scx='screen -x'
# Command SCRIPT is used as a workaround when not connected as root : "Cannot open your terminal '/dev/pts/0' - please check."
#alias scr='bash -c '\''script /dev/null -q -c "screen -r ${0#bash}"'\'''
#alias scrd='bash -c '\''script /dev/null -q -c "screen -rd ${0#bash}"'\'''
#alias scx='bash -c '\''script /dev/null -q -c "screen -x ${0#bash}"'\'''
#alias scrx='bash -c '\''script /dev/null -q -c "screen -rx ${0#bash}"'\'''
#alias scs='bash -c '\''script /dev/null -q -c "screen -h 50000 -S ${0#bash}"'\'''

export SCREENRC=${LIBDIR}/.screenrc
# .screenrc
# Enable mouse scroll
#termcapinfo xterm* ti@:te@

# Keep scrollback n lines
#defscrollback 50000

# Enable screen caption
#hardstatus on
#hardstatus alwayslastline

# Forward $STY to screen session after a SUDO
#screen
#screen $SHELL -c 'screen -X caption always "$STY"'
#caption always "%{= kc}Screen session on %H (system load: %l) %-28=%{= .m} %Y-%m-%d %0c"
#caption always "%{= kc}Screen session on %H (system load: %l) %-28=%{= .m} %D %d-%m-%Y %0c"


## TMUX
alias tmux='tmux -f ${LIBDIR}/.tmux.conf'
alias tms='tmux new -s'
alias tma='tmux attach'
alias tmls='tmux ls'
alias tmkill='tmux kill-session -t'
alias tmkillall="tmux ls | grep : | cut -d. -f1 | awk '{print substr($1, 0, length($1)-1)}' | xargs kill"
alias tmkillall2='while [ $? -ne 1 ]; do tmux kill-session; done'


## ANSIBLE
export ANSIBLE_CONFIG=~/ansible/ansible.cfg
ANSIBLE_HOST_KEY_CHECKING=False
export ANSIBLE_REMOTE_USER=root
#export ANSIBLE_INVENTORY=~/ansible/inventory/
#export ANSIBLE_HOST_KEY_CHECKING=False
#export ANSIBLE_LIBRARY=${MYDIR}/../library
#export ANSIBLE_MODULE_UTILS=${MYDIR}/../module_utils
#export ANSIBLE_VAULT_PASSWORD_FILE=~/.vault_pass.txt




#### FUNCTIONS (System)
## Builtin Enhancement
function dufg {
ARG1=${1:-*}
du -sk ./${ARG1} | /usr/bin/sort -n | /usr/bin/awk 'BEGIN{ pref[1]="K"; pref[2]="M"; pref[3]="G";} { total = total + $1; x = $1; y = 1; while( x > 1024 ) { x = (x + 1023)/1024; y++; } printf("%g%s\t%s\n",int(x*10)/10,pref[y],$2); } END { y = 1; while( total > 1024 ) { total = (total + 1023)/1024; y++; } printf("Total: %g%s\n",int(total*10)/10,pref[y]); }'
#du -sk * | awk '{ total = total + $1 } END { print total }'
#ls -l | awk '{sum += $5} END {print sum}'
}


function ts1 {
[ -n "$1" ] && filter="$*" || filter="*"
du -sk ${filter} | sort -n | awk '
     BEGIN {
        split("KB,MB,GB,TB,PB,EB,ZB,YB", Units, ",");
     }
     {
        total = total + $1
        u = 1;
        while ($1 >= 1024) {
           $1 = $1 / 1024;
           u += 1
        }
        $1 = sprintf("%.1f %s", $1, Units[u]);
        print $0;
     }
    END {
      u = 1;
      while (total >= 1024) {
        total = total / 1024;
        u += 1
      }
      printf("\n%.1f %s Total\n", total, Units[u]);
    }
'
}

function ts {
#[ -n "$1" ] && filter="$*" || filter=".[^.]* *"; ## FGR : Former
[ -n "$1" ] && filter="$*" || filter=".[!.]* *"  ## FGR 2025-02-17 : ".[!.]*" to include hidden folders and files
## FGR 2025-02-17 : 2>/dev/null to avoid "du: cannot access '.[!.]*': No such file or directory" when no hidden folder exist
du -sk ${filter} 2>/dev/null | sort -n | awk '
    BEGIN {
      split("KB,MB,GB,TB,PB,EB,ZB,YB", Units, ",");
    }
    {
      total = total + $1
      u = 1;
      while ($1 >= 1024) {
        $1 = $1 / 1024;
        u += 1
      }
      $1 = sprintf("%.1f %s", $1, Units[u]);
      #$3 = system("bash -c '\''stat -c %y "$2"'\''");
      #fdate = system("stat -c %y " $2);
      fdate_cmd="stat -c %y "$2" | cut -d. -f1"
      if (Units[u] != "KB") {fdate_cmd | getline fdate; close(fdate_cmd);} #else {fdate=""}
      #print $0
      #print $1" "fdate"   "$2
      print $0"   "fdate
      #printf("%.1f %s %s %s\n", $1, Units[u], fdate, $2);
    }
    END {
      u = 1;
      while (total >= 1024) {
        total = total / 1024;
        u += 1
      }
      printf("\n%.1f %s Total\n", total, Units[u]);
    }
'
}

## Find big files
#find . -xdev -type f -size +50M -print | xargs ls -lh | sort -k5,5 -h -r | head

alias nbfilebyday="stat -c "%y" * |cut -d' ' -f1|sort|uniq -c"
alias nbhfilebyday="stat -c "%y" * .*|cut -d' ' -f1|sort|uniq -c|tr -d "-""
function sizebyDay { ls -l --time-style=long-iso * | awk '{sum[$6] += $5/1048576;} END { for (date in sum) {printf "%s MB %d\n", date, sum[date];} }' | sort -k1 | column -t ; }
function sizebyDay2 { ls -l --time-style=long-iso * | WHINY_USERS=-9 awk 'END { for (date in sum) printf "%s\t MB %-15d\n", date, sum[date];} { sum[$6] += $5/1048576;}' ; }

## Only files, from current directory only, sorted by date and summed
function sizebyDayf { find ./ -maxdepth 1 -type f -printf '%TY-%Tm-%Td %s\n' | awk '{sum[$1] += $2/1048576;} END { for (date in sum){printf "%-15s MB %d\n", date, sum[date];} }' | sort ; }

## Only files, recursively, sorted by date and summed
function sizebyDayfr { find ./ -type f -printf '%TY-%Tm-%Td %s\n' | awk '{sum[$1] += $2/1048576; total += $2/1048576} END { for (date in sum){printf "%-15s MB %d\n", date, sum[date];} printf "Total MB %d\n", total; }' | sort ; }
function sizebyMonthfr { find ./ -type f -printf '%TY-%Tm %s\n' | awk '{sum[$1] += $2/1048576; total += $2/1048576} END { for (date in sum){printf "%-15s MB %d\n", date, sum[date];} printf "Total MB %d\n", total; }' | sort ; }

#time find -type f -ctime +90 | xargs -ifile du file | cut -d'/' -f1,2 | awk '{sum[$2] += $1/1024; total += $1/1048576} END { for (dir in sum){printf "%-30s MB %d\n", dir, sum[dir];} printf "Total MB %d\n", total; }' | sort -nk3


adGetuserInfo () {
    [ -z "$1" ] && echo Arg 1 is Required && return 1
    getent passwd $1
    [ -n "$2" ] && GREP_GROUP="| grep -i $2" && \
      eval "getent group | grep -i $1 | cut -d: -f1 ${GREP_GROUP}"
}

adGetgroupInfo () {
    [ -z "$1" ] && echo Arg 1 is Required && return 1
    echo $(getent group $1 | cut -d: -f1) GID:$(getent group $1 | cut -d: -f3)
    for aduser in $(getent group $1 | cut -d: -f4 | sed "s/,/\n/g" | sort)
    do
        [ -z "$2" ] && getent passwd $aduser | cut -d: -f1,5
        [ "$2" == "-v" ] && adGetuserInfo $aduser $3
    done
}


nfsgetacl() { nfs4_getfacl "$@" | grep -Ev "OWNER|GROUP|EVERYONE"; };
## NFS ACL : nfs4_setfacl -a A:fd:<uid>:RWX <path>
## FS ACL : setfacl -m u:<user>:rwx <path>



## Locate Enhancement
locd () {
    locate -0 -b -A "$@" | xargs -0 -I {} bash -c '[ -d "{}" ] && echo "{}"'
}

locf () {
    locate -0 -b -A "$@" | xargs -0 -I {} bash -c '[ -f "{}" ] && echo "{}"'
}


function MemRpt {

## https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt
## HugePages_Total is the size of the pool of huge pages.
## HugePages_Free  is the number of huge pages in the pool that are not yet
##                 allocated.
## HugePages_Rsvd  is short for "reserved," and is the number of huge pages for
##                 which a commitment to allocate from the pool has been made,
##                 but no allocation has yet been made.  Reserved huge pages
##                 guarantee that an application will be able to allocate a
##                 huge page from the pool of huge pages at fault time.
## HugePages_Surp  is short for "surplus," and is the number of huge pages in
##                 the pool above the value in /proc/sys/vm/nr_hugepages. The
##                 maximum number of surplus huge pages is controlled by
##                 /proc/sys/vm/nr_overcommit_hugepages.
## Hugepagesize    is the default hugepage size (in Kb).
## Hugetlb         is the total amount of memory (in kB), consumed by huge
##                 pages of all sizes.
##                 If huge pages of different sizes are in use, this number
##                 will exceed HugePages_Total * Hugepagesize. To get more
##                 detailed information, please, refer to
##                 /sys/kernel/mm/hugepages (described below).
## AnonHugePages entry lists the number of pages that the newer Transparent Huge Page mechanism currently has in use

    args=$*
    for argv in $* ; do
        case $argv in
        -h*)     Usage;;
        --csv)   local CSV=1 ; shift 1 ;;
        --int)   local INT=1 ; shift 1 ;;
        --float) local FLOAT=1 ; shift 1 ;;
        *) Usage;;
        #-exemple_1)    export EX=YES ; shift 1 ;;
        #-exemple_2*)    export EX=$2 ;  if [ "$2" = "" ]; then Usage ; else shift 2 ; fi ;;
        esac
    done

    [ -z "${INT}" -a -z "${FLOAT}" ] && local FLOAT=1
    [ -n "${FLOAT}" ] && local BC_SCALE='scale=2; '
    #[ -n "${CSV}" ] && stty flusho

    local MEM_TOTAL_GB=$(free -g | grep Mem | awk '{print $2}')
    local MEM_USED_GB=$(free -g | grep Mem | awk '{print $3}')
    local MEM_FREE_GB=$(free -g | grep Mem | awk '{print $4}')
    local MEM_CACHE_GB=$(free -g | grep Mem | awk '{print $6}')
    local MEM_AVAIL_GB=$(free -g | grep Mem | awk '{print $7}')
    local SWAP_TOTAL_GB=$(free -g | grep Swap | awk '{print $2}')
    local SWAP_USED_GB=$(free -g | grep Swap | awk '{print $3}')
    local SWAP_FREE_GB=$(free -g | grep Swap | awk '{print $4}')

    echo "Memory_Total GB : ${MEM_TOTAL_GB}"
    echo "Memory_Used  GB : ${MEM_USED_GB}"
    echo "Memory_Free  GB : ${MEM_FREE_GB}"
    echo "Memory_Cache GB : ${MEM_CACHE_GB}"
    echo "Memory_Avail GB : ${MEM_AVAIL_GB}"
    echo "Swap_Total GB : ${SWAP_TOTAL_GB}"
    echo "Swap_Used  GB : ${SWAP_USED_GB}"
    echo "Swap_Free  GB : ${SWAP_FREE_GB}"

    local PAGE_SIZE=$(getconf PAGE_SIZE)
    local SHMALL=$(cat /proc/sys/kernel/shmall)

    if [ "${INT}" == "1" ]; then
    local SHM_LIMIT_GB=$(( ${PAGE_SIZE} * ${SHMALL} / 1073741824 ))
    local SHM_USED_GB=$(ipcs -m | grep oracle | awk '{sum += $5} END {printf "%.0f", sum/1073741824}')
    local SHM_FREE_GB=$(( ${SHM_LIMIT_GB} - ${SHM_USED_GB} ))
    elif [ "${FLOAT}" == "1" ]; then
    local SHM_LIMIT_GB=$(echo "${BC_SCALE} ${PAGE_SIZE} * ${SHMALL} / 1073741824" | bc)
    local SHM_USED_GB=$(ipcs -m | grep oracle | awk '{sum += $5} END {printf "%.0f", sum/1073741824}')
    local SHM_FREE_GB=$(echo "${BC_SCALE} ${SHM_LIMIT_GB} - ${SHM_USED_GB}" | bc)
    fi
    echo "Shared_Memory_Limit GB : ${SHM_LIMIT_GB}"
    echo "Shared_Memory_Used  GB : ${SHM_USED_GB}"
    echo "Shared_Memory_Free  GB : ${SHM_FREE_GB}"

    local HPG_SIZE=$(grep Hugepagesize /proc/meminfo | awk '{print $2}')
    local HPG_TOTAL=$(grep HugePages_Total /proc/meminfo | awk '{print $2}')
    local HPG_FREE=$(grep HugePages_Free /proc/meminfo | awk '{print $2}')
    local HPG_RSVD=$(grep HugePages_Rsvd /proc/meminfo | awk '{print $2}')

    if [ "${INT}" == "1" ]; then
    local HPG_TOTAL_GB=$(( ${HPG_SIZE} * ${HPG_TOTAL} / 1048576 ))
    local HPG_RAWUSED_GB=$(( ${HPG_SIZE} * (${HPG_TOTAL} - ${HPG_FREE}) / 1048576 ))
    local HPG_RAWFREE_GB=$(( ${HPG_SIZE} * ${HPG_FREE} / 1048576 ))
    local HPG_RSVD_GB=$(( ${HPG_SIZE} * ${HPG_RSVD} / 1048576 ))
    local HPG_USED_GB=$(( ${HPG_SIZE} * (${HPG_TOTAL} - ${HPG_FREE} + ${HPG_RSVD}) / 1048576 ))
    local HPG_FREE_GB=$(( ${HPG_SIZE} * (${HPG_FREE} - ${HPG_RSVD}) / 1048576 ))
    local HPG_USED_PERCENT=$(( ${HPG_USED_GB} * 100 / ${HPG_TOTAL_GB} ))
    local HPG_FREE_PERCENT=$(( ${HPG_FREE_GB} * 100 / ${HPG_TOTAL_GB} ))
    elif [ "${FLOAT}" == "1" ]; then
    local HPG_TOTAL_GB=$(echo "${BC_SCALE} ${HPG_SIZE} * ${HPG_TOTAL} / 1048576" | bc)
    local HPG_RAWUSED_GB=$(echo "${BC_SCALE} ${HPG_SIZE} * (${HPG_TOTAL} - ${HPG_FREE}) / 1048576" | bc)
    local HPG_RAWFREE_GB=$(echo "${BC_SCALE} ${HPG_SIZE} * ${HPG_FREE} / 1048576" | bc)
    local HPG_RSVD_GB=$(echo "${BC_SCALE} ${HPG_SIZE} * ${HPG_RSVD} / 1048576" | bc)
    local HPG_USED_GB=$(echo "${BC_SCALE} ${HPG_SIZE} * (${HPG_TOTAL} - ${HPG_FREE} + ${HPG_RSVD}) / 1048576" | bc)
    local HPG_FREE_GB=$(echo "${BC_SCALE} ${HPG_SIZE} * (${HPG_FREE} - ${HPG_RSVD}) / 1048576" | bc)
    local HPG_USED_PERCENT=$(echo "${BC_SCALE}  ${HPG_USED_GB} * 100 / ${HPG_TOTAL_GB}" | bc)
    local HPG_FREE_PERCENT=$(echo "${BC_SCALE} ${HPG_FREE_GB} * 100 / ${HPG_TOTAL_GB}" | bc)
    fi

    echo "HugePages_Total   GB : ${HPG_TOTAL_GB}"
    echo "HugePages_RawUsed GB : ${HPG_RAWUSED_GB}"
    echo "HugePages_RawFree GB : ${HPG_RAWFREE_GB}"
    echo "HugePages_Rsvd    GB : ${HPG_RSVD_GB}"
    echo "HugePages_Used    GB : ${HPG_USED_GB}"
    echo "HugePages_Free    GB : ${HPG_FREE_GB}"
    echo "HugePages_Used     % : ${HPG_USED_PERCENT}"
    echo "HugePages_Free     % : ${HPG_FREE_PERCENT}"

    if [ "${INT}" == "1" ]; then
    local MEM_FREE_GDTOTAL=$(( ${MEM_AVAIL_GB} + ${HPG_FREE_GB} ))
    local MEM_USED_GDTOTAL_PERCENT=$(( (${MEM_USED_GB} - ${HPG_TOTAL_GB} + ${HPG_USED_GB}) * 100 / ${MEM_TOTAL_GB} ))
    local MEM_FREE_GDTOTAL_PERCENT=$(( (${MEM_AVAIL_GB} + ${HPG_FREE_GB}) * 100 / ${MEM_TOTAL_GB} ))
    elif [ "${FLOAT}" == "1" ]; then
    local MEM_FREE_GDTOTAL=$(echo "${BC_SCALE} ${MEM_AVAIL_GB} + ${HPG_FREE_GB}" | bc)
    local MEM_USED_GDTOTAL_PERCENT=$(echo "${BC_SCALE} (${MEM_USED_GB} - ${HPG_TOTAL_GB} + ${HPG_USED_GB}) * 100 / ${MEM_TOTAL_GB}" | bc)
    local MEM_FREE_GDTOTAL_PERCENT=$(echo "${BC_SCALE} (${MEM_AVAIL_GB} + ${HPG_FREE_GB}) * 100 / ${MEM_TOTAL_GB}" | bc)
    fi

    echo "Memory_Grand_Total_Free  GB : ${MEM_FREE_GDTOTAL} / ${MEM_TOTAL_GB}"
    echo "Memory_Grand_Total_Used  %  : ${MEM_USED_GDTOTAL_PERCENT}"
    echo "Memory_Grand_Total_Free  %  : ${MEM_FREE_GDTOTAL_PERCENT}"

    #[ -n "${CSV}" ] && stty -flusho
    #[ "${1^^}" == "CSV" ] && 
    [ "${CSV}" == "1" ] && echo "$(date "+%d/%m/%Y"),$(hostname -s),${MEM_FREE_GDTOTAL}" || return 0
}


function hugepages_calculator {
#!/bin/bash
#
# hugepages_setting.sh
#
# Linux bash script to compute values for the
# recommended HugePages/HugeTLB configuration
#
# Note: This script does calculation for all shared memory
# segments available when the script is run, no matter it
# is an Oracle RDBMS shared memory segment or not.
# Check for the kernel version
KERN=`uname -r | awk -F. '{ printf("%d.%d\n",$1,$2); }'`
# Find out the HugePage size
HPG_SZ=`grep Hugepagesize /proc/meminfo | awk {'print $2'}`
# Start from 1 pages to be on the safe side and guarantee 1 free HugePage
NUM_PG=1
# Cumulative number of pages required to handle the running shared memory segments
for SEG_BYTES in `ipcs -m | awk {'print $5'} | grep "[0-9][0-9]*"`
do
   MIN_PG=`echo "$SEG_BYTES/($HPG_SZ*1024)" | bc -q`
   if [ $MIN_PG -gt 0 ]; then
      NUM_PG=`echo "$NUM_PG+$MIN_PG+1" | bc -q`
   fi
done
# Finish with results
case $KERN in
   '2.4') HUGETLB_POOL=`echo "$NUM_PG*$HPG_SZ/1024" | bc -q`;
          echo "Recommended setting : vm.hugetlb_pool = $HUGETLB_POOL" ;;
   '2.6' | '3.8' | '3.10' | '4.1' | '4.14' ) echo "Recommended setting : vm.nr_hugepages = $NUM_PG" ;;
    *) echo "Unrecognized kernel version $KERN. Exiting." ;;
esac

echo "Current HugePages Allocated : 2K hugepages = " $(cat /proc/sys/vm/nr_hugepages)
# End
}


function pshugepage {
  HUGEPAGECOUNT=0
  for num in $(grep 'anon_hugepage.*dirty=' /proc/$@/numa_maps | awk '{print $6}' | sed 's/dirty=//') ; do
    HUGEPAGECOUNT=$((HUGEPAGECOUNT+num))
  done
  echo "NUMA_MAPS : Process $@ using $(( ${HUGEPAGECOUNT} * 2048 / 1048576 )) GB of HugePages : (${HUGEPAGECOUNT} HugePages)"

  HP_SMAPS_GB=$(grep -B 11 'KernelPageSize: *2048 kB' /proc/$@/smaps | grep "^Size:" | awk 'BEGIN{sum=0}{sum+=$2}END{print sum/1048576}')
  printf "SMAPS     : Process $@ using %.2f GB of HugePages\n" "${HP_SMAPS_GB}"
}


function ethlink {
  for i in 1 2 3 4 ; do echo "=== eth$i === : $(ethtool eth$i 2>&1 | egrep "Speed|Duplex|Link|Auto" | grep -Ev 'Unknown|Operation not permitted' | paste -s -)" ; done
}


function EXA_TEST_FLUX {
  if [ ! -z "${1}" ] ; then
    EXA_CNVG_TO_TEST="${1}"
    unset EXA_CNVG_HPR EXA_CNVG_BCH EXA_CNVG_PRD
  else
    EXA_CNVG_HPR="## ANONYMIZED BI ##" ; ENDPOINT_PORT=10198
    EXA_CNVG_BCH="## ANONYMIZED BI ##" ; ENDPOINT_PORT=10198
    EXA_CNVG_PRD="## ANONYMIZED BI ##" ; ENDPOINT_PORT=10098
  fi
  
  #unset EXA_LIST
  for EXA_LIST in $(set | grep '^EXA_CNVG_' | cut -d= -f1); do 
    echo "${EXA_LIST}=${!EXA_LIST}"
    for EXA_LIST_ITEM in $(echo "${!EXA_LIST}"); do
      [[ $(echo "${EXA_LIST_ITEM}" | cut -c3) =~ ['p'] ]] && { ENDPOINT_SCAN_PORT=10098 ; ENDPOINT_VIP_PORT=10095 ; } || { ENDPOINT_SCAN_PORT=10198 ; ENDPOINT_VIP_PORT=10195 ; }
      echo -e "\n#### Testing flows for SCAN on port '${ENDPOINT_SCAN_PORT}' : ${EXA_LIST_ITEM}"
      for endpoint_scan in $(nslookup ${EXA_LIST_ITEM} | awk '/Address: [0-9]/{print $2}'); do echo "=> Testing : ${endpoint_scan}:${ENDPOINT_SCAN_PORT}" ; nc -vzw1 ${endpoint_scan} ${ENDPOINT_SCAN_PORT} 2>&1   ; done
      echo -e "\n#### Testing flows for VIP '${ENDPOINT_VIP_PORT}' : $(echo "${EXA_LIST_ITEM}" | sed -E 's:(^c)(.*)(.-scan):s\2\[1-4]-vip:g')"
      for endpoint_vip in $(echo "${EXA_LIST_ITEM}" | sed -E 's:(^c)(.*)(.-scan):s\2\$i-vip:g') ; do for i in {1..4} ; do echo "=> Testing : $(eval echo $endpoint_vip):${ENDPOINT_VIP_PORT}"; nc -vzw1 $(eval echo $endpoint_vip) ${ENDPOINT_VIP_PORT} 2>&1 | grep -vE 'Version|bytes'; done ; done
    done
  done
  
  echo
  echo "Understanding the output :"
  echo "If Ncat result is 'Connected' or 'Connection refused' the flow is OPEN"
  echo "If Ncat result is 'TIMEOUT' the flow is CLOSE"
}


## BASH COMPLETION
# .inputrc
bind 'set completion-query-items 300'
#bind 'set print-completions-horizontally off'
#set rl_completion_query_items 1000

#bind 'set mark-directories on'
#bind 'set mark-symlinked-directories on'
#bind 'set page-completions off'
#bind 'set show-all-if-ambiguous on'
#bind 'set visible-stats on'

#alias oenv='bash -xc '\''script /dev/null -q -c "export ORAENV_ASK=NO;  export ORACLE_SID=$0; source /usr/local/bin/oraenv; echo ${ORACLE_SID}:${ORACLE_HOME}"'\'''
#alias oenv='script /dev/null -q -c "echo export ORAENV_ASK=NO;  export ORACLE_SID=$0; source /usr/local/bin/oraenv; echo ${ORACLE_SID}:${ORACLE_HOME}"'

## FUNCTIONS COMPLETION
oenv() {
    ORAENV_ASK=NO
    ORACLE_SID=$1
    . oraenv >/dev/null
    echo ${ORACLE_SID}:${ORACLE_HOME}
    unset ORAENV_ASK
    # OR #ORAENV_ASK=YES . oraenv <<<${1} 1>/dev/null

    ## FGR : To reload some alias
    fgenv -s
}
export -f oenv


_word_list_instance() {
## FGR 2023-11-06 : PGREG is Faster than PS
#  [ -z "${word_list_instance}" ] && word_list_instance=$(ps -eo args | grep pm[o]n | grep -v APX | cut -d'_' -f3- | cut -c1-10)
  [ -z "${word_list_instance}" -o "${RELOAD}" = "TRUE" ] && word_list_instance=$(pgrep -a pmon | grep -v APX | cut -d'_' -f3- | cut -c1-10)
#  [ -z "${word_list_dbname}" ] && word_list_dbname=$(ps -eo args | grep pm[o]n | grep -v APX | cut -d'_' -f3- | cut -c1-8)
#  [ -z "${word_list_dbname}" ] && word_list_dbname=$(pgrep -a pmon | grep -v APX | cut -d'_' -f3- | cut -c1-8)
  [ -f "${SCRIPT_DIR}/ora/env/init.allow" ] && word_list_bisudo=$(grep "^[^#|^$|^ *$]" ${SCRIPT_DIR}/ora/env/init.allow 2>/dev/null | cut -d' ' -f2 | uniq)
}
_word_list_instance


_ora_completion() {
    local cur prev ante
    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}
    ante=${COMP_WORDS[COMP_CWORD-2]}
    first=${COMP_WORDS[0]}
    array_scripts=$(ls -p ${SCRIPT_DIR} | grep -E 'ora_|vtom_|expl_' | grep -v '/')
#    array_scripts=$(grep "^[^#|^$|^ *$]" ${SCRIPT_DIR}/ora/env/init.allow | cut -d' ' -f2 | uniq -u)
#    array_scripts_args=( "${array_scripts[@]//ora_shell.sh}" )

    #word_list=$(cat /etc/oratab | cut -d':' -f1 | grep -v '#')
    #word_list=$(crsctl status resource -w "TYPE = ora.database.type" -p|grep USR_ORA_INST_NAME|sed "s:.*=::"|sort -u)
    #word_list=$(grep -v -e "^#\|^ \|^$" /etc/oratab | cut -f1 -d: | paste -sd " " -)
    #word_list=$(grep -v -e "^#\|^ \|^$" /etc/oratab | cut -f1 -d: | grep "$(ps -eo args | grep pm[o]n | cut -d'_' -f3- | cut -c1-10)" | paste -sd " " -)
#    word_list_instance=$(ps -eo args | grep pm[o]n | grep -v APX | cut -d'_' -f3- | cut -c1-10)
    [[ "${prev}" =~ "oenv" ]] && [ -z "${word_list_instance}" ] && word_list_instance=$(pgrep -a pmon | grep -v APX | cut -d'_' -f3- | cut -c1-10)
#    word_list_dbname=$(ps -eo args | grep pm[o]n | grep -v APX | cut -d'_' -f3- | cut -c1-8)
    [[ "${prev}" =~ "sudo" ]] && [ -z "${word_list_dbname}" ] && word_list_dbname=$(pgrep -a pmon | grep -v APX | cut -d'_' -f3- | cut -c1-8)
#    word_list_bisudo=$(grep "^[^#|^$|^ *$]" ${SCRIPT_DIR}/ora/env/init.allow 2>/dev/null | cut -d' ' -f2 | uniq)
    #word_list_scripts=$(ls -p ${SCRIPT_DIR} | grep -v '/')
    word_list_tns=$(grep '^[^ ].*=$' ${SCRIPT_DIR}/ora/wallet_infra/tnsnames.ora 2>/dev/null | cut -d= -f1)

    [ -n "${DEBUG}" ] && echo "0=$0 1=$1 cur=$cur prev=$prev ante=$ante first=$first" #array_scripts="${array_scripts[@]}""

    [[ "${prev}" =~ "oenv" ]] && COMPREPLY=( $(compgen -W "${word_list_instance}" -- $cur) ) && return
    [[ "${prev}" =~ "bisudo" ]] && COMPREPLY=( $(compgen -W "${word_list_bisudo}" -- $cur) ) && return
    [[ "${1}" == "sudo" ]] && [[ "${prev}" =~ "oracle" ]] && COMPREPLY=( $(compgen -W "${word_list_bisudo}" -- $cur) ) && return
    [[ "${1}" == "sudo" ]] && [[ "${array_scripts[@]}" =~ "${prev}" ]] && COMPREPLY=( $(compgen -W "${word_list_dbname}" -- $cur) ) && return
#    [[ "${array_scripts[@]}" =~ "${prev}" ]] && COMPREPLY=( $(compgen -W "${word_list_dbname}" -- $cur) ) && return
#    [[ "${array_scripts[@]}" =~ "${prev}" ]] && COMPREPLY=( $(compgen -W "-d" -- $cur) ) && return
#    [[ "${array_scripts[@]}" =~ "${ante}" && "${prev}" == "-d" ]] && COMPREPLY=( $(compgen -W "${word_list_dbname}"
    [[ $(grep -c -w -x "${prev//-/}" <<< "${array_scripts[@]}") == 1 ]] && COMPREPLY=( $(compgen -W "-d" -- $cur) ) && return
    [[ $(grep -c -w -x "${ante//-/}" <<< "${array_scripts[@]}") == 1 && "${prev}" == "-d" ]] && COMPREPLY=( $(compgen -W "${word_list_dbname}" -- $cur) ) && return
    [[ "${prev}" == "-db"  || "${prev}" == "-d" ]] && COMPREPLY=( $(compgen -W "${word_list_dbname}" -- $cur) ) && return
    [[ "${1}" =~ "sqlplus" ]] && [[ "${prev}" == "@" ]] && COMPREPLY=( $(compgen -W "${word_list_tns}" -- $cur) ) && return

    ## If nothing matched
    #[ ${#COMPREPLY[@]} == 0 ] && COMPREPLY=( $(compgen -W "${word_list_dbname}" -- ${cur}) ) && return
    #COMPREPLY=( $(compgen -W "${word_list}" -- ${cur}) )
}
complete -F _ora_completion oenv rlsqlplus
complete -F _ora_completion sqlplus srvctl exp expdp imp impdp
#complete -F _ora_completion ora_sql.sh ora_dgmgrl.sh ora_rman.sh ora_rman_backup.sh ora_rman_config.sh ora_status_instance.sh ora_status_backup.sh
#complete -F _ora_completion sql.sh dgmgrl.sh rman.sh rman_backup.sh rman_config.sh rman_config_to_tape.sh status_instance.sh status_backup.sh
[ -x "${SCRIPT_DIR}" ] && complete -F _ora_completion $(ls -p ${SCRIPT_DIR} | grep -v '/' | grep '.sh$')
#complete -F _ora_completion $(ls -p /oracle/exploit | grep -v '/' | grep '.sh$' ; ls -p /oracle/scripts | grep -v '/' | grep '.sh$')
#complete -D -F _ora_completion oralisthome -o bashdefault -o nospace -o default

## FG : Allow "sudo" to complete
#complete -cf sudo


_listener_completion() {
    COMPREPLY=()
    local cur="${COMP_WORDS[COMP_CWORD]}"
    word_list=$(ps -eo "cmd" | grep l[s]n | cut -d' ' -f2 | paste -sd " " -)
    COMPREPLY=( $(compgen -W "${word_list}" -- ${cur}) )
}

complete -F _listener_completion lsnrctl lsn


_example_complete()
{
    local cur_word prev_word word_list
# COMP_WORDBREAKS+==

    # COMP_WORDS is an array of words in the current command line.
    # COMP_CWORD is the index of the current word (the one the cursor is
    # in). So COMP_WORDS[COMP_CWORD] is the current word; we also record
    # the previous word here, although this specific script doesn't
    # use it yet.
    cur_word="${COMP_WORDS[COMP_CWORD]}"
    prev_word="${COMP_WORDS[COMP_CWORD-1]}"

    # Generate a list words
    word_list=`ps -ef|grep pm[o]n | cut -d_ -f3`

    # Only perform completion if the current word starts with a dash ('-'),
    # meaning that the user is trying to complete an option.
#    if [[ -n ${cur_word} ]] ; then
        # COMPREPLY is the array of possible completions, generated with
        # the compgen builtin.
        COMPREPLY=( $(compgen -W "${word_list}" -- ${cur_word}) )
#    else
#        COMPREPLY=()
#    fi
    return 0
}

# Register _example_complete to provide completion for the following commands
complete -F _example_complete oraup


## BASH COMMAND TIMER
# https://github.com/jichu4n/bash-command-timer
BCT_ENABLE=1
BCT_SUCCESS_COLOR='32'
BCT_ERROR_COLOR='91'
#BCT_TIME_FORMAT='%b %d %I:%M%p'
BCT_TIME_FORMAT='%a %b %d %H:%M:%S'
BCT_MILLIS=1
BCT_WRAP=0
# FGR : Print the clock to the LEFT or RIGHT
BCT_PRINT=LEFT

if date +'%N' | grep -qv 'N'; then
  BCTTime="date '+%s%N'"
  function BCTPrintTime {
    date --date="@$1" +"$BCT_TIME_FORMAT"
  }
elif hash gdate 2>/dev/null && gdate +'%N' | grep -qv 'N'; then
  BCTTime="gdate '+%s%N'"
  function BCTPrintTime {
    gdate --date="@$1" +"$BCT_TIME_FORMAT"
  }
elif hash perl 2>/dev/null; then
  BCTTime="perl -MTime::HiRes -e 'printf(\"%d\",Time::HiRes::time()*1000000000)'"
  function BCTPrintTime {
    date -r "$1" +"$BCT_TIME_FORMAT"
  }
else
  echo 'No compatible date, gdate or perl commands found, aborting'
  exit 1
fi

BCT_AT_PROMPT=1
function BCTPreCommand {
  local EXIT="$?"
  if [ $EXIT == 0 ]
  then
    # colour for exit without error
    BCT_COLOR=$BCT_SUCCESS_COLOR
  else
    # colour for exit with error
    BCT_COLOR=$BCT_ERROR_COLOR
  fi
  if [ -z "$BCT_AT_PROMPT" ]; then
    return
  fi
  unset BCT_AT_PROMPT
  BCT_COMMAND_START_TIME=$(eval $BCTTime)
}
trap 'BCTPreCommand' DEBUG

# Bash will automatically set COLUMNS to the current terminal width.
export COLUMNS

# Flag to prevent printing out the time upon first login.
BCT_FIRST_PROMPT=1
# This is executed before printing out the prompt.
function BCTPostCommand {
  BCT_AT_PROMPT=1

  if [ -n "$BCT_FIRST_PROMPT" ]; then
    unset BCT_FIRST_PROMPT
    return
  fi

  if [ -z "$BCT_ENABLE" ] || [ $BCT_ENABLE -ne 1 ]; then
    return
  fi

  # BCTTime prints out time in nanoseconds.
  local MSEC=1000000
  local SEC=$(($MSEC * 1000))
  local MIN=$((60 * $SEC))
  local HOUR=$((60 * $MIN))
  local DAY=$((24 * $HOUR))

  local command_start_time=$BCT_COMMAND_START_TIME
  local command_end_time=$(eval $BCTTime)
  local command_time=$(($command_end_time - $command_start_time))
  local num_days=$(($command_time / $DAY))
  local num_hours=$(($command_time % $DAY / $HOUR))
  local num_mins=$(($command_time % $HOUR / $MIN))
  local num_secs=$(($command_time % $MIN / $SEC))
  local num_msecs=$(($command_time % $SEC / $MSEC))
  local time_str=""
  if [ $num_days -gt 0 ]; then
    time_str="${time_str}${num_days}d "
  fi
  if [ $num_hours -gt 0 ]; then
    time_str="${time_str}${num_hours}h "
  fi
  if [ $num_mins -gt 0 ]; then
    time_str="${time_str}${num_mins}m "
  fi
  local num_msecs_pretty=''
  if [ -n "$BCT_MILLIS" ] && [ $BCT_MILLIS -eq 1 ]; then
    local num_msecs_pretty=$(printf '%03d' $num_msecs)
  fi
  time_str="${time_str}${num_secs}s${num_msecs_pretty}"
  now_str=$(BCTPrintTime $(($command_end_time / $SEC)))
  if [ -n "$now_str" ]; then
    local output_str="[ $time_str | $now_str ]"
  else
    local output_str="[ $time_str ]"
  fi
  if [ -n "$BCT_COLOR" ]; then
    local output_str_colored="\033[${BCT_COLOR}m${output_str}\033[0m"
  else
    local output_str_colored="${output_str}"
  fi
  # Trick to make sure the output wraps to the next line if there is not
  # enough room for the string (only when BCT_WRAP == 1)
  if [ -n "$BCT_WRAP" ] && [ $BCT_WRAP -eq 1 ]; then
    # we'll print as many spaces as characters exist in output_str, plus 2
    local wrap_space_prefix="${output_str//?/ }  "
  else
    local wrap_space_prefix=""
  fi

  # Move to the end of the line. This will NOT wrap to the next line
  # unless you have BCT_WRAP == 1
  # FGR : Print the clock to the left or right
  if [ -n "$BCT_PRINT" ] && [ $BCT_PRINT = "RIGHT" ]; then
    echo -ne "$wrap_space_prefix\033[${COLUMNS}C"
  elif [ -n "$BCT_PRINT" ] && [ $BCT_PRINT = "LEFT" ]; then
    #echo -ne "$wrap_space_prefix"
    [ -n "$BCT_WRAP" ] && [ $BCT_WRAP -eq 0 ] \
      && echo -ne "$wrap_space_prefix\033[${#output_str}C" \
      || echo -ne "$wrap_space_prefix"
  fi
  # Move back (length of output_str) columns.
  echo -ne "\033[${#output_str}D"
  # Finally, print output.
  echo -e "${output_str_colored}"
}
PROMPT_COMMAND='BCTPostCommand'
## END - BASH COMMAND TIMER


## Print a clock
function prompt_command {
  let prompt_x=$COLUMNS-6
  PROMPT_COMMAND=prompt_command
}

function print_clock {
[ -n "${DBG}" ] && set -x || set +x
  local       BLUE="\[\033[0;34m\]"
  local        RED="\[\033[0;31m\]"
  local  LIGHT_RED="\[\033[1;31m\]"
  local      WHITE="\[\033[1;37m\]"
  local  NO_COLOUR="\[\033[0m\]"
  case $TERM in
    xterm*) TITLEBAR='\[\033]0;\u@\h:\w\007\]' ;;
    *) TITLEBAR="" ;;
  esac

  PS1_CURRENT=${PS1}
  PS1="${TITLEBAR}\
\[\033[s\033[1;\$(echo -n \${prompt_x})H\]\
$BLUE[$LIGHT_RED\$(date +%Hh%M)$BLUE]\
\[\033[u\033[1A\]\
${PS1_CURRENT}"
#$BLUE[$LIGHT_RED\u@\h:\w$BLUE]\
#$WHITE\$$NO_COLOUR "
[ -n "${DBG}" ] && set +x
}
## END - Print a clock


function sudo_function {
export -f $1
su $2 -c "bash -c $1"
}


function highlight {
    declare -A fg_color_map
    fg_color_map[black]=30
    fg_color_map[red]=31
    fg_color_map[green]=32
    fg_color_map[yellow]=33
    fg_color_map[blue]=34
    fg_color_map[magenta]=35
    fg_color_map[cyan]=36

    fg_c=$(echo -e "\e[1;${fg_color_map[$1]}m")
    c_rs=$'\e[0m'
    sed -u s"/$2/$fg_c\0$c_rs/g"
}
#export -f highlight


alias listdbprmy='dbinfo | grep Open | grep $(hostname -s) | cut -d'.' -f2 | tr "[:lower:]" "[:upper:]"'
# CUT --complement
#LIST_INSTANCE=GCETSTX01,GCETSTX02,GCETSTX03
#echo $LIST_INSTANCE | cut -d',' --complement -f1




#### FG : TODO ####

### FUNCTIONS : TODO
function ORA_CNX_TEST {
## Check Instances connection
# All instances
pgrep -af _pmon_ | grep -v '+A' | sort -k2 | awk -F'_' '{ print $NF }' | \
 xargs -P10 -Idbsid sh -c '. oraenv<<<dbsid >/dev/null 2>&1 ; echo "${ORACLE_SID} $(printf "%-18s" `echo "${ORACLE_HOME}" | sed -E "s:.*/([0-9]*)\.([0-9]*)\.([0-9]*)\.([0-9]*)\.([0-9]*).*:\(\1.\2.\3.\4.\5\):"`;) `TEST_DB_CNX_OUT=$(echo -e "WHENEVER SQLERROR EXIT SQL.SQLCODE;\nconnect / as sysdba" | sqlplus -S -L /nolog) && echo "RC=$? : CNX OK" || echo "RC=$? : CNX KO : $(echo -n ${TEST_DB_CNX_OUT})"`"' | grep --color -Ei '^|CNX KO|ERROR|ORA-.*'
# xargs -P10 -Idbsid sh -c '. oraenv<<<dbsid >/dev/null 2>&1 ; printf "%10s %18s => %-6s %s %s %s %s %s %s %s %s %s %s\n" ${ORACLE_SID} `echo "${ORACLE_HOME}" | sed -E "s:.*/([0-9]*)\.([0-9]*)\.([0-9]*)\.([0-9]*)\.([0-9]*).*:\(\1.\2.\3.\4.\5\):"` `TEST_DB_CNX_OUT=$(echo -e "WHENEVER SQLERROR EXIT SQL.SQLCODE;\nconnect / as sysdba" | sqlplus -S -L /nolog) && echo "RC=$? : CNX OK" || echo "RC=$? : CNX KO : $(echo -n ${TEST_DB_CNX_OUT})"`' | grep --color -Ei '^|CNX KO|ERROR|ORA-.*' 
# xargs -P10 -Idbsid sh -c '. oraenv<<<dbsid >/dev/null 2>&1 ; echo ${ORACLE_SID} \(`echo "${ORACLE_HOME}" | sed -E "s:.*/([0-9]*)\.([0-9]*)\.([0-9]*)\.([0-9]*)\.([0-9]*).*:\1.\2.\3.\4.\5:"`\) : `echo -e "WHENEVER SQLERROR EXIT SQL.SQLCODE;\nselect * from dual;" | sqlplus -s / as sysdba >/dev/null 2>&1; [ "$?" = "0"  ] && echo "RC=$? : CNX OK" || echo "RC=$? : CNX KO"`' | grep --color -Ei '^|CNX KO'


# Per version
#ORA_VER=19.22
#pgrep -af _pmon_ | grep -v '+A' | sort -k2 | while read pid pname ; do echo ${pname#???_pmon_} $(sudo ls -l /proc/$pid/exe | awk -F'>' '{ print $2 }' | sed 's/bin\/oracle$//'); done | grep "${ORA_VER:-|NA|}" | awk '{print $1}' | \
# xargs -P10 -Idbsid sh -c '. oraenv<<<dbsid >/dev/null 2>&1 ; echo "${ORACLE_SID} $(printf "%-18s" `echo "${ORACLE_HOME}" | sed -E "s:.*/([0-9]*)\.([0-9]*)\.([0-9]*)\.([0-9]*)\.([0-9]*).*:\(\1.\2.\3.\4.\5\):"`;) `TEST_DB_CNX_OUT=$(echo -e "WHENEVER SQLERROR EXIT SQL.SQLCODE;\nconnect / as sysdba" | sqlplus -S -L /nolog) && echo "RC=$? : CNX OK" || echo "RC=$? : CNX KO : $(echo -n ${TEST_DB_CNX_OUT})"`"' | grep --color -Ei '^|CNX KO|ERROR|ORA-.*'
}


function SQL_PROCESS {
echo $1
SQL=$(cat <<-EOF
echo -e $1
EOF
)
echo SQL=$SQL
}

mount_point_of() {
  f=$(readlink -m -- "$1") &&
    until mountpoint -q -- "$f"; do
      f=${f%/*}; f=${f:-/}
    done &&
    printf '%s\n' "$f"
}

function SendMail {
	STATUS=$1
	COMMENT=$2
	hostname | grep prdres && ENV=PRD
	hostname | grep intres && ENV=HPR

	MAIL_FILE=Report_Mail.msg
	MAIL_FROM=ANSIBLE_${ENV}_$(hostname -s)
	[ "${ENV}" == "HPR" ] && MAIL_TO=<my_email> || MAIL_TO=<goup_email>
	MAIL_SUBJECT="[ANSIBLE][${ENV}] Deploiement des scripts du GIT en environnement \"${ENV}\""
	#LOG_CONTENTS_FILE=$( awk 'BEGIN{print "<div>"} {print "<br>";for(i=1;i<=NF;i++)print $i;} END{print "</div>"}' < <(tail -10 ~/${LOG_FILE}) )
	#LOG_CONTENTS_FILE=$( while read line; do BLINE="<b>$(cut -d: -f1<<<${line}) :</b>"; ELINE="$(cut -d: -f2-<<<${line})";  echo "<br>${BLINE}${ELINE}"; done < <(tail -10 ~/${LOG_FILE}) )
	#LOG_CONTENTS_FILE=$( while read line; do echo "${line}"; done < <(tail -10 ~/${LOG_FILE}) )

#Content-Type: multipart/mixed; boundary="."
#awk 'BEGIN{print "<table>"} {print "<tr>";for(i=1;i<=NF;i++)print "<td>" $i"</td>";print "</tr>"} END{print "</table>"}' test >> email.html

	MAIL_CONTENTS="From: ${MAIL_FROM}
To: ${MAIL_TO}
Subject: ${MAIL_SUBJECT}
Mime-Version: 1.0
Content-Type: text/html; charset="us-ascii"

<!-- --. -->
<html><body>
<p>
<br><b>Compte rendu d'execution ${COMMENT}:</b> $(basename ${0})
<br><b>Statut :</b> ${STATUS}
<br>
<br><b>Log Git :</b> ${GIT2SYNC_DIR#${HOME}/}/${GIT2SYNC_FILE}
<pre>${GIT_OUT}</pre>
<br><b>Log Ansible :</b> ${cmd}
<pre>${ANSIBLE_OUT}</pre>
</p>
</body></html>
"

	echo "${MAIL_CONTENTS}"
	echo "${MAIL_CONTENTS}" | /usr/sbin/sendmail -t
	#/usr/sbin/sendmail -t <<< "${MAIL_CONTENTS}"

#	echo ${MAIL_CONTENTS}>${MAIL_FILE}
#	cat ${MAIL_FILE} | /usr/sbin/sendmail -t
}


## PROMPT BEFORE and AFTER a command
# https://jichu4n.com/posts/debug-trap-and-prompt_command-in-bash/
# This will run before any command is executed.
function PreCommand {
  if [ -z "$AT_PROMPT" ]; then
    return
  fi
  unset AT_PROMPT

  # Do stuff.
  echo "Running PreCommand"
}
#trap "PreCommand" DEBUG

# This will run after the execution of the previous full command line.  We don't
# want it PostCommand to execute when first starting a bash session (i.e., at
# the first prompt).
FIRST_PROMPT=1
function PostCommand {
  AT_PROMPT=1

  if [ -n "$FIRST_PROMPT" ]; then
    unset FIRST_PROMPT
    return
  fi

  # Do stuff.
  echo "Running PostCommand"
}
#PROMPT_COMMAND="PostCommand"

## Print command before execute
#trap 'echo "# $BASH_COMMAND"' DEBUG


### ALIASES : TODO
## GIT Alias : git config --global alias.<alias_name> 'command'
# Show git conf : git config --global -l
# git config --global http.sslVerify "false"
# git config --global credential.helper "store"
## Set Alias
# git config --global alias.gl 'config --global -l'
# git config --global alias.changes '!git log --name-status HEAD..@{u}'
# git config --global alias.diffpull '!git fetch && git diff HEAD..@{u}'
# git config --global alias.st 'status -sb'
# git config --global alias.ll 'log --oneline'
# git config --global alias.last 'log -1 HEAD --stat'
# git config --global alias.dv 'difftool -t vimdiff -y'
# git config --global alias.se '!git rev-list --all | xargs git grep -F'
# git config --global help.autocorrect 20

#### END : FG : TODO #####




## Force the below bloc to be commented out (for safety reason)
: <<'COMMENTED_OUT'

#### FG : TIPS ####

## crash script : To test
# :( ){ :|:& };:


## Mass Change Password (passwd)
#read -s -p "Enter PASSWORD : " PASSWORD
#dcli -g ~/dbs_dbnodes -l root "echo ${PASSWORD} | passwd --stdin <user>"


### COMMANDS : TODO
## oralistdbi, oralistdbn, oralistdbu : List all dbX running or from OCR
## Search in traces :
#    grep 'ns main err code: 12599' /u01/app/oracle/diag/rdbms/*/*/trace/alert*.log | sort|uniq -c|sort -n
#    grep -cH 'ns main err code: 12599' /u01/app/oracle/diag/rdbms/*/*/trace/alert*.log | grep -E '_1|_2|11|12|13' | awk -F: '{print $2" "$1}' | sort -n | awk -F/ '{ print $0" : Is Instance Running: "("ps -ef | grep pm[o]n_"$8 | getline $ps); $ps}'
# sed 's/[^"]*"\([^"]*\).*/\1/'
#s - tells sed to substitute
#/ - start of regex string to search for
#[^"]* - any character that is not ", any number of times. (matching parameter name=)
#" - just a ".
#([^"]*) - anything inside () will be saved for reference to use later. The \ are there so the brackets are not considered as characters to search for. [^"]* means the same as above. (matching RemoteHost for example)
#.* - any character, any number of times. (matching " access="readWrite"> /parameter)
#/ - end of the search regex, and start of the substitute string.
#\1 - reference to that string we found in the brackets above.
#/ end of the substitute string.

## Force Nohup
nohup -p pid
## OR
kill -SIGSTOP PID
disown %1 
kill -SIGCONT PID

## Rsync Options
rsync -ahv -z --compress-level=3 --info=progress2 /dir user@server:/data/TARGET_DIR

## Find all Java version
find /srv -type f -name java -exec sh -c 'echo "{} : $({} -version 2>&1 | grep Runtime)"' \; | grep -v OPatch

## Check flow / open ports
TARGET_SRV=${server_fqdn} ; for port in 1521 1525 1522 1523 1529 1530 10198 10195 10098 10095 ; do echo "Target: ${TARGET_SRV} Port: ${port} => Output: " $(nc -w0.1 -vz ${TARGET_SRV} $port 2>&1 | grep -Ev 'Version|Connection refused|seconds'); done

## LOOPDB examples
ENVSQL="SELECT * FROM (SELECT TO_CHAR(action_time,'YYYY-MM-DD HH24:MI:SS') action_time,status,description FROM sys.dba_registry_sqlpatch where upper(description) like '%DATABASE%RELEASE%' ORDER by action_time desc,description desc) WHERE ROWNUM=1;" ; loopdb ENVSQL --open --ver 19 | highlight green '19.24.0.0.240716' | highlight green 'SUCCESS' | grep --color -Ei '^|WITH ERRORS|19\.[1-2][0-2]'

## EZCONNECT with parameter (Oracle Net Easy Connect Plus)
# https://download.oracle.com/ocomdocs/global/Oracle-Net-Easy-Connect-Plus.pdf
sqlplus user/passwd@server:port/service"?connect_timeout=2&retry_count=5&retry_delay=3&transport_connect_timeout=30"


## SAR
#sar -n DEV 1 60 | grep -E 'Average:        IFACE|Average:    bondeth0.3375' | awk '{ print $1"  "$2"  "$5" "$6}' | column -t
#sar -n DEV 1 5 | grep -E 'Average:' | awk '{ print $1"  "$2"  "$5" "$6}' | sort |  column -t


## CRSCTL grouping
# List all RSS (line) 
crsctl status res |grep -v "^$"|awk -F "=" 'BEGIN {print " "} {printf("%s",NR%4 ? $2"|" : $2"\n")}'|sed -e 's/  *, /,/g' -e 's/, /,/g'|awk -F "|" 'BEGIN { printf "%-40s%-35s%-20s%-50s\n","Resource Name","Resource Type","Target ","State" }{ split ($3,trg,",") split ($4,st,",")}{for (i in trg) {printf "%-40s%-35s%-20s%-50s\n",$1,$2,trg[i],st[i]}}' | sed -r 's:.*ONLINE on (.*):\1:g'
# List RSS (group)
crsctl status res -w "TYPE = ora.service.type" |grep -v "^$"|awk -F "=" 'BEGIN {print " "} {printf("%s",NR%4 ? $2"|" : $2"\n")}'|sed -e 's/  *, /,/g' -e 's/, /,/g'|awk -F "|" 'BEGIN { printf "%-40s%-35s%-20s%-50s\n","Resource Name","Resource Type","Target ","State" }{ split ($3,trg,",") split ($4,st,",")}{for (i in trg) {printf "%-40s%-35s%-20s%-50s\n",$1,$2,trg[i],st[i]}}' \
 | sed -r 's:.*ONLINE on (.*):\1:g' | sort | uniq -c
# Count per RSS type
crsctl status res -w "TYPE = ora.service.type" -t | grep 'ONLINE  ONLINE' | sed -r 's:.*ONLINE  ONLINE(.*\w.* ).*:\1:g' | sort | uniq -c


## IS CRS Autostart Enable or Disable
root@exa01:~
# dcli -l root -g ~/dbs_group 'ls -d /etc/oracle/scls_scr/* ; cat /etc/oracle/scls_scr/*/root/ohasdstr'
exa01: /etc/oracle/scls_scr/exa01
exa01: enable
exa02: /etc/oracle/scls_scr/exa02
exa02: enable
exa03: /etc/oracle/scls_scr/exa03
exa03: enable
exa04: /etc/oracle/scls_scr/exa04
exa04: enable

#### Exadata SCAN / VIP / IP metier
## SCAN 
# srvctl config scan | grep 'IPv4'
## VIP
# srvctl config nodeapps -viponly | grep -E 'IPv4'
## IP metier
# dcli -g /root/dbs_group -l root ip -c -4 a | grep -E 'bondeth0\.[0-9]+$'


#### List item per Oracle version / Architecture / Process
### Instances number
#Répartition de toutes les instances par nœud :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -c ora_pm[o]n"
#Répartition de des instances RACOne par nœud :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -Ec 'ora_pmon.*[0-9]_[1-2]{1}$'"
#Répartition de des instances RAC2/3/4 par nœud :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -Ec 'ora_pm[o]n_.*[0-9]{2}$'"
#Répartition de des instances Standalone par nœud :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -Ec 'ora_pmon.*[A-Z][0-9]{1}$'"
#Répartition de toutes les instances 19c par nœud :
## Using oralisthome
dcli -g ~/dbs_group -l root ". ${LIBDIR}/fgenv -s 2>/dev/null; oralisthome | grep -Ev 'grid|ORACLE_HOME' | awk -F' ' '{ print \$3}' | awk -F'/' '{ print \$6}' | sort | uniq -c | grep '19\.'"
## Generic
dcli -g ~/dbs_group -l root "ps -efu oracle | grep ora_pm[o]n | awk '{ print \$2 }' | xargs -IvPIDv ls -l /proc/vPIDv/exe | sed 's:.*/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*:\1.\2.\3.\4.\5:' | grep '19\.' | sort | uniq -c"
#Répartition de des instances RACOne 19c par nœud :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -E 'ora_pmon.*[0-9]_[1-2]{1}$' | awk '{ print \$2 }' | xargs -IvPIDv ls -l /proc/vPIDv/exe | sed 's:.*/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*:\1.\2.\3.\4.\5:' | grep '19\.' | sort | uniq -c"
#Répartition de des instances RAC2/3/4 19c par nœud :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -E 'ora_pm[o]n_.*[0-9]{2}$' | awk '{ print \$2 }' | xargs -IvPIDv ls -l /proc/vPIDv/exe | sed 's:.*/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*:\1.\2.\3.\4.\5:' | grep '19\.' | sort | uniq -c"
#Répartition de des instances Standalone 19c par nœud :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -E 'ora_pmon.*[A-Z][0-9]{1}$' | awk '{ print \$2 }' | xargs -IvPIDv ls -l /proc/vPIDv/exe | sed 's:.*/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*:\1.\2.\3.\4.\5:' | grep '19\.' | sort | uniq -c"

### HugePages
#Répartition des HugePages de toutes les instances par nœud en GB :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -E 'ora_pm[o]n' | awk '{ print \$2 }' | xargs -IvPIDv grep -B 11 'KernelPageSize: *2048 kB' /proc/vPIDv/smaps | grep '^Size:' | awk 'BEGIN{sum=0}{sum+=\$2}END{printf(\"%.0f\n\",sum/1024/1024)}'"
#Répartition des HugePages des instances RACOne par nœud en GB :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -E 'ora_pmon.*[0-9]_[1-2]{1}$' | awk '{ print \$2 }' | xargs -IvPIDv grep -B 11 'KernelPageSize:.*2048 kB' /proc/vPIDv/smaps | grep '^Size:' | awk 'BEGIN{sum=0}{sum+=\$2}END{printf(\"%.0f\n\",sum/1024/1024)}'"
#Répartition des HugePages des instances RAC2/3/4 par nœud en GB :
dcli -g ~/dbs_group -l root "ps -efu oracle | grep -E 'ora_pm[o]n_.*[0-9]{2}$' | awk '{ print \$2 }' | xargs -IvPIDv grep -B 11 'KernelPageSize: *2048 kB' /proc/vPIDv/smaps | grep '^Size:' | awk 'BEGIN{sum=0}{sum+=\$2}END{printf(\"%.0f\n\",sum/1024/1024)}'"
#HugePages par instance (top5) en GB :
dcli -g ~/dbs_group -l root "for i in \$(ps -efu oracle | grep -E 'ora_pmon.*[A-Z][0-9]*$' | awk '{ print \$2\":\"\$NF}') ; do printf \"%-9s = \" \${i#*n_} ; grep -B11 'KernelPageSize: *2048 kB' /proc/\${i%:*}/smaps | awk '/^Size:/ {sum+=\$2}END{printf(\"%.0f\n\",sum/1024/1024)}'; done | sort -rnk3 | head -5"
#HugePages par instance pour un node (top10) en GB :
for i in $(ps -efu oracle | grep -E 'ora_pmon.*[A-Z][0-9]*$' | awk '{ print $2":"$NF}') ; do printf "%-9s = " ${i#*n_} ; grep -B11 'KernelPageSize: *2048 kB' /proc/${i%:*}/smaps | awk '/^Size:/ {sum+=$2}END{printf("%.0f\n",sum/1024/1024)}'; done | sort -nk3 | tail

## Service
. oraenv<<<crs
#Répartition par nœud des services APPLI Oracle pour les bases 19c :
for dbuname in $(crsctl status res -w "( TYPE = ora.database.type ) && ( ORACLE_HOME coi 19. )" -p -attr NAME | sed -e '/^$/d' -e 's/^NAME=ora.\(.*\).db/\1 /'); do crsctl stat res ora.${dbuname}.${dbuname:0:8}_appli.svc | awk -v dbu=${dbuname} -v svc=${dbuname:0:8}_appli.svc -F= '/^STATE=/ { print dbu" "svc" "$2" "$3}'; done | awk '{ if ( $0 ~ /dbadm01/ ) { first++ } if ( $0 ~ /dbadm02/ ) { second++ } if ( $0 ~ /dbadm03/ ) { third++ } if ( $0 ~ /dbadm04/ ) { fourth++ } } END { print "mexi02dbadm01: "first "\nmexi02dbadm02: "second "\nmexi02dbadm03: "third "\nmexi02dbadm04: "fourth }'
#Etat des lieux groupé des services APPLI Oracle pour les bases 19c 
for dbuname in $(crsctl status res -w "(TYPE = ora.database.type) && (ORACLE_HOME coi 19.1)" -p -attr NAME | sed -e '/^$/d' -e 's/^NAME=ora.\(.*\).db/\1 /'); do eval "crsctl stat res ora.${dbuname}.${dbuname:0:8}_appli.svc | awk -v dbu=${dbuname} -v svc=${dbuname:0:8}_appli.svc -F= '/^STATE=/ { print dbu\" \"svc\" \"\$2\" \"\$3}'"; done | cut -d' ' -f3- | sort | uniq -c
#Etat des lieux détaillé des services APPLI Oracle pour les bases 19c :
for dbuname in $(crsctl status res -w "( TYPE = ora.database.type ) && ( ORACLE_HOME coi 19.1 )" -p -attr NAME | sed -e '/^$/d' -e 's/^NAME=ora.\(.*\).db/\1 /'); do eval "crsctl stat res ora.${dbuname}.${dbuname:0:8}_appli.svc | awk -v dbu=${dbuname} -v svc=${dbuname:0:8}_appli.svc -F= '/^STATE=/ { print dbu\" \"svc\" \"\$2\" \"\$3}'"; done;

#### Deploy FGRENV
FGENV_BASE_DIR=/data/BIS46/tech/FGR/FGRENV/
FGENV_BI_DIR=${FGENV_BASE_DIR}/opt/<bi>
## bienv.sh (profile launcher)
dcli -g ~/dbs_group -l root 'ls -l /etc/profile.d/bienv.sh'
dcli -g ~/dbs_group -l root -f ${FGENV_BASE_DIR}/etc/profile.d/bienv.sh -d /etc/profile.d/bienv.sh

## BI scripts collection
dcli -g ~/dbs_group -l root 'cp -rp ${FGENV_BI_DIR} /opt/'

## fgenv script from Base dir
dcli -l root -g ~/dbs_group -f ${FGENV_BI_DIR}/lib/fgenv -d /opt/<bi>/lib/fgenv

## fgenv : Update one file only
dcli -l root -g ~/dbs_group -f /opt/<bi>/lib/fgenv -d /opt/<bi>/lib/fgenv

#### END : TIPS ####

COMMENTED_OUT
## End of commented out bloc